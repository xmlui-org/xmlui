<Component name="PdfAsForm">
  <DataSource id="labels" url="/f1040-fields.json" />
  <HStack height="100%">
    <VStack width="60%">
      <Pdf id="myPdf" src="/f1040.pdf" mode="edit" fieldLabels="{labels.value}" />
    </VStack>
    <VStack width="40%" padding="$space-2" gap="$space-1">
      <Table
        when="{myPdf.formFields}"
        data="{myPdf.formFields}"
        size="sm"
      >
        <Column header="Field" bindTo="field" />
        <Column header="Value" bindTo="value" />
      </Table>
    </VStack>
  </HStack>
  <Markdown><![CDATA[
## XMLUI Source

```xml
<DataSource id="labels" url="/f1040-fields.json" />
<Pdf id="myPdf" src="/f1040.pdf" mode="edit" fieldLabels="{labels.value}" />
<Table data="{myPdf.formFields}" size="sm">
  <Column header="Field" bindTo="field" />
  <Column header="Value" bindTo="value" />
</Table>
```

### How it works

The IRS Form 1040 uses **AcroForm** fields with XFA-style naming (e.g. `topmostSubform[0].Page1[0].f1_14[0]`). The `Pdf` component auto-detects these fields and renders them as interactive HTML inputs. The optional `fieldLabels` prop maps raw field IDs to human-readable names â€” loaded here from a JSON file via `DataSource`. As you fill in fields, the table updates reactively with no scripting required.

### What's next

- **Non-AcroForm PDFs**: When a PDF has no embedded form fields, the component's existing annotation/overlay system can be used to manually place input regions by page and coordinates.
- **Richer XMLUI controls**: The field metadata includes type info (text, checkbox, select) and constraints (char limits, dropdown options). A future version could map these to native XMLUI form components for two-way binding.
- **Backend integration**: The captured `formValues` object is ready to send to a backend service for PDF flattening (stamping the data back into the document to produce a filled PDF) and/or cryptographic signing.
  ]]></Markdown>
</Component>
