# Programming Concepts

Creating an app requires defining some UI logic that describes how to react (change the UI) to user interactions and system events. For example, pressing a button or selecting an item in a list should follow an app-specific flow.

XMLUI provides a scripting language (XMLUI Script) with syntax and semantics similar to JavaScript. When the engine detects it is time to run a particular code, it executes the precompiled script.

## Code Locations

You have several choices for declaring XMLUI Script code snippets:

1. You can add the script code inline (within the markup, properties, event handlers, etc.).
2. You can declare code-behind files for your app's main and component files. Code-behind files have the same name as your component and use an additional `.xs` file extension. For example, if your component file is `MyComp.xmlui`, the corresponding code-behind is `MyComp.xmlui.xs`.
3. XMLUI allows you to declare `<script>` sections within the markup (in any component) to describe code regarding a particular component.

**XMLUI does not force you to apply a particular code location. It is up to your preference (coding style) where you put the code.**

You can mix these coding styles within an application if they provide value.

## Inline Code Snippets

Often, you use only small code snippets that explain themselves the best when they are as close to the markup as possible. XMLUI accepts inline code snippets in several locations.

### Property Values

Properties accept expressions (often called _binding expressions_ in XMLUI) that can be combined with string segments.

The following sample uses _binding expressions_ to set the `value` property of a couple of `Text` components. The wrapping curly braces sign the engine that the content between `{` and `}` should be considered a binding expression. When initializing the property's value, the engine evaluates the binding expression and sets the property to the evaluated value:

```ueml copy {4, 7}
<VStack>
  <HStack>
    <Text value="Square root of 2 is:\xa0" />
    <Text value="{Math.sqrt(2)}" />
  </HStack>
  <Text value="Square root of 5 is: {Math.sqrt(5)}" />
</VStack>
```

When rendering the app, the engine evaluates `Math.sqrt(2)` and `Math.sqrt(5)` and displays the expressions' values:

<Playground
  previewOnly={true}
  name="Example: Setting property values"
  height={60}
  horizontal={true}
  app={`
    <VStack>
      <HStack>
        <Text value="Square root of 2 is:\xa0" />
        <Text value="{Math.sqrt(2)}" />
      </HStack>
      <Text value="Square root of 5 is: {Math.sqrt(5)}" />
    </VStack>
  `}
/>

Observe that the second text calculating the square root of 5 combines a binding expression with a literal string segment:

```text
Square root of 5 is: {Math.sqrt(5)}
```

> **Note**: For the expression syntax, check the [XMLUI Expressions](/reference/xmlui-script/binding-expressions) article

### Literal Text Values

You can nest text values into components. These texts can contain binding expressions. When rendering them, XMLUI replaces the expression definitions with their evaluated values:

```ueml copy {2}
<VStack>
  Square root of 3 is: {Math.sqrt(3)}
</VStack>
```

<Playground
  previewOnly={true}
  name="Example: Literal text values"
  height={40}
  horizontal={true}
  app={`
    <VStack>
      Square root of 3 is: {Math.sqrt(3)}
    </VStack>
  `}
/>

### Variable Declarations

Variables are indispensable to the UI logic as they store some state. You can use binding expressions to set a variable initial value:

```ueml copy {2}
<VStack
  var.myValue="{6 * 7}">
  Life, universe, and everything: {myValue}
</VStack>
```

Here, `var.myValue` is a variable declaration with a variable name (`myValue`) and an initial value (`{6 * 7}`). Before displaying the `VStack` component, the engine initializes the `myValue` variable. Thus, when the text is displayed, `{myValue}` is replaced with its current value, 42.

<Playground
  previewOnly={true}
  name="Example: Variables values"
  height={40}
  horizontal={true}
  app={`
    <VStack 
      var.myValue="{6 * 7}">
      Life, universe, and everything: {myValue}
    </VStack>
  `}
/>

XMLUI attribute values are strings by default. When you declare component properties, the components transform string attribute values to the native property types automatically. So, when you set a Boolean property's value to the `"true"` string, the component converts the string to a Boolean `true`. Similarly, components can handle numeric values.

However, variables do not involve any particular logic; they just hold the value they are assigned to. When you initialize a variable value with a literal string, that variable will hold a string. You must use binding expressions to initial a variable with a number or boolean value.

The following sample will demonstrate this concept:

```ueml copy
<VStack
  var.stringValue="true"
  var.boolValue="{true}"
  var.num1Value="123"
  var.num2Value="{123}">
  <Text>'stringValue' is a {typeof stringValue}, it is {stringValue}</Text>
  <Text>'boolValue' is a {typeof boolValue}, it is {boolValue}</Text>
  <Text>'num1Value' is a {typeof num1Value}, it is {num1Value}</Text>
  <Text>'num2Value' is a {typeof num2Value}, it is {num2Value}</Text>
</VStack>
```

Check the variable types in the output:

<Playground
  previewOnly={true}
  name="Example: Variables values and types"
  height={100}
  horizontal={true}
  app={`
    <VStack 
      var.stringValue="true"
      var.boolValue="{true}"
      var.num1Value="123"
      var.num2Value="{123}">
      <Text>'stringValue' is a {typeof stringValue}, it is {stringValue}</Text>
      <Text>'boolValue' is a {typeof boolValue}, it is {boolValue}</Text>
      <Text>'num1Value' is a {typeof num1Value}, it is {num1Value}</Text>
      <Text>'num2Value' is a {typeof num2Value}, it is {num2Value}</Text>
    </VStack>
  `}
/>

> **Note**: XMLUI variables have some particular (and helpful) traits. Later in this document, you will learn more details about them.

### Event Handlers

When a user interaction or system event occurs, the XMLUI engine executes component event handlers. In an event handler, the entire attribute value is an XMLUI Script code snippet, so you do not need to wrap the code into curly braces:

```ueml copy {3}
<Button
  label="Greet me!"
  onClick="window.alert('Howdy!')"
/>
```

If you click the button, the engine executes the `window.alert('Howdy!')` code and displays a dialog:

<Playground
  previewOnly={true}
  name="Example: Event handlers"
  height={60}
  horizontal={true}
  app={`
    <Button 
      label="Greet me!"
      onClick="window.alert('Howdy!')"
    />
  `}
/>

Event handlers may contain not only expressions but also XMLUI statements:

```ueml copy {4-6}
<Button
  label="Sum numbers from 1 to 1000!"
  onClick="
    let sum = 0;
    for (let i = 1; i <= 1000; i++) sum += i;
    window.alert('1 + ... + 1000 = ' + sum);
  "
/>
```

Click the button to execute the event handler code!

<Playground
  previewOnly={true}
  name="Example: Event handlers"
  height={60}
  horizontal={true}
  app={`
    <Button 
      label="Sum numbers from 1 to 1000!"
      onClick="
        let sum = 0;
        for (let i = 1; i <= 1000; i++) sum += i;
        window.alert('1 + ... + 1000 = ' + sum);
      "
    />
  `}
/>

> **Note**: For the available statements and their syntax, check the [XMLUI Syntax](/reference/xmlui-script/xmlui-script) article

Event handlers are functions that may receive parameters. You can declare them using the arrow function syntax. For example, the following sample displays the X and Y coordinates of the mouse when you click the button:

```ueml copy
<Button
  label="Display my click position!"
  onClick="args => window.alert('Mouse: (' + args.clientX + ', ' + args.clientY + ')')"
/>
```

<Playground
  previewOnly={true}
  name="Example: Event handlers"
  height={60}
  horizontal={true}
  app={`
    <Button 
      label="Display my click position!"
      onClick="args => window.alert('Mouse: (' + args.clientX + ', ' + args.clientY + ')')"
    />
  `}
/>

> **Note**: XMLUI understands your intention when defining an event handler. In addition to the arrow function syntax, it accepts several other alternatives, as the [Event Handlers](/reference/xmlui-script/xmlui-script/#event-handlers) section of the XMLUI Statements document describes.

### API Methods

Reusable components can expose API methods to other components. These API methods can use XMLUI Script statements like event handlers. Also, API methods are functions.

You can learn more about APIs in the [Reusable Components](/learning/using-components/reusable-components/#adding-component-apis) article.

## Code-Behind Files

When your code contains several variables and event handlers, you can declare them in a code-behind file to collect code snippets and separate them from the markup. Code-behind files have the same name as the component (or app) file and an additional `.xs` suffix.

A code-behind file can contain only variable and function declarations. Variables can be used just as if they were declared inline; functions can be utilized as event handlers or helpers. **The code you declare in a code-behind file is visible in the entire component but not outside.**

Here is a sample app with a code-behind file. The following is the app's markup in the **Main.xmlui** file:

```ueml copy
 <Button 
  label="Sum numbers from 1 to {endValue}!"
  onClick="sumAndDisplay" />
```

The markup references two identifiers, `endValue`, `sumAndDisplay`, in the **Main.xmlui.xs** code-behind file:

```javascript
var endValue = 123;

function sumAndDisplay() {
  let sum = 0;
  for (let i = 1; i <= endValue; i++) sum += i;
  window.alert('1 + ... + ' + endValue + ' = ' + sum);
}
```

<Playground
  previewOnly={true}
  name="Example: Code-behind file"
  height={60}
  horizontal={true}
  app={`
    <VStack>
      <script>
        var endValue = 123;

        function sumAndDisplay() {
          let sum = 0;
          for (let i = 1; i <= endValue; i++) sum += i;
          window.alert('1 + ... + ' + endValue + ' = ' + sum);
        }
      </script>
      <Button 
        label="Sum numbers from 1 to {endValue}!"
        onClick="sumAndDisplay" />
    </VStack>    
  `}
/>

In the markup, the `Button` component is bound with the `click` event handler explicitly:

```ueml copy {3}
 <Button 
  label="Sum numbers from 1 to {endValue}!"
  onClick="sumAndDisplay" />
```

XMLUI supports implicit event handler binding. When you name your functions following a particular naming convention, XMLUI binds an event handler with its corresponding code-behind function.

In the following example, the button's ID is `myButton`. The markup (**Main.xmlui**) does not have any event handler declaration:

```ueml copy
 <Button id="myButton" label="(Implicit) Sum numbers from 1 to {endValue}!" />
```

The code-behind file (**Main.xmlui.xs**) declares a function with the `myButton_onClick` name:

```javascript /myButton_onClick/
var endValue = 234;

function myButton_onClick() {
  let sum = 0;
  for (let i = 1; i <= endValue; i++) sum += i;
  window.alert('1 + ... + ' + endValue + ' = ' + sum);
}
```

The XMLUI scripting engine recognizes the intention and binds the function with the `click` event handler. The modified app works the same way as the previous one:

<Playground
  previewOnly={true}
  name="Example: Code-behind file with implicit binding"
  height={60}
  horizontal={true}
  app={`
    <VStack>
      <script>
        var endValue = 234;

        function myButton_onClick() {
          let sum = 0;
          for (let i = 1; i <= endValue; i++) sum += i;
          window.alert('1 + ... + ' + endValue + ' = ' + sum);
        }
      </script>
      <Button id="myButton" label="(Implicit) Sum numbers from 1 to {endValue}!" />
    </VStack>    
  `}
/>

When you define implicit and explicit event handlers, the explicit handler prevails. When you change the markup to this one, the engine will use the `onClick` event handler in the markup and ignore the implicit binding in the code-behind file:

```ueml copy
<Button 
  id="myButton" label="(Overwritten) Sum numbers from 1 to {endValue}!" 
  onClick="window.alert('onClicks is overwritten!')" />
```

Try it!

<Playground
  previewOnly={true}
  name="Example: Code-behind file with overwrite"
  height={60}
  horizontal={true}
  app={`
    <VStack>
      <script>
        var endValue = 234;

        function myButton_onClick() {
          let sum = 0;
          for (let i = 1; i <= endValue; i++) sum += i;
          window.alert('1 + ... + ' + endValue + ' = ' + sum);
        }
      </script>
      <Button 
        id="myButton" 
        label="(Overwritten) Sum numbers from 1 to {endValue}!" 
        onClick="window.alert('onClicks is overwritten!')" />
    </VStack>    
  `}
/>

## Variables

Your programs must store some state. Like other (imperative) programming languages, XMLUI Script provides variables. Unlike most programming languages, XMLUI allows you to use two kinds of variables: *component variables* and *helper variables*. They behave as expected; you can initialize them and change (update) their values.

Helper variables are the ones you define in a script with the `let` or `const` keywords, like in this sample:

```javascript
let sum = 0;
const upperBound = 100;
for (let i = 0; i < upperBound) {
  sum += i;
}
```

Component variables are those you declare in the markup with the `var.` prefix or code-behind files and `<script>` tags with the `var` keyword, such as in these examples:

*(code-behind)*:

```javascript /var endValue/
var endValue = 234;

function myButton_onClick() {
  let sum = 0;
  for (let i = 1; i <= endValue; i++) sum += i;
  window.alert('1 + ... + ' + endValue + ' = ' + sum);
}
```

*(markup)*:

```ueml copy /var.count/
<Button var.count="{0}" label="Click to increment: {count}" onClick="count++" />
```

These declarations work precisely just like the `let` variable declarations. However, component variables have some additional capability: they are reactive!

Reactiveness means that the engine detects when any dependency that may influence the variable's value changes. If the engine catches such a change, it re-evaluates the variable's value again and refreshes other variables and the UI.

Here is a short sample:

```ueml copy /var.count/ /var.clickTimes3/
<VStack gap="1rem"
  var.count="{0}"
  var.clickTimes3="{count * 3}">
  <Button 
    label="Click to increment: {count}" 
    onClick="count++" />
  <Text>3 times the click count: {clickTimes3}</Text>  
</VStack>    
```
When you click the button, it increments **only** the `count` variable. However, as `countTimes3` is a reactive variable with `count` as a dependency, updating `count` triggers the re-evaluation of `countTimes3`.

<Playground
  previewOnly={true}
  name="Example: Component variables - reactivity"
  height={100}
  horizontal={true}
  app={`
    <VStack gap="1rem"
      var.count="{0}"
      var.clickTimes3="{count * 3}">
      <Button 
        label="Click to increment: {count}" 
        onClick="count++" />
      <Text>3 times the click count: {clickTimes3}</Text>  
    </VStack>    
  `}
/>

> **Note**: The `VStack` instance defines these variables, which are thus visible in the nested `Button` and `Text` components.

## How XMLUI Code Runs

Though XMLUI uses a scripting language similar to JavaScript and utilizes the JavaScript runtime library, it differs from running native JavaScript code in the browser.

The engine does not create JavaScript code to execute it in the browser; it runs interpreted code created from the source script. These are the main reasons XMLUI prefers this technique:

- It is easier to avoid potential security breaches and work with the browser's CSP (Content Security Policy)
- XMLUI makes intelligent decisions about when to run the code synchronously and when to opt for asynchronous execution.
- XMLUI can make the UI responsive without any special care in the code.

### No Frozen UI

Even if you start an infinite loop in the code, the UI remains responsive:

```ueml
<VStack var.count="{0}" var.loopRuns="{false}" padding="1rem" gap="1rem">
  <HStack gap="1rem">
    <Button enabled="{!loopRuns}"
      label="Start infinite loop"
      themeColor="attention"
      onClick="loopRuns = true; while (loopRuns) count++;"
    />
    <Button
      enabled="{loopRuns}"
      label="Exit infinite loop"
      onClick="loopRuns = false;"/>
  </HStack>
  Counter value: {count}
</VStack>
```

Though the first button starts an infinite loop (if it were native JavaScript, it would block the UI), you can still click the other button, which allows the code to break out of the loop, by setting the `loopRuns` variables to `false`.

This is the event handler with the infinite while loop:

```text
loopRuns = true; while (loopRuns) count++;
```

Now, try the code and break out of the loop by clicking the second button:

<Playground
  previewOnly={true}
  name="Example: No frozen UI"
  height={120}
  horizontal={true}
  app={`
    <VStack var.count="{0}" var.loopRuns="{false}" padding="1rem" gap="1rem">
      <HStack gap="1rem">
        <Button enabled="{!loopRuns}" 
          label="Start infinite loop"
          themeColor="attention"
          onClick="loopRuns = true; while (loopRuns) count++;"
        />
        <Button 
          enabled="{loopRuns}" 
          label="Exit infinite loop" 
          onClick="loopRuns = false;"/>
      </HStack>
      Counter value: {count}
    </VStack>
  `}
/>

### Async Code Execution

The engine runs an event handler and API code using async execution. It does not require you to declare async/await constructs, as you would need in native JavaScript. However, synchronous execution is used when evaluating expressions.

This behavior has a significant consequence: you cannot use property values of variable initializations that run asynchronously.

Property value declarations and variable initializations cannot use asynchronously running expressions, as the engine needs to have their explicit values to render components. For example, in the following markup, using the `delay()` function would raise an error with this message: "Promises (async function calls) are not allowed in binding expressions":

```ueml copy {}
<Text value="My value {delay(100), 123}" />
```

## Components and Scopes

An XMLUI app markup is a hierarchical tree in which each component manages its state. Each component's state consists of a private part that cannot be accessed from outside. However, components may expose an API to access and manipulate their state.

### Component IDs

To access a particular component's exposed properties and methods, you must have a reference to it in the code. You can use the component's identifier as the reference:

```ueml copy /question/
<VStack padding="1rem" gap="1rem" height="100%"
  backgroundColor="{question.value ? 'cyan' : 'transparent'}">
  <Checkbox id="question" initialValue="true" label="Are you interested in this topic?" />
  <Text value="The checkbox above is {question.value ? 'checked' : 'unchecked'}" />
</VStack>
```

In this example, the `Checkbox` component's `id` property is `question,` and so you can access its exposed `value` property as `question.value`.

Click the checkbox and test how the app's UI changes with it!

<Playground
  previewOnly={true}
  name="Example: Accessing component state through ID"
  height={100}
  horizontal={true}
  app={`
    <VStack padding="1rem" gap="1rem" height="100%" 
      backgroundColor="{question.value ? 'cyan' : 'transparent'}">
      <Checkbox id="question" initialValue="true" label="Are you interested in this topic?" />
      <Text value="The checkbox above is {question.value ? 'checked' : 'unchecked'}" />
    </VStack>
  `}
/>

Each component has a unique identifier (assigned by the engine) used internally to access and manage its state through its exposed API. If you want to access a component's state from outside, you must assign an explicit ID to it. When you assign an ID to a particular component, that ID is visible in these scopes:

- When you define a component ID within a reusable component, the ID is visible within the reusable component but not outside.
- Component IDs in the app definition are visible within the entire app definition markup; however, reusable component definitions do not see them.

When you use a component ID in a reusable component (like in the following example), that component ID cannot be seen from outside:

```ueml copy 
<Component name="TopicQuestion">
  <Checkbox id="topic" initialValue="true" label="Are you interested in this topic?" />
  <Text value="The checkbox above is {topic.value ? 'checked' : 'unchecked'}" />
</Component>
```

In this simple app using the `TopicQuestion` component, `VStack` cannot access the checkbox with the `topic` ID (as it is within `TopicComponent`). Thus, the `topic.value` expression will be evaluated as an undefined value, and the stack's background will remain transparent in the checked and unchecked states.

```ueml copy
<VStack padding="1rem" gap="1rem" height="100%" 
  backgroundColor="{topic.value ? 'cyan' : 'transparent'}">
  <TopicQuestion />
</VStack>
```

<Playground
  previewOnly={true}
  name="Example: Accessing component state through ID"
  height={100}
  horizontal={true}
  components={[
    `
      <Component name="TopicQuestion">
        <Checkbox id="topic" initialValue="true" label="Are you interested in this topic?" />
        <Text value="The checkbox above is {topic.value ? 'checked' : 'unchecked'}" />
      </Component>
    `,
  ]}
  app={`
    <VStack padding="1rem" gap="1rem" height="100%" 
      backgroundColor="{topic1.value ? 'cyan' : 'transparent'}">
      <TopicQuestion />
    </VStack>
  `}
/>

XMLUI allows you to refer to a component ID before declaring that component. Look again at the example using the `question` Checkbox:

```ueml copy
<VStack padding="1rem" gap="1rem" height="100%" 
  backgroundColor="{question.value ? 'cyan' : 'transparent'}">
  <Checkbox id="question" initialValue="true" label="Are you interested in this topic?" />
  <Text value="The checkbox above is {question.value ? 'checked' : 'unchecked'}" />
</VStack>
```

It shows that the `VStack` component's `backgroundColor` property refers to the `question` ID. When the engine first time evaluates the `question` variable (before finding out that there is a checkbox with `question` ID), it does not find `question`. However, when the `Checkbox` sets its state, it defines the `question` ID. This state change triggers the evaluation of the `VStack`'s `backgroundColor` property value; at that time, `question` refers to the checkbox.

