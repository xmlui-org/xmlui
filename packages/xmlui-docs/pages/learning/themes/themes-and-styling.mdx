import mySimpleApp from "./samples/my-simple-app.xmlui";
import mySimpleAppLight from "./samples/my-simple-app-light.xmlui";
import gallery from "./samples/gallery.xmlui";
import myThemedApp from "./samples/my-themed-app.xmlui";
import inputs from "./samples/inputs.xmlui";

# Themes and Styling

XMLUI has a solid styling system containing two layers to declare the visual traits of components:

- **Themes**. You can apply themes that set up the overall appearance of the application. When you deploy an application, you can deploy it with multiple themes, allowing users to select their preferred theme. XMLUI ships with a few themes out of the box; you can quickly create your own. Examples are the default XMLUI light and dark themes, the theme built on your company's brand design, etc.
- **Layout properties**. You can assign layout properties to individual or reusable components to customize the appearance of a particular component. For example, the background color of a component, the padding size of a button, the rounding of a border, the font size of a particular component, and many more are all layout properties.

You can use two fundamental strategies (or combine them) when dealing with visual appearance:

1. You can set layout property values _directly_ (to a literal property value) one-by-one. This way of working with layout props may cause a lot of extra work if you use too many of them in your app, and later, you must modify them.
2. You can use _theme variables_ to set layout property values. Theme variables, as their name suggests, are defined in a theme. When you update their value centrally in a theme definition, all components using the particular theme variable will change their appearance accordingly.

Though the first method is faster while prototyping an app, you should use theme variables to avoid style maintenance hell.

You can read more details about layout properties and their usage in the [Component Appearance](./component-appearance) article. Here, you will learn to use, create, and modify themes.

Themes encapsulate not only the styles (colors, spacing, etc.) of components but also other resources, such as icons and fonts. This section will focus on the previous appearance category; however, you can learn more about using your custom fonts and icons in the [Resources](./resources) article.

## Using the Built-in Themes

When you build an application, it will use the XMLUI light theme by default:

<Playground previewOnly={true} name="Example: using the default theme" height={280} horizontal={true} app={mySimpleAppLight} />

Your app has a configuration file (config.json) where you can change several settings, including the app's default theme:

```json copy {6}
{
  "name": "My Super App",
  "globals": {
    "apiUrl": "/myapi"
  },
}
```

Setting the `defaultTheme` configuration value to `solid` will change your app to use a different theme.

<Playground previewOnly={true} name="Example: using the 'solid' theme" height={280} horizontal={true} app={mySimpleApp} defaultTheme="solid" />

You can change the theme's tone by setting the `defaultTone` configuration value. This sample sets the tone to dark:

```json copy {6}
{
  "name": "My Super App",
  "globals": {
    "apiUrl": "/myapi"
  },
  "defaultTone": "dark"
}
```

Now, the theme looks like this:

<Playground previewOnly={true} name="Dark tone" height={280} horizontal={true} app={mySimpleApp} defaultTone="dark" />

> **Note**: You can combine the `defaultTheme` and `defaultTone` settings.

## Using Custom Themes

When creating an app, you often intend to apply your own theme, for example, one that matches your company's brand design elements. You can add that theme to your app if a designer has created it or create a new theme from scratch.

### Using an Existing Theme File

Like your app's configuration file, themes are in separate files (generally within the `themes` folder). Suppose a designer has already prepared a theme file named "our-brand.json". You can quickly add this file to your app through `config.json`:

```json copy {6-7}
{
  "name": "My Super App",
  "globals": {
    "apiUrl": "/myapi"
  },
  "defaultTheme": "our-brand",
  "themes": ["themes/our-brand.json"]
}
```

The designer modified a few brand attributes within the design, such as the color of the background and the button, and she created rounded buttons. To use her theme design, add the `our-brand.json` file (with its relative path under the app folder) to the `theme` configuration property:

<Playground
    previewOnly={true}
    name="Custom theme"
    height={280}
    horizontal={true}
    app={mySimpleApp}
    defaultTheme="our-brand"
    themes={[
        {
            name: "Our Brand Theme",
            id: "our-brand",
            themeVars: {
                "color-bg": "blanchedalmond",
                "color-primary": "purple",
                "color-text-primary": "#202020",
                "radius-Button": "16px",
            },
        },
    ]}
/>

You can add multiple theme files to an app. Suppose the designer has created multiple brand themes (`our-brand`, and `our-brand2`) you can list them in the `themes` property:

```json copy {6-7}
{
  "name": "My Super App",
  "globals": {
    "apiUrl": "/myapi"
  },
  "defaultTheme": "our-brand2",
  "themes": ["themes/our-brand.json", "themes/our-brand2.json"]
}
```

<Playground
    previewOnly={true}
    name="Second theme"
    height={280}
    horizontal={true}
    app={mySimpleApp}
    defaultTheme="our-brand2"
    themes={[
        {
            name: "Our Brand Theme",
            id: "our-brand2",
            tone: "dark",
            themeVars: {
                "color-bg": "saddlebrown",
                "color-primary": "magenta",
                "color-text-primary": "#e0e0e0",
                "radius-Button": "16px",
            },
        },
    ]}
/>

### Creating a new Theme

A theme is defined in a theme file that encapsulates everything you would use within a theme, including theme variables, resources (like fonts and icons),  and their tone-specific variations. Theme variables determine the visual appearance of components. Each of them has a name and a value. The components delivered with XMLUI, your custom components, and third-party components can use these theme variable names to refer to their values.

> **Note**:  While developing an app, you put theme files into the `themes` folder using JSON format and the `.json` file extension.

The following theme file is the complete definition of the `our-brand` theme the designer added to the app in one of the previous steps. This theme includes color variants for light and dark tones:

```json copy
{
  "id": "our-brand-dark",
  "name": "Our Brand Theme",
  "themeVars": {
    "radius-Button": "16px",
  },
  "resources": {
  },
  "tones": {
    "themeVars": {
      "light": {
        "color-bg": "blanchedalmond",
        "color-primary": "purple",
        "color-text-primary": "#e0e0e0"
      },
      "dark": {
        "color-bg": "saddlebrown",
        "color-primary": "magenta",
        "color-text-primary": "#202020"
      }
    },
    "resources": {
    }  
  }
}
```

Here, `id` specified the unique identifier of the theme. You can use this ID to refer to the theme; one occasion to use it is setting the `defaultTheme` setting. The `name` property allows adding a friendly name for the theme.

Each theme has three optional keys:
- `themeVars` for tone-independent theme variable definitions;
- `resources` for tone-independent resource definitions;
- and `tone` for tone-specific theme variables and resources.

> **Note**: We discuss resources in [this article](./resources).

When evaluating the value of a particular theme variable, XMLUI takes the theme-independent variable values and then overrides them with theme-specific values, provided they are defined.

These are the theme variables in the previous theme definition:

```json copy
{
  "themeVars": {
    "radius-Button": "16px",
  },
  "resources": {
  },
  "tones": {
    "themeVars": {
      "light": {
        "color-bg": "blanchedalmond",
        "color-primary": "purple",
        "color-text-primary": "#e0e0e0"
      },
      "dark": {
        "color-bg": "saddlebrown",
        "color-primary": "magenta",
        "color-text-primary": "#202020"
      }
    },
  }
}
```
- `radius-Button` has only a theme-independent definition, so it will be used with light and dark themes.
- `color-bg`, `color-primary`, and `color-text-primary` have tone-specific definitions.

## Theme Variable Semantics

The XMLUI theming engine aspires to allow the creation of new themes and the customizing of existing ones with the least effort. To support this striving, theme variables have a unique naming convention that the engine leverages when rendering visual components.

Each theme name should follow naming convention to leverage the intelligent features of the theming engine:

```text
<propertyName>-<ComponentId>-<trait1>-<trait2>--<state1>--<state2>--<stateN>
```

In this convention, the `<ComponentId>` part is optional.

- Those theme variables that do not use the `<ComponentId>` segment are _app-bound_ variables, for they define visuals that can be applied to the entire application, including multiple types of components.
- The variables with a `<ComponentId>` segment are _component-bound_ variables, which influence only the component's appearance defined by the corresponding ID.

> **Note**: You can define theme variables that do not follow this convention; we call them _unbound_ variables. You can still use them; however, the theming engine simply replaces their occurrences with their values without the intelligence it adds for app-bound and component-bound variables.

### Properties, Traits, and States

Each theme variable is about to define the value of a property influencing the visual appearance of a particular part of the UI. The `<propertyName>` segment defines such a visual property. Here are a few examples:

- `color-text`: text color (or forecolor)
- `color-bg`: background color
- `text-size`: the size of the text
- `line-height`: the height of a text line
- `padding-horizontal`: The value declaring the horizontal padding space
The `<propertyName>` segment should use lowercase letters and dashes.

For the complete list of available `<propertyName>` values, see the [Theme Variables](/components/appearance/theme-variables/#property-names) article in the Component Reference.

The `<trait1>` and `<trait2>` segments describe one or two trait values regarding a particular property (`<propertyName>`).

For example, the `Button` component has two traits that define its appearance. The `themeColor` trait defines the set of colors to use with the button; its available values are `primary`, `secondary`, and `attention`. The `variant` trait specifies the general appearance of the button (whether it has a border at all, etc.) with the values of `solid`, `outlined`, or `ghost`. The `themeColor` is the first trait, and `variant` is the second. So, we can use (among the others) these theme variables with button colors:

- `color-bg-Button-primary-solid`: Defines the background color of a button that is set up to use the `primary` theme color, displayed with the `solid` variant.
- `color-border-Button-attention-ghost`: Specifies the border color of a ghost button displayed with the `attention` theme color.

See the [Theme Variables](/components/appearance/theme-variables/#app-bound-traits) article in the Component Reference for the complete list of app-bound traits. You can check the traits of a particular component on its reference page.

The `<state1>`, ..., `<stateN>` values define visual states that may modify the appearance of a particular UI element or component (regarding a specific trait). Here are a few examples:

- `hover`: The mouse is hovered over the component
- `active`: The particular component is being activated by the user (for example, a user presses down the mouse button while over a button element)
- `focus`: The particular element (e.g., a textbox) currently has the focus

When defining a theme variable, you can define multiple state values (in any order). Let's see a few examples:

- `color-bg-Button-primary-solid--hover`: The background color to use with a `solid` button with the `primary` theme color while the mouse hovers over it.
- `color-border-Button-attention-ghost--focus`: Specifies the border color of a focused ghost button displayed with the `attention` theme color.

For the complete list of available `<state>` values, see the [Theme Variables](/components/appearance/theme-variables/#visual-states) article in the Component Reference.

### Theme Variable Chaining

You earlier learned that theme variables following the naming conventions above are either app- or component-bound. When the name contains a `<ComponentId>` section, it is bound to the component with that ID. The component ID is always the name of the component (with the exact case) as you use them in the markup, For example, `Button` for the `<Button>` component, `AppHeader` for the `<AppHeader>` component, and so on.

> **Note**: The individual XMLUI components are built to leverage as many app-bound theme properties as possible instead of using unnecessary component-bound components. Their design ensures that you can change their visual appearance by modifying only a few theme variables and also allows you to fine-tune the component style.

The theming engine uses several techniques to achieve this behavior. One of them is _theme variable chaining_.

This approach means that theme variables compose a chain, and most fall back to the previous variable on that chain. For example, here is a chain that sets the border color of a solid button using the primary color when the mouse hovers over it:

```text
color-primary
  color-Button
    color-bg-Button
      color-bg-Button-solid
        color-bg-Button-primary
          color-bg-Button-primary-solid
            color-bg-Button-primary-solid--hover
```

Theme variable chaining has two significant behaviors:

- **Traversal from the chain's last (bottom) element toward the first (top).** When the engine looks for a particular theme variable, it searches it from the bottom toward the top, until it finds the particular variable.
- **Tail pruning**. When you set the value of a theme variable somewhere in the chain, the other variables toward the bottom of the chain get cleared (they lose their values).

> **Note**: Components may add logic to generate undefined lower-level theme variable values from upper-level values. For example, the `Button` component automatically creates fallback colors when the `color-Button` theme variable is set.

### Changing App-Bound Variables

Let's examine these behaviors with examples! Here, you see a gallery of assorted buttons, a badge, and a few text components using the default theme (light):

<Playground previewOnly={true} name="Gallery with the default theme" height={440} horizontal={true} app={gallery} />

Let's update the value of `color-primary`! This theme variable is at the top of the theme variable chain.

```json
{
  "color-primary": "orangered"
}
```

Due to the theme variable chaining, all components using the primary color (`Button` instances with their theme color property set to `primary` and `Badge` leverage the primary color) immediately change their appearance:

<Playground
    previewOnly={true}
    name="Changing 'color-primary'"
    height={440}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-primary": "orangered",
            },
        },
    ]}
/>

Try moving the mouse over the buttons labeled as primary and click them! You can see that the change in the `color-primary` theme variable affects other button colors, like the one used to indicate the hovered and pressed states. The theming engine ensures that the changes in `color-primary` update the related visual properties automatically. Besides the hover color, the border color changes, too.

### Changing Component-Bound Variables

Changing `color-primary` updated the primary color of all components, including the `Badge`. Suppose you want to keep the `Badge` component intact, for you intend to change only button colors. In that case, you should use the more specific `color-Button` theme variable, which (as it is a component-bound theme variable), affects only `Button`:

```json
{
  "color-Button": "orangered"
}
```

The result demonstrates that the `Badge` component remained intact. However, all buttons, independently of their color theme (`primary`, `secondary`, or `attention`) and variant (`solid`, `outlined`, or `ghost`) use the same colors.

> **Note**: The `Button` component responds to the changes of the `color-Button` and updates the background, text, and border colors accordingly. It also updates the colors to use with the hover and active states.

<Playground
    previewOnly={true}
    name="Changing 'color-Button'"
    height={440}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-Button": "orangered",
            },
        },
    ]}
/>

### More Specific Variable Changes

The single change of `color-Button` redefined all button colors, which goes against the intention of having several theme colors. If you intend to change only the solid button using the primary color, the best theme variable to modify is `color-Button-primary-solid`:

```json
{
  "color-Button-primary-solid": "orangered"
}
```

The name of the property tells everything about its effect. Here, you can check that it affects only one of the buttons, as expected. Buttons with secondary and attention colors or using the outlined and ghost variants are intact.

<Playground
    previewOnly={true}
    name="Changing 'color-Button-primary-solid'"
    height={440}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-Button-primary-solid": "orangered",
            },
        },
    ]}
/>

Sometimes, you want to override a single visual property of a component, like the background color of the button when it is hovered:

```json
{
  "color-bg-Button--hover": "orangered"
}
```

This theme variable works as you expect! Move the mouse over any button to test the hover effect:

<Playground
    previewOnly={true}
    name="Changing 'color-bg-Button--hover'"
    height={440}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-bg-Button--hover": "orangered",
            },
        },
    ]}
/>

Following this pattern, you can tighten the theme variable to affect only a single button type's hover color, like in this sample:

```json
{
  "color-bg-Button-primary-solid--hover": "orangered"
}
```

Try the hover effect now! You can see now it affects only the top-left button (using the primary color theme with the solid variant):

<Playground
    previewOnly={true}
    name="Changing 'color-bg-Button-primary-solid--hover'"
    height={440}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-bg-Button-primary-solid--hover": "orangered",
            },
        },
    ]}
/>

### Component Theme Classes

Components can form a theming hierarchy. For example, many components represent some inputs, as the following example shows:

```ueml {3,4}
<Form id="driveForm" subject="{{car: 'Toyota Celica', year: '1999'}}" padding=1em>
  <FlowLayout paddingBottom=1em gap=1em>
    <FormItem width="50%" label="Car Type" bindTo="car" autoFocus="true" type="text" />
    <FormItem width="50%" label="Year" bindTo="year" autoFocus="true" type="integer" />
  </FlowLayout>
</Form>
```

<Playground previewOnly={true} name="Input components" height={200} horizontal={true} app={inputs} />

If you want to change their border rounding while keeping other components, such as the buttons intact, you could create a derived theme like this:

```json
{
  "id": "rounded",
  "name": "Rounded theme",
  "themeVars": {
    "radius-TextBox": "160px",
    "radius-NumberBox": "160px"
  }
}
```

The new theme works as you expect:

<Playground
    previewOnly={true}
    name="Input components with theme #1"
    height={200}
    horizontal={true}
    app={inputs}
    defaultTheme="rounded"
    themes={[
        {
            name: "Rounded",
            id: "rounded",
            themeVars: {
                "radius-TextBox": "160px",
                "radius-NumberBox": "160px",
            },
        },
    ]}
/>

Many components function as inputs. When you change some of their generic visual traits, such as the rounding, you will likely change the same trait of multiple component types. For example, you changed the rounding of two components in the previous sample.

What if you intend to change the rounding of ten input component types? Following the pattern above, you would end up with a theme with ten different `radius-<component-name>` theme variables.

XMLUI provides a faster way to do this. Define the theme like this:

```json
{
  "id": "rounded",
  "name": "Rounded theme",
  "themeVars": {
    "radius-Input": "160px",
    "color-bg-Input": "papayawhip"
  }
}
```

This theme changes the rounding and the background color of **all** input components:

<Playground
    previewOnly={true}
    name="Input components with theme #2"
    height={200}
    horizontal={true}
    app={inputs}
    defaultTheme="rounded"
    themes={[
        {
            name: "Rounded",
            id: "rounded",
            themeVars: {
                "radius-Input": "160px",
                "color-bg-Input": "papayawhip",
            },
        },
    ]}
/>

The key to this behavior is the `Input` component name within the `radius-Input` and `color-bg-Input` variable names.

There is no `Input` component. `Input` is just an abstract *theme class name* used from theming. The `TextBox`, `NumberBox`, and other input components (behind the scenes, in their implementation) declare their theming inherits from the abstract `Input` theming. This declaration adds new theme variables to the theme variable chain of input components.

For example, the rounding-related theme variable chain is this for `TextBox`:

```text
radius
  radius-Input
    radius-TextBox
```

> **Note**: The reference information of components describes the theme classes a particular component inherits from.

## Theme Inheritance

You can create new themes deriving from existing themes. This pattern helps you create theme variations quickly and also maintain them.

Supposing you need to construct new theme variants (multiple color options) for your product leveraging the brand design, you can create a new theme for the primary brand elements, such as fonts, sizes, spacing, and other typography traits. You can derive a few others for the color options using this theme as a base. In the derived themes, you define only the colors that distinguish the inherited theme from its base.

### Theme Inheritance Example

Let's create a new theme that applies typography elements according to your company's brand design. This theme defines some font-specific settings, spacings, and a few other traits:

```json
{
  "id": "brand-base",
  "name": "Brand Base Theme",
  "themeVars": {
    "space-base": "0.5rem",
    "font-family": "serif",
    "font-family-Heading": "sans-serif",
    "font-weight-H1": "font-weight-medium",
    "radius": "8px"
  }
}
```

Check how this theme modification changes the font (now it uses a serif font), lightens the heading text's weight, and increases spacing (see the Button).

<Playground
    previewOnly={true}
    name="Base theme according the company brand design"
    height={280}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="brand-base"
    themes={[
        {
            name: "Brand Base Theme",
            id: "brand-base",
            themeVars: {
                "space-base": "0.5rem",
                "font-family": "serif",
                "font-family-Heading": "sans-serif",
                "font-weight-H1": "font-weight-medium",
                radius: "8px",
            },
        },
    ]}
/>

Leveraging theme inheritance, we can create several new themes based on the new company brand design:

```json
[
  {
    "id": "brand-purple",
    "name": "Brand Purple",
    "extends": ["brand-base"],
    "themeVars": {
      "color-primary": "purple"
    }
  },
  {
    "id": "brand-green",
    "name": "Brand Green",
    "extends": ["brand-base"],
    "themeVars": {
      "color-primary": "green"
    }
  }
]
```

All themes use the `extends` property to declare their base theme:

- `brand-purple` inherits `brand-base`. It overrides `color-primary` to get a purplish color.
- `brand-green` is derived from `brand-base`; it changes the primary color to green.

Let's see how the new themes alter the app's appearance:

<Playground
    previewOnly={true}
    name="Purple theme based on the light brand design"
    height={280}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="brand-purple"
    themes={[
        {
            name: "Brand Base Theme",
            id: "brand-base",
            themeVars: {
                "space-base": "0.5rem",
                "font-family": "serif",
                "font-family-Heading": "sans-serif",
                "font-weight-H1": "font-weight-medium",
                radius: "8px",
            },
        },
        {
            name: "Brand Purple",
            id: "brand-purple",
            extends: ["brand-base"],
            themeVars: {
                "color-primary": "purple",
            },
        },
    ]}
/>

<Playground
    previewOnly={true}
    name="Green theme based on the light brand design"
    height={280}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="brand-green"
    themes={[
        {
            name: "Brand Base Theme",
            id: "brand-base",
            themeVars: {
                "space-base": "0.5rem",
                "font-family": "serif",
                "font-family-Heading": "sans-serif",
                "font-weight-H1": "font-weight-medium",
                radius: "8px",
            },
        },
        {
            name: "Brand Green",
            id: "brand-green",
            extends: ["brand-base"],
            themeVars: {
                "color-primary": "green",
            },
        },
    ]}
/>

### Resolving Tone Conflicts

When deriving a new theme from an existing one, theme variable changes may cause undesired effects when the inherited theme changes its tone (for example, from light to dark). Let's see an example demonstrating such a situation!

We change the default theme of the app to emphasize button borders:

```json {5-7}
{
  "id": "em-border",
  "name": "Emphasized Button Border Theme",
  "themeVars": {
    "color-border-Button-primary-solid": "navy",
    "color-border-Button-primary-solid--hover": "purple",
    "thickness-border-Button": "0.25em"
  }
}
```

When you move the mouse over the button (try it!), the border changes to a purple color:

<Playground
    previewOnly={true}
    name="Custom theme with light tone"
    height={230}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="em-border"
    themes={[
        {
            name: "Emphasized Button border theme",
            id: "em-border",
            themeVars: {
                "color-border-Button-primary-solid": "navy",
                "color-border-Button-primary-solid--hover": "purple",
                "thickness-border-Button": "0.25em",
            },
        },
    ]}
/>

Now, create a variant of this theme with the following definition, which changes the Button's color from blue to contrasting orange and adds a darker border color:

```json {6-7}
{
  "id": "em-border-orange",
  "name": "Emphasized Button border with orange",
  "extends": ["em-border"],
  "themeVars": {
    "color-Button": "orange",
    "color-border-Button-primary-solid": "orangered"
  }
}
```

Because the base theme defines the `color-border-Button-primary-solid--hover` theme variable with the `purple` value, we expect that due to the inheritance, the dark theme uses this value and displays a purple color when you hover the mouse over the button.

However, when you try the modified theme, the hover effect changes the border to an orangish color, reflecting the buttons's base color:

<Playground
    previewOnly={true}
    name="Emphasized Button border with orange"
    height={230}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="em-border-orange"
    themes={[
        {
            name: "Emphasized Button Border Theme",
            id: "em-border",
            themeVars: {
                "color-border-Button-primary-solid": "navy",
                "color-border-Button-primary-solid--hover": "mediumorchid",
                "thickness-border-Button": "0.25em",
            },
        },
        {
            name: "Emphasized Button border dark theme",
            id: "em-border-orange",
            extends: ["em-border"],
            themeVars: {
                "color-Button": "orange",
                "color-border-Button-primary-solid": "orangered",
            },
        },
    ]}
/>

*It is not a bug!* When you override the `color-border-Button-primary-solid` theme variable in the derived theme to reflect the dark nature of the theme, the theming engine applies tail pruning and undefines all theme variables behind `color-border-Button-primary-solid` in the theme variable chain. The hovered border color is (`color-border-Button-primary-solid
--hovered`) among the undefined ones; thus, the hovered color does not reflect the purple color declared in the base theme.

You can easily handle tail pruning; add the pruned theme variable definition with a new value that matches the dark theme. In this case, use medium-purple instead of purple:

```json {8}
{
  "id": "em-border-orange",
  "name": "Emphasized Button border orange theme",
  "extends": ["em-border"],
  "themeVars": {
    "color-Button": "orange",
    "color-border-Button-primary-solid": "orangered",
    "color-border-Button-primary-solid--hover": "mediumpurple"
  }
}
```

<Playground
    previewOnly={true}
    name="Emphasized Button border with fixed orange"
    height={230}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="em-border-dark"
    themes={[
        {
            name: "Emphasized Button Border Theme",
            id: "em-border",
            themeVars: {
                "color-border-Button-primary-solid": "navy",
                "color-border-Button-primary-solid--hover": "purple",
                "thickness-border-Button": "0.25em",
            },
        },
        {
            name: "Emphasized Button border dark theme",
            id: "em-border-dark",
            tone: "dark",
            extends: ["em-border"],
            themeVars: {
                "color-Button": "orange",
                "color-border-Button-primary-solid": "orangered",
                "color-border-Button-primary-solid--hover": "mediumpurple",
            },
        },
    ]}
/>

### Inheriting from Multiple Themes

XMLUI supports multiple theme inheritance. You can create a new theme by inheriting properties from more than one theme. This feature is beneficial when you create theme matrixes.

When you create multiple templates for an app, those can be divided into two main groups. Some theme groups define the general appearance, such as font, spacing, sizes, etc. Other groups define only colors. This division offers an opportunity to create theme matrixes where rows convey the general appearance and columns represent the different color variants.

With the multiple theme inheritance in XMLUI, it is easy to create such theme matrixes. Assume you want to define a small theme matrix with three general appearance theme types and three color variants:

| Themes           | Color #1      | Color #2      | Color #3      |
| ---------------- | ------------- | ------------- | ------------- |
| **Apperance #1** | `app1-color1` | `app1-color2` | `app1-color3` |
| **Apperance #2** | `app2-color1` | `app2-color2` | `app2-color3` |
| **Apperance #3** | `app3-color1` | `app3-color2` | `app3-color3` |

By defining six base themes (three for the general appearance and three for the color variants), you can leverage multiple theme inheritance:

- `app1-base`: the theme variants for the first general appearance theme variants with no colors.
- `app2-base`: the theme variants for the second general appearance theme variants with no colors.
- `app3-base`: the theme variants for the third general appearance theme variants with no colors.
- `color1`: the theme variants for the colors variants #1.
- `color2`: the theme variants for the colors variants #2.
- `color3`: the theme variants for the colors variants #3.

Now, you can define the theme matrix cell-by-cell using multiple inheritance:

```json
[
  {
    "id": "app1-color1",
    "name": "App1-Color1",
    "extends": ["app1-base", "color1"]
  },
  {
    "id": "app1-color2",
    "name": "App1-Color2",
    "extends": ["app1-base", "color2"]
  },
  {
    "id": "app1-color3",
    "name": "App1-Color3",
    "extends": ["app1-base", "color3"]
  },
  {
    "id": "app2-color1",
    "name": "App2-Color1",
    "extends": ["app2-base", "color1"]
  },
  {
    "id": "app2-color2",
    "name": "App2-Color2",
    "extends": ["app2-base", "color2"]
  },
  {
    "id": "app2-color3",
    "name": "App2-Color3",
    "extends": ["app2-base", "color3"]
  },
  {
    "id": "app3-color1",
    "name": "App3-Color1",
    "extends": ["app3-base", "color1"]
  },
  {
    "id": "app3-color2",
    "name": "App3-Color2",
    "extends": ["app3-base", "color2"]
  },
  {
    "id": "app3-color3",
    "name": "App3-Color3",
    "extends": ["app3-base", "color3"]
  }
]
```

Though you have nine themes, if, for some reason, you need to modify the themes, it is usually enough to change two of the base themes: one for the general appearance traits and another for colors.

Due to the multiple inheritance, you can be sure that changes in the base themes flow down to derived themes; you do not have to cope with maintaining nine separate themes.
