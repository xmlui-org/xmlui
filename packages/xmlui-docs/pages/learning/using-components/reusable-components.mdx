# Reusable Components

XLMUI has been designed with reusable components in mind. Besides the components out-of-the box, you can use the markup to create and utilize your reusable components within your app.

This article will teach you the gritty-nitty details of component creation and customization.

## Defining Reusable Components

Use the `<Component>` tag to declare a reusable component in the markup. This tag has a mandatory attribute, `name`, a unique identifier to the component. You should use this ID when you declare an instance of the component. As a convention, the component's name must start with an uppercase letter. The following characters of the ID may be letters, digits, the underscore (`_`), or the dollar sign (`$`) character.

The component must have content, at least a single nested tag to define the component's visual representation, and, optionally, it may have variables assigned to the component.

You start with a simple reusable component to display a value with a label. The blueprint of this component is just a few lines of markup:

```ueml copy 
<Component name="LabeledValue">
  <HStack>
    <Text>Label:</Text>
    &nbsp;
    <Text>Value</Text></HStack>
</Component>
```

You can immediately use the new component type, `LableledValue`, putting it into your app using the `<LabeledValue>` tag:

```ueml copy
<VStack padding="1rem" gap="1rem">
  <LabeledValue />
  -- Separator text --
  <LabeledValue />
</VStack>
```

The XMLUI engine displays all `LabeledValue` component instances:

<Playground
    previewOnly
    name="LabeledText"
    components={[`
      <Component name="LabeledValue">
        <HStack><Text>Label</Text>:&nbsp;<Text>Value</Text></HStack>
      </Component>
    `]}
    app={`
    <VStack padding="1rem" gap="1rem">
      <LabeledValue />
      -- Separator text --
      <LabeledValue />
    </VStack>
    `}
    height={150}
/>

## Using Properties

Though reusable components with a static appearance may be helpful, the real power comes when you can define component properties to influence the appearance and behavior of a particular reusable component.

With a few additions, you can allow `LabeledValue` to receive a `label` and a `value` specification:

```ueml copy
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label}:&nbsp;</Text>
    <Text>{$props.value}</Text>
  </HStack>
</Component>
```

The `$props` identifier defines the properties passed to the custom component. You can use the `.` operator to access a particular property. So, `$props.label` and `$props.value` mark the `label` and `value` properties, respectively. As you use these names in binding expressions, the engine will display their run time value.

Use the same markup to pass property values to reusable components as you do for built-in components:

```ueml
<VStack padding="1rem" gap="1rem">
  <LabeledValue label="Firstname" value="Cameron" />
  -- Separator text --
  <LabeledValue label="Lastname" value="Smith" />
</VStack>
```

<Playground
    previewOnly
    name="LabeledText with properties"
    components={[`
      <Component name="LabeledValue">
        <HStack><Text>{$props.label}</Text>:&nbsp;<Text>{$props.value}</Text></HStack>
      </Component>
    `]}
    app={`
    <VStack padding="1rem" gap="1rem">
      <LabeledValue label="Firstname" value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" value="Smith" />
    </VStack>
    `}
    height={150}
/>

> **Note**: XMLUI does not require defining component properties in advance. You just use your property through the `$props` identifier; the engine will immediately understand and render it.

Sometimes, it is helpful to have default values for properties. XMLUI makes it simple using the `??` operator, as you can see in the following component definition:

```ueml
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label ?? '[label]'}:&nbsp;</Text>
    <Text>{$props.value ?? '[none]'}</Text>
  </HStack>
</Component>
```

<Playground
    previewOnly
    name="LabeledText with default property values"
    components={[`
      <Component name="LabeledValue">
        <HStack>
          <Text>{$props.label ?? '[label]'}</Text>:&nbsp;
          <Text>{$props.value ?? '[none]'}</Text>
        </HStack>
      </Component>
    `]}
    app={`
    <VStack padding="1rem" gap="1rem">
      <LabeledValue value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" />
    </VStack>
    `}
    height={150}
/>

## Using Events

Similarly to properties, you can harness a reusable component with custom events.

Create a new reusable component, `<IncButton>`, which increments its value for every click. This component can notify its environment about increments by firing an event. This event receives the current counter as an event parameter:

```ueml copy {4}
<Component name="IncButton">
  <Button 
    label="Click to increment: {count}" var.count="{0}" 
    onClick="count++; $events.incremented(count)" />
</Component>
```

The following app uses the new event to append the number of clicks to a text. The handler of the `incremented` event (`onIncremented`) declares an arrow function where `v` represents the event value, namely, the count of clicks:

```ueml copy
<VStack var.text="">
  <IncButton onIncremented="v => text += ' ' + v" />
  <Text value="{text}" />
</VStack>
```

Try using `<IncButton>` with the `incremented` event:

<Playground
    previewOnly
    name="IncButton with an event"
    components={[`
      <Component name="IncButton">
        <Button 
          label="Click to increment: {count}" var.count="{0}" 
          onClick="count++; $events.incremented(count)" />
      </Component>
    `]}
    app={`
    <VStack var.text="">
      <IncButton onIncremented="v => text += ' ' + v" />
      <Text value="{text}" />
    </VStack>
    `}
    height={100}
/>

## Adding Component APIs

Besides properties and events, you can add custom methods (APIs) to a particular component. You can use these methods in other components to execute an operation or query some information from the component with the API.

The following code snippet shows a modified `<IncButton>` component that offers an API method, `setValue`, to set the button's counter value from outside the component:

```ueml copy {4} 
<Component 
  name="IncButton" 
  var.count="{0}" 
  api.setValue="v => count = v">
  <Button label="Click to increment: {count}" onClick="count++" />
</Component>
```

> **Note**: Variables defined within a reusable component are invisible from outside. However, with an explicit API, you can expose them.

The updated component stores the counter value in a variable belonging to the entire component (and not enclosed within the `<Button>`. This line declares the `setValue` API method with an arrow function with the parameter receiving the new value (`v`).

The following app adds a second button to set the current value of `<IncButton>` to 123 on a click. Here, we provide an `id` for `<IncButton>` to refer to it from the second button:

```ueml copy {3,6}
<VStack>
  <HStack gap="0.2rem">
    <IncButton id="myIncButton" />
    <Button 
      label="Set count to 123!" 
      onClick="myIncButton.setValue(123)" />
  </HStack>
</VStack>
```
The click event handler (`onClick`) of the second button uses the `myIncButton.setValue()` expression to invoke the `setValue` method associated with the `myIncButton` instance.

Try using this simple app:

<Playground
    previewOnly
    name="IncButton with an API"
    components={[`
      <Component name="IncButton" var.count="{0}" api.setValue="v => count = v">
        <Button label="Click to increment: {count}" onClick="count++" />
      </Component>
`]}
    app={`
    <VStack>
      <HStack gap="0.2rem">
        <IncButton id="myIncButton" />
        <Button label="Set count to 123!" onClick="myIncButton.setValue(123)" />
      </HStack>
    </VStack>
    `}
    height={60}
/>

## `<ChildrenSlot>`

You can use the `ChildrenSlot` placeholder within a reusable component's definition to mark the location when the reusable component's children should be injected. Here, `ChildrenSlot` is nested into `VStack` to mark the location to inject `MyStack` children:

```ueml copy {4}
<Component name="MyStack">
  <H2>This is my special Stack</H2>
  <VStack padding="1rem" gap="0.2rem" backgroundColor="cyan">
   <ChildrenSlot/>
  </VStack>
</Component>
```

This sample injects children into `MyStack`:

```ueml copy {2-4}
<MyStack>
 These are the children injected into the
 <H3>MyStack</H3>
 component's ChildrenSlot placeholder
</MyStack>
```

`MyStack` puts the children into the location designated by `ChildrenSlot`:

<Playground
    previewOnly={true}
    name="Example: Using ChildrenSlot"
    horizontal={true}
    height={200}
    components={[
        `
    <Component name="MyStack">
      <H2>This is my special Stack</H2>
      <VStack padding="1rem" gap="0.2rem" backgroundColor="cyan">
       <ChildrenSlot/>
      </VStack>
    </Component>
  `,
    ]}
    app={`
    <MyStack>
     These are the children injected into the
     <H3>MyStack</H3>
     component's ChildrenSlot placeholder
    </MyStack>
  `}
/>

## Component Metadata

XMLUI reusable components are designed to be lightweight, so you do not have to define properties, events, and APIs to allow an app to use the component. For example, without explicitly declaring the properties of `LabeledText` or the events of `IncButton` in the previous examples, you could quickly utilize them through the `$props` object.

However, often, it is helpful if a reusable component can expose its properties, events, and APIs (especially when shared among apps through component libraries). App design tools also benefit from this information.

XMLUI allows you to specify such metadata with a reusable component definition.

_TBD_

