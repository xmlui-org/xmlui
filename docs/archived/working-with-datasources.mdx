import { COMPONENT_DATASOURCE, COMPONENT_LIST, COMPONENT_TABLE, CREATE_THE_APP, DATA_MANIPULATION_WITH_APIACTION, GETTING_STARTED_WITH_XMLUI } from "../meta/pages";

# Data Fetching

In this tutorial, you will learn how to load data from external sources using the `DataSource` component and the `data` property.

This tutorial assumes you already completed either the <SmartLink href={GETTING_STARTED_WITH_XMLUI}>Getting started</SmartLink> section or the <SmartLink href={CREATE_THE_APP}>Contact List</SmartLink> tutorial.
Both provide foundational knowledge this tutorial will build upon.

For a detailed rundown of the available properties, events and API for the `DataSource` component see the <SmartLink href={COMPONENT_DATASOURCE}>`DataSource` reference docs</SmartLink>.

A companion tutorial is also available that deals with data manipulation titled <SmartLink href={DATA_MANIPULATION_WITH_APIACTION}>Data Manipulation with APICall</SmartLink>.

Use the `create-xmlui-app` tool (as you learned from the earlier tutorials). Name your app as you prefer (e.g., `ds-tutorial`). After creating the code, open the app in your code editor (VS Code).

## Emulating a Backend

The app will use a backend to store, retrieve and modify data. However, there is no need to create an actual backend. Instead, you will add an emulated backend with a REST interface for the app using the built-in tooling capabilities of the XMLUI.

Follow these steps to add the emulated backend to the app:

1. Download the [api.ts](/resources/files/tutorials/datasource/api.ts "download") file containing the backend's implementation.
2. Copy this file (`api.ts`) into the `src` folder.

> **Note**: XMLUI uses an emulation deeply integrated with the browser's networking layer. You can use the browser's development tools to check the contents of the requests and responses as if the app was communicating with an actual backend.

Test the backend by adding code that triggers an API endpoint. There is a specific `/test` endpoint which returns a simple response object:

```json
{
  "message": "Hello from the Server!"
}
```

To fetch this simple data, replace the contents of the `Main.xmlui` file with the following:

```xmlui copy filename="Main.xmlui" 
<App layout="vertical-full-header">
  <AppHeader>
    <Text variant="title">DataSource Tutorial</Text>
  </AppHeader>
  <NavPanel>
    <NavLink label="Home" to="/" />
  </NavPanel>
  <Pages>
    <Page url="/">
      <DataSource id="test" url="/api/test" />
      <H1>{test.value.message}</H1>
    </Page>
  </Pages>
  <Footer>Powered by XMLUI</Footer>
</App>
```

Now run the app with `npm start`! The development web server starts and displays the local address (http://localhost:5173/, by default, unless the port is free; otherwise, it will be a different port). Open your browser with the displayed address:

<br/>
<Image alt="Test API" src="/resources/images/datasource-tutorial/test-message.png" />

You are ready to learn using the `DataSource` component! In subsequent sections, you will play with `DataSource` features. You will add more `Page` components to the app in each section demonstrating a particular trait.

## Loading a List of Data

XMLUI can quickly fetch data from an API.
Most XMLUI components have a `data` property to provide them with data - both local and external via API calls.
This property is useful for components that can display a list of items (such as the <SmartLink href={COMPONENT_LIST}>`List`</SmartLink> or <SmartLink href={COMPONENT_TABLE}>`Table`</SmartLink>).

Add the highlighted `NavLink` and `Page` components to the code in the "Main.xmlui" file to populate the `List` component with data!
For the sake of brevity, from now on, we omit the majority of the existing code and shorten the instructions like here:

```xmlui copy filename="Main.xmlui" {2, 4-6}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Simple Data Load" to="/get-data" />
<!-- Append this Page as the last within Pages -->
<Page url="/get-data">
  <List data="/api/shopping-list" />
</Page>
<!-- Omitted -->
```

This short form replaces the entire contents of the `Main.xmlui` file, which should be after following the instructions:

```xmlui copy filename="Main.xmlui" {7,14-16}
<App layout="vertical-full-header">
  <AppHeader>
    <Text variant="title">DataSource Tutorial</Text>
  </AppHeader>
  <NavPanel>
    <NavLink label="Home" to="/" />
    <NavLink label="Simple Data Load" to="/get-data" />
  </NavPanel>
  <Pages>
    <Page url="/">
      <DataSource id="test" url="/api/test" />
      <H1>{test.value.message}</H1>
    </Page>
    <Page url="/get-data">
      <List data="/api/shopping-list" />
    </Page>
  </Pages>
  <Footer>Powered by XMLUI</Footer>
</App>
```

When you select the Simple Data Load menu item (navigate to the `/get-data` page), it will show a list of grocery items:

<br/>
<Image alt="Using the data prop" src="/resources/images/datasource-tutorial/list-items.png" />

The `data` property is capable of handling the fetching of external data from an API endpoint.
Here, the URL points to the local "shopping-list" endpoint that returns a list of grocery items which look like so:

| Attribute | Type    |
| :-------- | :------ |
| id        | number  |
| name      | string  |
| quantity  | number  |
| unit      | string  |
| category  | string  |
| inPantry  | boolean |

## Filtering Incoming Data

A typical pattern involves filtering a list of data after fetching it and passing it to the component to render.
However, you have to use the `DataSource` component instead of the `data` property to do that.

In the `Main.xmlui` file, create a new page with a `DataSource` component and a `List` using the `data` property:

```xmlui copy filename="Main.xmlui" {2, 4-7}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Filtering Data" to="/filter" />
<!-- Append this Page as the last within Pages -->
<Page url="/filter">
  <DataSource id="filteredGroceries" url="/api/shopping-list" />
  <List data="{filteredGroceries.value}" />
</Page>
<!-- Omitted -->
```

The `DataSource` component manages the gritty-nitty details of fetching the data, which you can access through `value`. In this example, the ID of `DataSource` is `filteredGroceries`, so you can refer to the data from that source with `filteredGroceries.data`.

This modification will still list the same data.You can manipulate it like a regular Javascript array. Change the `data` property of `List` to apply a filter condition:

```xmlui copy filename="Main.xmlui" /.filter(item => !item.inPantry)/
<!-- Omitted -->
<Page url="/filter">
  <DataSource id="filteredGroceries" url="/api/shopping-list" />
  <List data="{filteredGroceries.value.filter(item => !item.inPantry)}" />
</Page>
<!-- Omitted -->
```

The filtered list contains fewer items, only those for which the `inPantry` property is `true`:

<br/>
<Image alt="Filtering Data #2" src="/resources/images/datasource-tutorial/filtered-items.png" />

## Loading Indicators

By default, the `List` has a loading spinner that is automatically rendered when data is loaded via the `data` prop.
You can try it with this code:

```xmlui copy filename="Main.xmlui" {2, 4-6}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Loading Indicators" to="/loading" />
<!-- Append this Page as the last within Pages -->
<Page url="/loading">
  <List data="/api/shopping-list-slow" />
</Page>
<!-- Omitted -->
```

As the name in the URL suggests, this API endpoint imitates a slow load operation. While the UI waits for the completion of data fetch, you can see the loading indicator:

<br/>
<Image alt="Filtering Data #2" src="/resources/images/datasource-tutorial/slow-loading.png" />

This behavior is available when you use the `data` prop of `List`. In this case, the `List` component manages the data fetching and knows when the data is being loaded. Thus, it can display the loading indicator.

However, if you use the `data` property of `List` to specify the data, the component does not know if the data is being fetched. The list simply observes that the `data` properties value has been changed.

If you want the `List` to know that data fetching is in progress, use the `loading` property. Update the `Main.xmlui` file:

```xmlui copy filename="Main.xmlui" /loading="{slowGroceries.inProgress}"/
<!-- Omitted -->
<Page url="/loading">
  <DataSource id="slowGroceries" url="/api/shopping-list-slow" />
  <List data="{slowGroceries.value}" loading="{slowGroceries.inProgress}" />
</Page>
<!-- Omitted -->
```

The `loading` property is now bound to the `inProgress` property of the corresponding `DataSource`; while the data is being fetched, `inProgress` is `true`. Thus, the updated code displays the load indicator as in the previous example.

> **Note**: XMLUI uses smart data caching. When you move to another menu and then back to "Loading Indicators", the data is immediately displayed as the app does not fetch it again from the backend. Instead, it utilizes the cached data. Refresh the browser to clear the cache and see the "in progress" effect again.

## Granular Data Selection

Sometimes the response you get from an API has the relevant data nested deeper in the JSON object tree.
Luckily, the `DataSource` component provides a handy property called `resultSelector` that lets you select the specific key in the response object.

Add the following lines highlighted below in the code block:

```xmlui copy filename="Main.xmlui" {2, 4-7}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Granular Data Selection" to="/result-selector" />
<!-- Append this Page as the last within Pages -->
<Page url="/result-selector">
  <DataSource id="selectedGroceries" url="/api/shopping-list-meta" />
  <List data="{selectedGroceries.value}" />
</Page>
<!-- Omitted -->
```

When you visit the newly added page, it displays a "No data available" message:

<br/>
<Image alt="Filtering Data #2" src="/resources/images/datasource-tutorial/no-data.png" />

The reason for this unexpected message is that the response coming from the `/api/shopping-list-meta` endpoint has the following shape:

```javascript
{
  items: shoppingList,
  meta: {
    totalItems: shoppingList.length,
  },
}
```

The `meta` attribute contains some extra information regarding the data coming through but you are only interested in the actual list of shopping items. You can opt to select the `items` key like so:

```xmlui copy filename="Main.xmlui" /selectedGroceries.value.items/
<!-- Omitted -->
<Page url="/result-selector">
  <DataSource id="selectedGroceries" url="/api/shopping-list-meta" />
  <List data="{selectedGroceries.value.items}" />
</Page>
<!-- Omitted -->
```

If you refer to this `DataSource` in several locations, you have to consider the shape of the response and apply the `items` property in each reference. However, you can use the `resultSelector` property of `DataSource` instead to make your code easier to maintain:

```xmlui copy filename="Main.xmlui" /resultSelector="items"/
<!-- Omitted -->
<Page url="/result-selector">
  <DataSource id="selectedGroceries" url="/api/shopping-list-meta" resultSelector="items" />
  <List data="{selectedGroceries.value}" />
</Page>
<!-- Omitted -->
```

Using `resultSelector,` any consumers of the `DataSource` component will consider the `items` property of the response as requested data.

## Using Query Parameters

Query parameters are additional information sent to an API endpoint to fetch data. The backend filters the data using search parameters and transfers only the filtered result.

In the <SmartLink href="#filtering-incoming-data">Filtering Incoming Data</SmartLink> section, you filtered the response data on the client side; here, you will use query parameters to let the backend handle the filtering, sorting, and ordering.

Add a new route with the URL `/query-params`:

```xmlui copy filename="Main.xmlui" {2, 4-7}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Using Query Parameters" to="/query-params" />
<!-- Append this Page as the last within Pages -->
<Page url="/query-params">
  <DataSource id="queriedGroceries" url="/api/shopping-list-query" />
  <List data="{queriedGroceries.value}" />
</Page>
<!-- Omitted -->
```

Specifying query parameters is done using key-value pairs in the `queryParams` property:

```xmlui copy filename="Main.xmlui" /queryParams="{{ limit: 4, inPantry: true }}"/
<!-- Omitted -->
<Page url="/query-params">
  <DataSource 
    id="queriedGroceries" 
    url="/api/shopping-list-query" 
    queryParams="{{ limit: 4, inPantry: true }}" />
  <List data="{queriedGroceries.value}" />
</Page>
<!-- Omitted -->
```

These parameters are appended to the request's URL, and the `DataSource`component will send the following request:

```
/api/shopping-list-query?limit=2&inPantry=true
```


The request retrieves up to four items with their `inPantry` flag set `true`:

<br/>
<Image alt="Query Params Successful" src="/resources/images/datasource-tutorial/filtered-data.png" />

## Adding Header information

In situtations where the request needs certain headers to be present the `headers` prop comes to the rescue.
In the following example, the backend requires a header named `x-api-key` to be present when you call `/api/shopping-list-headers` to authenticate the client.

To add headers to the requests you make, start by adding a new `Page`:

```xmlui copy filename="Main.xmlui" {2, 4-7}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Using Headers" to="/headers" />
<!-- Append this Page as the last within Pages -->
<Page url="/headers">
  <DataSource id="groceriesWithHeaders" url="/api/shopping-list-headers" />
  <List data="{groceriesWithHeaders.value}" />
</Page>
<!-- Omitted -->
```

When you move to the newly added page, it does not display data (instead, it displays an error), as the invoked API expects information in the `x-api-key` header. Modify the code to send this header:

```xmlui copy filename="Main.xmlui" /headers="{{ 'x-api-key': '0001' }}"/
<!-- Omitted -->
<Page url="/headers">
  <DataSource 
    id="groceriesWithHeaders" 
    url="/api/shopping-list-headers" 
    headers="{{ 'x-api-key': '0001' }}" />
  <H2 
    when="{groceriesWithHeaders.value !== undefined}" 
    color="green" 
    value="API Key accepted!" />
  <List data="{groceriesWithHeaders.value}" />
</Page>
<!-- Omitted -->
```

Now, the app displays the data from the backend:

<br/>
<Image alt="Right Headers Sent" src="/resources/images/datasource-tutorial/data-with-header.png" />

## Refetching

XMLUI detects when the displayed data becomes stale and refetches data from the backend.
This mechanic does not work for all situations depending on certain user actions.
To give you more control, the `DataSource` component provides a `refetch` method that can be imperatively called in code logic.
This marks the currently displayed data as stale and enforces a new request to the backend.

Add another `Page` and `NavLink` to the `Pages` and `NavPanel` components respectively:

```xmlui copy filename="Main.xmlui" {2, 4-7}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Refetching" to="/refetch" />
<!-- Append this Page as the last within Pages -->
<Page url="/refetch">
  <DataSource id="refetchedGroceries" url="/api/shopping-list" />
  <List data="{refetchedGroceries.value}" />
</Page>
<!-- Omitted -->
```

Next, add a Button to tie the `refetch` function to the Button's `onClick` method:

```xmlui copy filename="Main.xmlui" {4-7}
<!-- Omitted -->
<Page url="/refetch">
  <DataSource id="refetchedGroceries" url="/api/shopping-list" />
  <Button 
    label="Reload" 
    enabled="{!refetchedGroceries.inProgress}" 
    onClick="refetchedGroceries.refetch()" />
  <List data="{refetchedGroceries.value}" />
</Page>
<!-- Omitted -->
```

Finally, to see how many times the refetch happened, add a `Text` element with a variable called counter.
You also need to increase the counter when the `refetch` is fired:

```xmlui copy filename="Main.xmlui" {2, 7, 8}
<!-- Omitted -->
<Page url="/refetch" var.counter="{0}">
  <DataSource id="refetchedGroceries" url="/api/shopping-list" />
  <Button 
    label="Reload" 
    enabled="{!refetchedGroceries.inProgress}" 
    onClick="counter++; refetchedGroceries.refetch()" />
  <Text variant="subtitle" value="#of refetch operations: {counter}" />
  <List data="{refetchedGroceries.value}" />
</Page>
<!-- Omitted -->
```

<br/>
<Image alt="Refetching" src="/resources/images/datasource-tutorial/refetch-data.png" />

## Unconventional Endpoints & the `body` Prop

There are certain API endpoints that don't respond to a GET request, instead you have to send a POST request to get data.
The `DataSource` component provides access to the `method` of the request sent to the backend.
In this scenario, you will request data from the `/api/shopping-item-unconventional` endpoint which responds only to a POST request.

Add another `Page` and `NavLink` to the `Pages` and `NavPanel` components respectively:

```xmlui copy filename="Main.xmlui" {2, 4}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Unconventional Endpoints" to="/unconventional" />
<!-- Append this Page as the last within Pages -->
<Page url="/unconventional">
  <DataSource id="unconventionalItem" url="/api/shopping-item-unconventional" />
  <H2 value="Item with ID '{itemId}': {JSON.stringify(unconventionalItem.value, null, 2)}" />
</Page>
<!-- Omitted -->
```

However, this request will not work, as there is no GET endpoint for the specified URL. Let's modify the request to use a POST and pass the parameter of the request in its body:

```xmlui copy filename="Main.xmlui" {2, 6-8}/
<!-- Omitted -->
<Page url="/unconventional" var.itemId="{10}">
  <DataSource 
    id="unconventionalItem" 
    url="/api/shopping-item-unconventional" 
    method="post" 
    body="{{ id: itemId }}" />
  <H2 value="Item with ID '{itemId}': {JSON.stringify(unconventionalItem.value, null, 2)}" />
</Page>
<!-- Omitted -->
```
> **Note**: The page defines the value of `itemId` with this attribute: `var.itemId="{10}"`, so the request will retrieve the item with an ID of 10:

<br/>
<Image alt="Handling Unconventional Endpoints" src="/resources/images/datasource-tutorial/unconventional-data.png" />

## Pagination

The pagination of large lists is a commonly used technique in web development and is also supported in XMLUI in the `DataSource` component.
The component has two properties that indicate which attributes contain information on the previous and next pages respectively.

In this section you will modify the original `List` to load its content in pages and fetch the next page when the user clicks a button.

First, add a new `Page` with a simple data list:

```xmlui copy filename="Main.xmlui" {2, 4}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Paging" to="/pagination" />
<!-- Append this Page as the last within Pages -->
<Page url="/pagination">
  <DataSource id="pagedGroceries" url="/api/shopping-list-pagination" />
  <List data="{pagedGroceries.value}" />
</Page>
<!-- Omitted -->
```

> **Note**: At this point, the `/API/shopping-list-pagination` API will not work, as it expects additional information.

Next, you will set the page size in the request query parameters (`queryParams`) and also set the next page selector (`nextPageSelector`):

```xmlui copy filename="Main.xmlui" {6-7}
<!-- Omitted -->
<Page url="/pagination">
  <DataSource
    id="pagedGroceries"
    url="/api/shopping-list-pagination"
    queryParams="{{ size: 4, nextPageParam: $pageParams.nextPageParam }}"
    nextPageSelector="{$response[$response.length-1].id}"
  />
  <List data="{pagedGroceries.value}" />
</Page>
<!-- Omitted -->
```

The `nextPageSelector` property indicates what part of the API response contains the next page information (e.g. a cursor or an item index). In this case, the API expects the last item's ID from the loaded datalist and responds with a slice of the original grocery list using the ID and the size.

The `queryParams` will append two query parameters to the request URL:
the first is the page size (`size`), the second is the item ID set in the `nextPageSelector` (accessed via `$pageParams.nextPageParam`). Note the special `$pageParams` context variable that is provided by the `DataSource` component. It is there so that you can access information on the previous or next pages.

One last thing is to create a trigger to keep fetching new pages. Add a `Button` component with the following `click` event and a `Text` component to display the number of loaded items:

```xmlui copy filename="Main.xmlui" {3-6}
<!-- Omitted -->
<Page url="/pagination">
  <HStack gap="1rem">
    <Button label="Show More" onClick="pagedGroceries.fetchNextPage()" />
    <Text value="Loaded items: {pagedGroceries.value.length}" />
  </HStack>
  <DataSource
    id="pagedGroceries"
    url="/api/shopping-list-pagination"
    queryParams="{{ size: 4, nextPageParam: $pageParams.nextPageParam }}"
    nextPageSelector="{$response[$response.length-1].id}"
  />
  <List data="{pagedGroceries.value}" />
</Page>
<!-- Omitted -->
```

The `DataSource` component provides the `fetchPrevPage` and `fetchNextPage` functions which can be called from both code behind and in event handlers. 

When you navigate to the Paging tab in the app, it displays the first page of items (loads four items): 

<br/>
<Image alt="Polling" src="/resources/images/datasource-tutorial/initial-page-items.png" />

On pressing the button, the `click` event is fired and requests the next list page; now, it displays eight items:

<br/>
<Image alt="Polling" src="/resources/images/datasource-tutorial/next-page-items.png" />

## Polling

Polling in the context of the `DataSource` means that the component checks the backend for data updates in regular intervals and updates the UI accordingly.

By default, the component already checks for data changes, but using the polling feature gives you more control and is helpful in case the data changes rapidly. The length of these intervals can be set using the `pollIntervalInSeconds` property.

In this section, you will set up polling to fetch a number of newly added grocery items added to the list of groceries by the mocked backend.

Add a new `Page` and set the `pollIntervalInSeconds` property to the `DataSource` specifying a reasonably large re-fetch frequency to see it in action:

```xmlui copy filename="Main.xmlui" {2, 4}
<!-- Append this NavLink to the bottom of existing ones -->
<NavLink label="Polling" to="/polling" />
<!-- Append this Page as the last within Pages -->
<Page url="/polling">
  <DataSource id="polledGroceries" url="/api/shopping-list-polled" pollIntervalInSeconds="3" />
  <List data="{polledGroceries.value}" />
</Page>
<!-- Omitted -->
```

When navigating to "/polling", the list of groceries will contain some items.

This API emulates changes in the backend data. Thanks to the polling feature, new grocery items start popping up after 3 seconds. When the list reaches 5 items, the backend clears the table of data and starts populating it again for every API call.

<br/>
<Image alt="Polling" src="/resources/images/datasource-tutorial/polling-1.png" />

## Error Handling

_TBD_

