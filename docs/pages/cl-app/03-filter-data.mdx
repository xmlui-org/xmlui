import { Callout } from 'nextra/components'

# Filter Data

In the previous article, you created and customized a list of contacts. That list displayed all contacts retrieved from the database. However, you often want to display only a subset of them, such as contacts with their review overdue. In this article, you will learn how you can filter data.

Technically, you have two different options for data filtering in a client-server scenario:
1. You call a particular API with the filter condition to retrieve only the requested data.
2. You get the data from the backend and filter it on the client side.

<Callout type="info" emoji="ðŸ“”">
  You may combine these two options: query some pre-filtered data from the backend and apply further filtering in the UI.
</Callout>

In this article, you will implement the filtering functionality with both options.

## Create Filter Pages

Add a few new menu items with their corresponding pages to the app definition in the `Main.xmlui` file. Change the `/contacts` URL representing all contacts to `/contacts/all`. Set up each page to display only the related filter's name:

```ueml copy {9-13, 16, 24-27} filename="Main.xmlui"
<App layout="vertical-full-header">
  <AppHeader>
    <H2>Contact Management</H2>
    <SpaceFiller />
    <ThemeChangerButton showSettings="false" />
  </AppHeader>  
  <NavPanel>
    <NavLink label="Dashboard" to="/" />
    <NavLink label="All Contacts" to="/contacts/all" />
    <NavLink label="Overdue Reviews" to="/contacts/overdue"/>
    <NavLink label="Today's Reviews" to="/contacts/today"/>
    <NavLink label="Upcoming Reviews" to="/contacts/upcoming"/>
    <NavLink label="Completed Reviews" to="/contacts/completed"/>  </NavPanel>
  <Pages>
    <Page url="/">Dashboard</Page>
    <Page url="/contacts/all">
      <Datasource id="categories" url="/api/categories" />
      <List datasource="/api/contacts">
        <property name="itemTemplate">
          <ContactRow item="{$item}" categories="{categories.value}" />
        </property>
      </List>
    </Page>
    <Page url="/contacts/overdue">Overdue</Page>
    <Page url="/contacts/today">Today</Page>
    <Page url="/contacts/upcoming">Upcoming</Page>
    <Page url="/contacts/completed">Completed</Page>
  </Pages>
  <Footer>
    Powered by XMLUI
  </Footer>
</App>
```

The URLs specified at a particular `NavLink` tag will navigate to the page determined by the matching `Page` tag. For example, selecting the Overdue Reviews menu item displays this UI:

<br/>
<Image alt="Task menus" src="/resources/images/get-started/contact-menus.png" />

## Filter on the Client

First, let's focus on filtering the data on the client side. In this scenario, you fetch all data from the backend but filter it before assigning it to the displayed list. All lists use the same logic; the only difference is how they filter the contact data. 

### A Reusable `Contacts` Component

Let's extract this functionality into a new component that receives a filtering function:

Create a new file, `Contacts.xmlui` in the `components` folder, and add this content:

```ueml copy filename="Contacts.xmlui"
<Component name="Contacts">
  <Datasource id="categories" url="/api/categories" />
  <Datasource id="contacts" url="/api/contacts" />
    <List items="{contacts.value.filter($props.predicate)}">
      <property name="itemTemplate">
        <ContactRow item="{$item}" categories="{categories.value}" />
      </property>
    </List>
</Component>
```

The `Contacts` component declares a new `Datasource` to fetch all contacts from the backend. Previously, you set the `datasource` property of the `List` to bind it to the fetched data. You cannot do this direct binding now, as you have to filter the fetched data before passing it to `List`. Instead, filter the contacts by using a predicate function (passed in the `predicate` component property).

<Callout type="info" emoji="ðŸ“”">
  A predicate function accepts a contact record and retrieves a boolean value to indicate whether that particular contact should be in the filtered set.
</Callout>

Update all `Page` tags in the `Main.xmlui` file to use the new `Tasks` component:

```ueml copy {5, 8, 11, 14,17} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/overdue">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/today">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/completed">
    <Contacts predicate="{t => true}"/>
  </Page>
</Pages>
<!-- Omitted -->
```

In this code, you use the same predicate, `t => true`, for each `Contacts` independently from the desired filtering. This predicate will match with every task, so using `Contacts` with the `t => true` predicate will represent all contacts retrieved from the backend.

Now, when you visit any of the contact-related menu functions, the UI displays all contacts.

<br/>
<Image alt="Contact predicates" src="/resources/images/get-started/contact-predicates.png" />


Though contacts still need to be filtered, the new structure makes it easy. To implement a particular filter, you pass the appropriate predicate function to the `Contact` component.

### Update Predicates

Let's finish the job and create the appropriate predicates! 

Create a new `Main.xmlui.xs` file in the `src` folder. As you learned earlier, this is a code-behind file for `Main.xmlui`. Add this function definition to the file:

```javascript copy filename="Main.xmlui.xs"
function getSection(contact) {
  if (contact.reviewCompleted) return 'Completed';
  if (!contact.reviewDueDate) return 'No Due Date';
  if (isToday(contact.reviewDueDate)) return 'Today';
  return (getDate(contact.reviewDueDate) < getDate()) 
    ? 'Overdue' 
    : 'Upcoming'
}
```

This function returns one of these section values of the input contact: `Completed`, `No Due Date`, `Today`, `Overdue`, or `Upcoming`.

Change the `predicate` properties of `Contacts` components in `Main.xmlui`:

```ueml copy {5, 8, 11, 14, 17} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/overdue">
    <Contacts predicate="{t => getSection(t) === 'Overdue'}"/>
  </Page>
  <Page url="/contacts/today">
    <Contacts predicate="{t => getSection(t) === 'Today'}"/>
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts predicate="{t => getSection(t) === 'Upcoming'}"/>
  </Page>
  <Page url="/contacts/completed">
    <Contacts predicate="{t => getSection(t) === 'Completed'}"/>
  </Page>
</Pages>
<!-- Omitted -->
```

Now, contact filtering works as expected. The list of today's reviews contains only contacts belonging to that category.

<br/>
<Image alt="Today's Reviews" src="/resources/images/get-started/review-today.png" />

### Display Contact Counts

From a UX point of view, it would be excellent to display the number of contacts in a particular section with the menu items to indicate, for example, that today we have two reviews to complete.

This feature requires a different approach: you cannot postpone getting a particular contact section count while the user selects that section in the menu; we must query it when the app starts.

With the following steps, you query all contacts when the app starts and create variables that hold the contact records for a particular section:

1. Create a `Datasource` within the main component to fetch the count values for all sections.
2. Add variables that keep the records in a particular contact section.
3. Update the `Contacts` component to use those variables in the data source.
4. Extend the menu item labels with contact counts.

#### Create a `Datasource`

Navigate to the `Main.xmlui` file and add this `Datasource` declaration (after `AppHeader`):

```ueml copy {2} filename="Main.xmlui"
<!-- Insert after AppHeader -->
<Datasource id="contacts" url="/api/contacts" />
<NavPanel>
  <!-- Omitted -->
</NavPanel>
<!-- Omitted -->
```

You can access the current data under this `Datasource` using the `contacts.value` expression (`contacxts` identifies the `Datasource`, `value` represents the fetched data).

#### Add Task Category Variables

Append these variable definitions to the `Main.xmlui.xs` file:

```javascript copy filename="Main.xmlui.xs"
var allContacts = contacts.value.filter(t => true);
var overdueContacts = contacts.value.filter(t => getSection(t) === "Overdue");
var todayContacts = contacts.value.filter(t => getSection(t) === "Today");
var upcomingContacts = contacts.value.filter(t => getSection(t) === "Upcoming");
var completedContacts = contacts.value.filter(t => getSection(t) === "Completed");
```

Each variable represents a particular task category. XMLUI variables are reactive variables: whenever a dependency on the right side (after the equal sign) of the variable definition changes, the engine re-evaluates the variable's values and ensures that all dependent objects, including the UI, are updated.

#### Update the `Contacts` Component

You moved the `Datasource` component to the main component, so you no longer need it in `Contacts`. You will pass the contacts to display in the `data` property (see `$props.data`) of `Contacts`:

```ueml copy filename="Contacts.xmlui"
<Component name="Contacts">
  <Datasource id="categories" url="/api/categories" />
  <List items="{$props.data}">
    <property name="itemTemplate">
      <ContactRow item="{$item}" categories="{categories.value}" />
    </property>
  </List>
</Component>
```

Update the occurrences of `Contacts` in `Main.xmlui` to pass the variables in `data`:

```ueml copy {4, 7, 10, 13, 16} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts data="{allContacts}" />
  </Page>
  <Page url="/contacts/overdue">
    <Contacts data="{overdueContacts}" />
  </Page>
  <Page url="/contacts/today">
    <Contacts data="{todayContacts}" />
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts data="{upcomingContacts}" />
  </Page>
  <Page url="/contacts/completed">
    <Contacts data="{completedContacts}" />
  </Page>
</Pages>
<!-- Omitted -->
```

#### Extend the Menu Item Labels

Only one step remains: extend the `NavItem` labels with the expressions to display the contact record counts:

```ueml copy {4-8} filename="Main.xmlui"
<!-- Omitted -->
<NavPanel>
  <NavLink label="Dashboard" to="/" />
  <NavLink label="All Contacts ({allContacts.length})" to="/contacts/all" />
  <NavLink label="Overdue Reviews ({overdueContacts.length})" to="/contacts/overdue"/>
  <NavLink label="Today's Reviews ({todayContacts.length})" to="/contacts/today"/>
  <NavLink label="Upcoming Reviews ({upcomingContacts.length})" to="/contacts/upcoming"/>
  <NavLink label="Completed Reviews ({completedContacts.length})" to="/contacts/completed"/>
</NavPanel>
<!-- Omitted -->
```

When you run the app, it displays the contact record counts in the menu item labels:

<br/>
<Image alt="Completed tasks" src="/resources/images/get-started/contact-counts.png" />

## Filter on the Server

So far, the app has used a single API endpoint, `/api/contacts` to receive all contact records. However, the API has other endpoints to get filtered data, as the following URLs suggest:

- `/api/contacts/overdue`
- `/api/contacts/today`
- `/api/contacts/upcoming`
- `/api/contacts/completed`

In this section, you will change the code to get filtered contact data from the backend.

### Update `Contacts`

Change the definition of the `Contacts` component by removing the `Datasource` querying all tasks and setting the `datasource` property of the `List` to accept a filter tag:

```ueml copy {3} filename="Contacts.xmlui"
<Component name="Contacts">
  <Datasource id="categories" url="/api/categories" />
  <List datasource="/api/contacts/{$props.filter}">
    <property name="itemTemplate">
      <ContactRow item="{$item}" categories="{categories.value}" />
    </property>
  </List>
</Component>
```

<Callout>
  At this point, the changes are not complete, the app will stop working and display error messages when you refresh the browser. Ignore them; they will go away soon.
</Callout>

The predicates you used with client-side filtering are now within the backend's logic. When you invoke a particular `/api/contacts/<filterTag>` endpoint, the backend will apply the proper filtering. The `Contacts` component receives its filter tag through the `filter` property.

### Update Filter Tags

Remove the `Datasource` tag from `Main.xmlui`, as you no longer need to invoke the `/api/tasks` endpoint.

Change the `Main.xmlui` file to use the filter tags instead of predicates:

```ueml copy {5, 8, 11, 14, 17} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts filter="" />
  </Page>
  <Page url="/contacts/overdue">
    <Contacts filter="overdue" />
  </Page>
  <Page url="/contacts/today">
    <Contacts filter="today" />
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts filter="upcoming" />
  </Page>
  <Page url="/contacts/completed">
    <Contacts filter="completed" />
  </Page>
</Pages>
<!-- Omitted -->
```

Now, the app gets the contact information filtered in the backend. To make sure the previous error messages (due to the incomplete app) go away, refresh the app in the browser:

<br/>
<Image alt="Completed tasks" src="/resources/images/get-started/filter-completed.png" />

### Update Contact Counts

You can see that the menu items show "(undefined)" instead of the current contact count. This situation resulted from removing the `DataSource` from `Main.xmlui`, which was used to calculate contact counts.

The API has an endpoint, `/api/contactcounts`, retrieving the task category counts in an object with properties `all`, `overdue`, `today`, `upcoming`, and `completed`, each representing a particular contact section.

Add a new `Datasource` to the `Main.xmlui` file to fetch the contact counts:

```ueml copy {2} filename="Main.xmlui"
<AppHeader title="Contact Management" />
<Datasource id="contactCounts" url="/api/contactcounts" />
<NavPanel>
  <!-- Omitted -->
</NavPanel>
<!-- Omitted -->
```

Update the menu item labels to use the contact counts retrieved from the server:

```ueml copy {4-8} filename="Main.xmlui"
<!-- Omitted -->
<NavPanel>
  <NavLink label="Dashboard" to="/" />
  <NavLink label="All Contacts ({contactCounts.value.all})" to="/contacts/all" />
  <NavLink label="Overdue Reviews ({contactCounts.value.overdue})" to="/contacts/overdue"/>
  <NavLink label="Today's Reviews ({contactCounts.value.today})" to="/contacts/today"/>
  <NavLink label="Upcoming Reviews ({contactCounts.value.upcoming})" to="/contacts/upcoming"/>
  <NavLink label="Completed Reviews ({contactCounts.value.completed})" to="/contacts/completed"/>
</NavPanel>
<!-- Omitted -->
```

With this step, the contact counts are displayed again (refresh the browser to see the changes):

<br/>
<Image alt="Completed tasks" src="/resources/images/get-started/contact-counts.png" />

Now that you learned how to retrieve and filter data on the client or the backend site, it is time to add a few polishing steps to the app. The following article will show you them.