import { Callout } from 'nextra/components'
import { CL_TUTORIAL3 } from '../../meta/downloads'

# Filter Data

<Callout type="info" emoji="ðŸ“”">
You can continue working with the code you completed in the previous tutorial section. Alternatively, you can download the code from <DownloadLink href={CL_TUTORIAL3}>here</DownloadLink> and carry on. 
</Callout>

In the previous article, you created and customized a list of contacts. That list displayed all contacts retrieved from the database. However, you often want to display only a subset of them, such as contacts with their review overdue. In this article, you will learn how you can filter data.

Technically, you have two different options for data filtering in a client-server scenario:
1. You call a particular API with the filter condition to retrieve only the requested data.
2. You get the data from the backend and filter it on the client side.

<Callout type="info" emoji="ðŸ“”">
  You may combine these two options: query some pre-filtered data from the backend and apply further filtering in the UI.
</Callout>

In this article, you will implement the filtering functionality with both options.

## Create Filter Pages

Add a few new menu items with their corresponding pages to the app definition in the `Main.xmlui` file. Change the `/contacts` URL representing all contacts to `/contacts/all`. Set up each page to display only the related filter's name:

```ueml copy {13-17, 21, 26-29} filename="Main.xmlui"
<App 
  layout="vertical-sticky" 
  name="Contact List Tutorial" 
  logo="resources/logo.svg" 
  logo-dark="resources/logo-dark.svg">
  <AppHeader>
    <H2>Contact Management</H2>
    <SpaceFiller />
    <ToneChangerButton />
  </AppHeader>  
  <NavPanel>
    <NavLink label="Dashboard" to="/" />
    <NavLink label="All Contacts" to="/contacts/all" />
    <NavLink label="Overdue Reviews" to="/contacts/overdue"/>
    <NavLink label="Today's Reviews" to="/contacts/today"/>
    <NavLink label="Upcoming Reviews" to="/contacts/upcoming"/>
    <NavLink label="Completed Reviews" to="/contacts/completed"/>
  </NavPanel>
  <Pages>
    <Page url="/">Dashboard</Page>
    <Page url="/contacts/all">
      <DataSource id="categories" url="/api/categories" />
      <List data="/api/contacts">
        <ContactRow item="{$item}" categories="{categories.value}" />
      </List>
    </Page>
    <Page url="/contacts/overdue">Overdue</Page>
    <Page url="/contacts/today">Today</Page>
    <Page url="/contacts/upcoming">Upcoming</Page>
    <Page url="/contacts/completed">Completed</Page>
  </Pages>
  <Footer>
    Powered by XMLUI
  </Footer>
</App>
```

The URLs specified in the `NavLink` components will navigate to the page determined by the matching `Page` component.
For example, selecting the "Overdue Reviews menu" item displays the following:

<br/>
<Image alt="Task menus" src="/resources/images/get-started/contact-menus.png" />

## Filter on the Client

First, let's focus on filtering the data on the client side.
In this scenario, you will fetch all the data from the backend but filter it before assigning it to the displayed list.
All lists use the same logic; the only difference is how they filter the contact data. 

### A Reusable `Contacts` Component

Next, you will extract this functionality into a new component that receives a filtering function:

Create a new file, `Contacts.xmlui` in the `components` folder, and add this piece of code:

```ueml copy filename="Contacts.xmlui"
<Component name="Contacts">
  <DataSource id="categories" url="/api/categories" />
  <DataSource id="contacts" url="/api/contacts" />
  <List items="{contacts.value.filter($props.predicate)}">
    <ContactRow item="{$item}" categories="{categories.value}" />
  </List>
</Component>
```

The `Contacts` component declares a new `DataSource` component to fetch all contacts from the backend.
Previously, you used the `data` property of the `List` by pointing it to an API endpoint to fetch data.
You cannot do so in this situation, as you have to filter the fetched data before passing it to `List`.
Instead, filter the contacts by using a predicate function (passed in the `predicate` component property).

<Callout type="info" emoji="ðŸ“”">
  A predicate function accepts a contact record and returns a boolean value to indicate whether that particular contact should be in the filtered set.
</Callout>

Update all `Page` tags in the `Main.xmlui` file to use the new `Contacts` component:

```ueml copy {5, 8, 11, 14,17} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/overdue">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/today">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/completed">
    <Contacts predicate="{t => true}"/>
  </Page>
</Pages>
<!-- Omitted -->
```

In this code, you use the same predicate, `t => true`, for each `Contacts` independently from the desired filtering. This predicate will match with every task, so using `Contacts` with the `t => true` predicate will represent all contacts retrieved from the backend.

Now, when you visit any of the contact-related menu functions, the UI displays all contacts.

<br/>
<Image alt="Contact predicates" src="/resources/images/get-started/contact-predicates.png" />


Though contacts still need to be filtered, the new structure makes it easy. To implement a particular filter, you pass the appropriate predicate function to the `Contact` component.

### Update Predicates

Let's finish the job and create the appropriate predicates! 

Create a new `Main.xmlui.xs` file in the `src` folder. As you learned earlier, this is a code-behind file for `Main.xmlui`. Add this function definition to the file:

```javascript copy filename="Main.xmlui.xs"
function getSection(contact) {
  if (contact.reviewCompleted) return 'Completed';
  if (!contact.reviewDueDate) return 'No Due Date';
  if (isToday(contact.reviewDueDate)) return 'Today';
  return (getDate(contact.reviewDueDate) < getDate()) 
    ? 'Overdue' 
    : 'Upcoming'
}
```

This function returns one of these section values of the input contact: `Completed`, `No Due Date`, `Today`, `Overdue`, or `Upcoming`.

Change the `predicate` property of all `Contacts` components in `Main.xmlui`:

```ueml copy {5, 8, 11, 14, 17} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts predicate="{t => true}"/>
  </Page>
  <Page url="/contacts/overdue">
    <Contacts predicate="{t => getSection(t) === 'Overdue'}"/>
  </Page>
  <Page url="/contacts/today">
    <Contacts predicate="{t => getSection(t) === 'Today'}"/>
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts predicate="{t => getSection(t) === 'Upcoming'}"/>
  </Page>
  <Page url="/contacts/completed">
    <Contacts predicate="{t => getSection(t) === 'Completed'}"/>
  </Page>
</Pages>
<!-- Omitted -->
```

Now, contact filtering works as expected. The list of today's reviews contains only contacts belonging to that category.

<br/>
<Image alt="Today's Reviews" src="/resources/images/get-started/review-today.png" />

### Display Contact Counts

From a UX point of view, it would be good to display the number of contacts in a particular section with the menu items to indicate, for example, that today there are two reviews to be done.

This feature requires a different approach: you cannot postpone getting the number of contacts in a particular section while the user selects that section in the menu; we must query it when the app starts.

With the following steps, you will query all contacts when the app starts and create variables that contain the contact records for a particular section:

1. Create a `DataSource` component within the main component to fetch the number of items in every section.
2. Add variables that keep the records in a particular section.
3. Update the `Contacts` component to use those variables in the data source.
4. Append the contact counts to the menu item labels.

#### Create a `DataSource`

Navigate to the `Main.xmlui` file and add this `DataSource` declaration (after `AppHeader`):

```ueml copy {2} filename="Main.xmlui"
<!-- Insert after AppHeader -->
<DataSource id="contacts" url="/api/contacts" />
<NavPanel>
  <!-- Omitted -->
</NavPanel>
<!-- Omitted -->
```

You can access the current data under this `DataSource` using the `contacts.value` expression (`contacts` identifies the `DataSource`, `value` represents the fetched data).

#### Add Task Category Variables

Append these variable definitions to the `Main.xmlui.xs` file:

```javascript copy filename="Main.xmlui.xs"
var allContacts = contacts.value.filter(t => true);
var overdueContacts = contacts.value.filter(t => getSection(t) === "Overdue");
var todayContacts = contacts.value.filter(t => getSection(t) === "Today");
var upcomingContacts = contacts.value.filter(t => getSection(t) === "Upcoming");
var completedContacts = contacts.value.filter(t => getSection(t) === "Completed");
```

Each variable represents a particular task category.
XMLUI variables are reactive variables: whenever a dependency on the right side (after the equal sign) of the variable definition changes,
the engine re-evaluates the variable's value and ensures that all dependent objects, including the UI, are updated.

#### Update the `Contacts` Component

You moved the `DataSource` component to the main component, so you no longer need it in `Contacts`.
Pass the contacts to display in the `data` property of `Contacts` (see `$props.data`):

```ueml copy filename="Contacts.xmlui"
<Component name="Contacts">
  <DataSource id="categories" url="/api/categories" />
  <List items="{$props.data}">
    <ContactRow item="{$item}" categories="{categories.value}" />
  </List>
</Component>
```

Update the occurrences of `Contacts` in `Main.xmlui` to pass the variables in `data`:

```ueml copy {4, 7, 10, 13, 16} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts data="{allContacts}" />
  </Page>
  <Page url="/contacts/overdue">
    <Contacts data="{overdueContacts}" />
  </Page>
  <Page url="/contacts/today">
    <Contacts data="{todayContacts}" />
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts data="{upcomingContacts}" />
  </Page>
  <Page url="/contacts/completed">
    <Contacts data="{completedContacts}" />
  </Page>
</Pages>
<!-- Omitted -->
```

#### Update the Menu Item Labels

One final step remains: extend the `NavItem` labels with the expressions to display the number of contact records:

```ueml copy {4-8} filename="Main.xmlui"
<!-- Omitted -->
<NavPanel>
  <NavLink label="Dashboard" to="/" />
  <NavLink label="All Contacts ({allContacts.length})" to="/contacts/all" />
  <NavLink label="Overdue Reviews ({overdueContacts.length})" to="/contacts/overdue"/>
  <NavLink label="Today's Reviews ({todayContacts.length})" to="/contacts/today"/>
  <NavLink label="Upcoming Reviews ({upcomingContacts.length})" to="/contacts/upcoming"/>
  <NavLink label="Completed Reviews ({completedContacts.length})" to="/contacts/completed"/>
</NavPanel>
<!-- Omitted -->
```

When you run the app, it displays the contact record counts in the menu item labels:

<br/>
<Image alt="Completed tasks" src="/resources/images/get-started/contact-counts.png" />

## Filter on the Server

So far, the app has used a single API endpoint, `/api/contacts` to receive all contact records.
However, the API has other endpoints to get filtered data, as the following URLs indicate:

- `/api/contacts/overdue`
- `/api/contacts/today`
- `/api/contacts/upcoming`
- `/api/contacts/completed`

In this section, you will change the code to get filtered contact data from the backend.

### Update `Contacts`

Change the definition of the `Contacts` component by removing the `DataSource` querying all tasks and setting the `data` property of the `List` to accept a filter tag:

```ueml copy {3} filename="Contacts.xmlui"
<Component name="Contacts">
  <DataSource id="categories" url="/api/categories" />
  <List data="/api/contacts/{$props.filter}">
    <ContactRow item="{$item}" categories="{categories.value}" />
  </List>
</Component>
```

<Callout>
  At this point, the changes are not complete, the app will stop working and display error messages when you refresh the browser. Ignore them; they will go away soon.
</Callout>

The predicates you used with client-side filtering are now coming from the backend.
When you invoke a particular `/api/contacts/<filterTag>` endpoint, the backend will apply the proper filtering.
The `Contacts` component receives its filter tag through the `filter` property.

### Update Filter Tags

Remove the `DataSource` tag from `Main.xmlui`, as you no longer need to invoke the `/api/contacts` endpoint.

Change the `Main.xmlui` file to use the filter tags instead of predicates:

```ueml copy {5, 8, 11, 14, 17} filename="Main.xmlui"
<!-- Omitted -->
<Pages>
  <Page url="/">Dashboard</Page>
  <Page url="/contacts/all">
    <Contacts filter="" />
  </Page>
  <Page url="/contacts/overdue">
    <Contacts filter="overdue" />
  </Page>
  <Page url="/contacts/today">
    <Contacts filter="today" />
  </Page>
  <Page url="/contacts/upcoming">
    <Contacts filter="upcoming" />
  </Page>
  <Page url="/contacts/completed">
    <Contacts filter="completed" />
  </Page>
</Pages>
<!-- Omitted -->
```

Now, the app gets the contact filtered information from the backend.
To make sure the pontential error messages go away (that came up due to incomplete code), refresh the app in the browser:

<br/>
<Image alt="Completed tasks" src="/resources/images/get-started/filter-completed.png" />

### Update Contact Counts

You can see that the menu items show "(undefined)" instead of the current contact count.
This situation resulted from removing the `DataSource` from `Main.xmlui`, which was used to calculate contact counts.

The API has an endpoint, `/api/contactcounts`,
retrieving the task category counts in an object with properties `all`, `overdue`, `today`, `upcoming`, and `completed`,
each representing a particular contact section.

Add a new `DataSource` to the `Main.xmlui` file to fetch the contact counts:

```ueml copy {2} filename="Main.xmlui"
<!-- After AppHeader -->
<DataSource id="contactCounts" url="/api/contactcounts" />
<NavPanel>
  <!-- Omitted -->
</NavPanel>
<!-- Omitted -->
```

Update the menu item labels to use the contact counts retrieved from the server:

```ueml copy {4-8} filename="Main.xmlui"
<!-- Omitted -->
<NavPanel>
  <NavLink label="Dashboard" to="/" />
  <NavLink label="All Contacts ({contactCounts.value.all})" to="/contacts/all" />
  <NavLink label="Overdue Reviews ({contactCounts.value.overdue})" to="/contacts/overdue"/>
  <NavLink label="Today's Reviews ({contactCounts.value.today})" to="/contacts/today"/>
  <NavLink label="Upcoming Reviews ({contactCounts.value.upcoming})" to="/contacts/upcoming"/>
  <NavLink label="Completed Reviews ({contactCounts.value.completed})" to="/contacts/completed"/>
</NavPanel>
<!-- Omitted -->
```

With this step, the contact counts are displayed again (refresh the browser to see the changes):

<br/>
<Image alt="Completed tasks" src="/resources/images/get-started/contact-counts.png" />

Now that you learned how to retrieve and filter data on the client or the backend site, it is time to add a few finishing touches to the app.
The next article will show you how.