import { Callout } from 'nextra/components'

# A Few Finishing Touches

There are a few things left to improve the user experience in our app.
In this section, you will make minor changes to enhance the app's look and feel.

## Fetching the Number of Records

When the app starts, it takes a fraction of a second to reach the backend and retrieve the number of contact records to display.
You may still see an "(undefined)" label while the data loads.
We can quickly fix this by showing a "loading..." message while the contact data is retrieved from the database.

Add a new function, `countLabel` to `Main.xmlui.xs`:

```javascript copy filename="Main.xmlui.xs"
function countLabel(cat) { 
  return contactCounts.inProgress ? "loading..." : contactCounts.value[cat];
}
```

This function takes a name (the name of the contact section) as its argument and retrieves the corresponding number of contact categories. 
The "true" value of the `contactCounts.inProgress` property indicates whether the `DataSource` (with the `contactCounts` id) retrieving the contact counts is currently fetching data.

Update the task count expression in the menu item labels to leverage the new, improved display:

```ueml copy {4-8} filename="Main.xmlui"
<!-- Omitted -->
<NavPanel>
  <NavLink label="Dashboard" to="/" />
  <NavLink label="All Contacts ({countLabel('all')})" to="/contacts/all" />
  <NavLink label="Overdue Reviews ({countLabel('overdue')})" to="/contacts/overdue"/>
  <NavLink label="Today's Reviews ({countLabel('today')})" to="/contacts/today"/>
  <NavLink label="Upcoming Reviews ({countLabel('upcoming')})" to="/contacts/upcoming"/>
  <NavLink label="Completed Reviews ({countLabel('completed')})" to="/contacts/completed"/>
</NavPanel>
<!-- Omitted -->
```

Now, instead of "undefined", labels display "loading...":

<br/>
<Image alt="Loading message" src="/resources/images/get-started/loading-message.png" />

## Displaying List Sections

The `List` component supports the grouping of list items according to a specified attribute.
It has a `sectionBy` property that enables this grouping.
The `List` identifies each unique value of the attribute given to `sectionBy` and groups the items accordingly.

We have already created the `getSections` function within `Main.xmlui.xs`, which comes in handy for grouping.
It is currently in the `Main.xmlui.xs` file, but we need it in the `Contacts` component.

Create a code-behind file for `Contacts` within the `components` folder called `Contacts.xmlui.xs`.
Move the `getSections` function from `Main.xmlui.xs` to this file:

```javascript copy filename="Contacts.xmlui.xs"
function getSection(contact) {
  if (contact.reviewCompleted) return "Completed";
  if (!contact.reviewDueDate) return "No Due Date";
  if (isToday(contact.reviewDueDate)) return "Today";
  return getDate(contact.reviewDueDate) < getDate() ? "Overdue" : "Upcoming";
}
```

Update the code in `Contacts` to add a `section` field to the contact items:

```ueml copy {4} filename="Contacts.xmlui" /section: getSection(t)/
<Component name="Contacts">
  <DataSource id="categories" url="/api/categories" />
  <DataSource id="contacts" url="/api/contacts/{$props.filter}" />
  <List items="{contacts.value.map(t => ({...t, section: getSection(t)}))}">
    <ContactRow item="{$item}" categories="{categories.value}" />
  </List>
</Component>
```

<Callout type="info" emoji="ðŸ“”">
  Here, the `items` property of `List` receives a list of items, each extended with the section information.
</Callout>

To display the section information, add the `section` property to the `List` and define the template to display section headers:

```ueml copy {6, 8-14} filename="Contacts.xmlui"
<Component name="Contacts">
  <DataSource id="categories" url="/api/categories" />
  <DataSource id="contacts" url="/api/contacts/{$props.filter}" />
  <List 
    items="{contacts.value.map(t => ({...t, section: getSection(t)}))}"
    sectionBy="section">
    <ContactRow item="{$item}" categories="{categories.value}" />
    <property name="sectionTemplate">
      <HStack horizontalPadding="$space-normal" verticalPadding="$space-tight">
        <Text 
          variant="subtitle"
          value="{$item.sectionKey} ({loading(contacts, $item.sectionItems.length ?? 0)})" />
      </HStack>
    </property>
  </List>
</Component>
```

In the section template, you can utilize the `$item` property to access the section key and the items within that section.

To finish up, add the following function to `Contacts.xmlui.xs`:

```javascript copy filename="Contacts.xmlui.xs"
function loading(contacts, count) {
  return contacts.inProgress ? "loading..." : count;
}
```

Now, When you display all contacts, you can see that items are sectioned:

<br/>
<Image alt="Sectioned items" src="/resources/images/get-started/sectioned-items.png" />

## Expanding and Collapsing Sections

The sections of a list can be expanded or collapsed.
Unless you declare otherwise, all sections are expanded by default.
Besides `$items`, each section receives a `$context` value, through which you can query the state of the section (`isExpanded`) and use the `toggle` function to expand or collapse the section.

Update the `List` definition in `Contacts`:

```ueml copy {8-22} filename="Contacts.xmlui"
<Component name="Contacts">
  <DataSource id="categories" url="/api/categories" />
  <DataSource id="contacts" url="/api/contacts/{$props.filter}" />
  <List 
    items="{contacts.value.map(t => ({...t, section: getSection(t)}))}"
    sectionBy="section">
    <ContactRow item="{$item}" categories="{categories.value}" />
    <property name="sectionTemplate">
      <HStack 
        horizontalPadding="$space-normal" 
        verticalPadding="$space-tight"
        verticalAlignment="center"
        onClick="() => $context.toggle()">
          <Text 
            variant="subtitle" 
            value="{$item.sectionKey} ({loading(contacts, $item.sectionItems.length ?? 0)})" />
        <SpaceFiller />
        <Icon 
          name="{$context.isExpanded ? 'chevrondown' : 'chevronright'}" 
          size="md" />  
      </HStack>
    </property>
  </List>
</Component>
```

Now, you can expand or collapse sections by clicking them. The following figure shows the Completed section in its collapsed state:

<br/>
<Image alt="collapsed sections" src="/resources/images/get-started/section-collapsed.png" />

## Section Ordering

The order of sections displayed above could be more helpful using a different ordering.
With the help of the `defaultSections` property of the `List`, you can define the ordering.

Modify the `List` accordingly:

```ueml copy {4} filename="Contacts.xmlui"
<!-- Omitted -->
<List 
  items="{contacts.value.map(t => ({...t, section: getSection(t)}))}"
  defaultSections="{['Overdue', 'Today', 'Upcoming', 'No Due Date', 'Completed']}"
  sectionBy="section">
  <!-- Omitted -->
</List>
<!-- Omitted -->
```

You can see the updated section order:

<br/>
<Image alt="Sections ordered" src="/resources/images/get-started/sections-ordered.png" />

## Omitting Empty Sections

By specifying the default sections, the filtered lists also display them.
So when you visit a filtered list, such as "Today's Reviews", it displays empty sections:

<br/>
<Image alt="empty sections" src="/resources/images/get-started/empty-sections.png" />

Modify the code to omit them whenever we display a filtered list:

```ueml copy {4-5} filename="Tasks.xmlui"
<!-- Omitted -->
<List 
  items="{contacts.value.map(t => ({...t, section: getSection(t)}))}"
  defaultSections="{!$props.filter
    ? ['Overdue', 'Today', 'Upcoming', 'No Due Date', 'Completed'] : undefined}"
  sectionBy="section">
  <!-- Omitted -->
</List>  
<!-- Omitted -->
```

Now, the empty sections are no longer displayed:

<br/>
<Image alt="no empty sections" src="/resources/images/get-started/no-empty-sections.png" />

So far, you have displayed only read-only data. In the following section, you will create, edit, and delete contact data.