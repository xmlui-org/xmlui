import { Callout } from 'nextra/components'
import { CL_TUTORIAL2 } from '../../meta/downloads'

# Display Data in a List

At the end of the previous article, you fetched data from the emulated backend and displayed it as a JSON structure to test the backend. In this article, you will learn how to use data-aware components to display data.

<Callout type="info" emoji="ðŸ“”">
You can continue working with the code you completed in the previous tutorial section. Alternatively, you can download the code from <DownloadLink href={CL_TUTORIAL2}>here</DownloadLink> and carry on. 
</Callout>

## Fetching Data from API

With XMLUI, fetching data from a REST API is straightforward.
The `data` property, which accepts local data, also handles data fetching if the value provided looks like a URL string.
Components manage all aspects of the data fetching operation.

Replace the `Page` tag with the `/contacts` URL to use the following contents:

```ueml copy {3} filename="Main.xmlui"
<!-- Omitted -->
<Page url="/contacts">
  <List data="/api/contacts" />
</Page>
<!-- Omitted -->
```

If the app is not running yet, start it on your web server and visit the app's page in your browser. The code snipped you have just added displays some contact data when you click the Contacts menu:

<br/>
<Image alt="Default task list" src="/resources/images/get-started/default-contact-list.png" />

The `List` component does not know anything about the semantics and structure of the data. Unless you provide some hints (or a sophisticated description) of the UI to display a particular data item, `List` will display a simple layout selecting a field as a title and another as a subtitle.

The default layout is good for quick prototyping, but in this case, you need a better way to display fetched data!

## Customizing the List

The list component is versatile and provides several services, making it easy to customize the layout. In this section, you will change the outlook of list items. A contact record has these fields (columns):

| Field | Type | Description |
| --- | --- | --- |
| id | integer | The unique identifier of the contact |
| fullName | string | The contact's name |
| categoryId | integer | Reference to the category ID of the contact |
| comments | string | Additional information about the contact |
| reviewDueDate | date | The date when the contact should be reviewed |
| reviewCompleted | boolean | Indicates whether the review is completed |

The default display of the list uses the `fullName` and then `categoryId` fields. If you want to change the default view of an item, you can modify the template used to show a particular item. Modify the `List` component's definition to use a different template:

```ueml copy {3} filename="Main.xmlui"
<!-- Omitted -->
<List data="/api/contacts">
  <Card title="{$item.fullName}" subtitle="{$item.comments}" />
</List>
<!-- Omitted -->
```

<br/>
<Image alt="Template with Card" src="/resources/images/get-started/template-with-card.png" />

The code utilizes the `Card` component, a simple container to display cohesive data, such as record fields. This component has a predefined layout we can leverage through the `title` and `subtitle` fields. Take note of the `$item` context value; it represents the current item the template should display. So `$item.fullName` and `$item.comments` are the fields of the current contact record.

## Adding and Formatting Fields

Let's change the layout of the items to something more attractive and helpful. Modify the nested items of `List` as in the following code snippet:

```ueml copy {3-14} filename="Main.xmlui"
<!-- Omitted -->
<List data="/api/contacts">
  <Card>
    <HStack verticalAlignment="center">
      <Checkbox initialValue="{$item.reviewCompleted}" />
      <VStack width="*" gap="0">
        <Text variant="strong">{$item.fullName}</Text>
        <Text>{$item.comments}</Text>
      </VStack>
      <HStack verticalAlignment="center" horizontalAlignment="end">
        <Text>{smartFormatDate($item.reviewDueDate)}</Text>
      </HStack>
    </HStack>
  </Card>
</List>
<!-- Omitted -->
```

Here, you add a checkbox indicating the completeness of a particular item. You align the item's title and description in a column with two rows and display the `reviewDueDate` field aligned right in the item's row:

<br/>
<Image alt="Test API" src="/resources/images/get-started/detailed-template.png" />

<Callout type="info" emoji="ðŸ“”">
  The code leverages several `HStack` (horizontal stack) and `VStack` (vertical stack) component instances to establish the layout.
</Callout>

## Extracting a Reusable component

The item template of a contact row is getting bigger and bigger. In the future, you will extend this template by displaying other task properties and adding a context menu to initiate task-related actions. The template is within the `Main.xmlui` file, and as it will involve more functionality, that file will be crowded and lose its easy-to-read nature.

It is the best time to extract the item template of the list into a separate component. With the following steps, you will refactor the app:

1. Create a new file, `ContactRow.xmlui`, in the `components` folder. By convention, custom components created within the app go into the `components` folder.
2. Type this code into `ContactRow.xmlui` to declare a reusable component:

```ueml copy filename="ContactRow.xmlui"
<Component name="ContactRow">
</Component>
```

3. Move the item template from the `Main.xmlui` file to the `ContactRow.xmlui` file:

```ueml copy {2-13} filename="ContactRow.xmlui"
<Component name="ContactRow">
  <Card>
    <HStack verticalAlignment="center">
      <Checkbox initialValue="{$item.reviewCompleted}" />
      <VStack width="*" gap="0">
        <Text variant="strong">{$item.fullName}</Text>
        <Text>{$item.comments}</Text>
      </VStack>
      <HStack verticalAlignment="center" horizontalAlignment="end">
        <Text>{smartFormatDate($item.reviewDueDate)}</Text>
      </HStack>
    </HStack>
  </Card>
</Component>
```

4. The `$item` context value you used with the list's item template has no meaning within a reusable component's definition. Reusable components use the `$props` context value to refer to the properties passed in their markup instances. Thus, you need to replace the `$item` occurrences with `$props.item` to ensure the new extracted component works:

```ueml copy {2-13} filename="ContactRow.xmlui" /$props.item/
<Component name="ContactRow">
  <Card>
    <HStack verticalAlignment="center">
      <Checkbox initialValue="{$props.item.reviewCompleted}" />
      <VStack width="*" gap="0">
        <Text variant="strong">{$props.item.fullName}</Text>
        <Text>{$props.item.comments}</Text>
      </VStack>
      <HStack verticalAlignment="center" horizontalAlignment="end">
        <Text>{smartFormatDate($props.item.reviewDueDate)}</Text>
      </HStack>
    </HStack>
  </Card>
</Component>
```

5. Go back to the `Main.xmlui` file and replace the item template with the new `ContactRow` component:

```ueml copy filename="Main.xmlui" {3}
<!-- Omitted -->
<List data="/api/contacts">
  <ContactRow item="{$item}" />
</List>
<!-- Omitted -->
```

The app should work as before; however, now, it uses the extracted component.

## Categorizing Data

In the app's database, each contact can be assigned a category. The available categories are stored in the database with the following structure:

| Field | Type | Description |
| --- | --- | --- |
| id | integer | The unique identifier of the category |
| name | string | The category's name |
| color | string | The category's color |

XMLUI has a `Badge` component that can use a color map (name and color pairs). When you pass a value to a `Badge`, it leverages the color map to set up the component's background according to the badge's text. In this section, you will add a `Badge` displaying the category associated with a particular contact:

1. Navigate to the `Main.xmlui` file and add a `DataSource` component before the `List` with the `categories` identifier. You can refer to the fetched value with `categories.value`; pass it to `ContactRow` in the `categoryList` property. This `DataSource` component will fetch all category data from the backend. Update the `ContactRow` component by setting the `categories` property:

```ueml copy {2, 4} filename="Main.xmlui"
<Page url="/contacts">
  <DataSource id="categories" url="/api/categories" />
  <List data="/api/contacts">
    <ContactRow item="{$item}" categories="{categories.value}" />
  </List>
</Page>
```

2. Create a new `ContactRow.xmlui.xs` file in the `components` folder. This file intentionally has the same name extended with `.xs` as the `ContactRow` component's markup file. It is a *code behind* a file containing variables and functions visible within the `ContactRow` component; they represent the states, actions, and other utility functionality. Copy this content into the new file:

```javascript copy filename="ContactRow.xmlui.xs"
// Category record of the item
var category = $props.categories.find(t => t.id === $props.item.categoryId);
 
// Create a color map for all categories
var categoriesColorMap = toHashObject($props.categories, "name", "color");
```

The `category` variable contains the category record associated with the item. If the item does not have a topic, the variable has an undefined value. The `categoriesColorMap` variable converts the list of topic records into a hash object with the topic name and color value pairs.

<Callout type="info" emoji="ðŸ“”">
This transformation with the `reduce` JavaScript function converts category records from this format

```json
[
  { "name": "<name1>", "color": "<color1>" },
  { "name": "<name2>", "color": "<color2>" },
  // ...
]
```

into a hash object:

```json
{
  "<name1>": "<color1>",
  "<name2>": "<color2>",
  // ...
}
```
</Callout>

3. Add a `Badge` component to the `ContactRow` definition and wire it up with the current item:

```ueml copy {10} filename="ContactRow.xmlui" /category/ /categoriesColorMap/
<Component name="ContactRow">
  <Card>
    <HStack verticalAlignment="center">
      <Checkbox initialValue="{$props.item.reviewCompleted}" />
      <VStack width="*" gap="0">
        <Text variant="strong">{$props.item.fullName}</Text>
        <Text>{$props.item.comments}</Text>
      </VStack>
      <HStack verticalAlignment="center" horizontalAlignment="end">
        <Badge when="{category}" value="{category.name}" colorMap="{categoriesColorMap}"/>
        <Text>{smartFormatDate($props.item.reviewDueDate)}</Text>
      </HStack>
    </HStack>
  </Card>
</Component>
```

The markup leverages these the `Badge` properties:
- `when` is a Boolean property influencing when the component should be rendered (and displayed). If there is no category associated with a particular contact, the badge is not displayed.
- `value` means the text to display in the badge; it is set to the category name.
- `colorMap` declares the mapping of values to background colors.

Now, running the app will display the topics of task items:

<br/>
<Image alt="Badges" src="/resources/images/get-started/items-and-badges.png" />

In the following article, you will learn to display filtered data.

