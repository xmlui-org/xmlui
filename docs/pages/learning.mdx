import { Callout } from 'nextra/components'
import themeGallery from "./styles-and-themes/samples/theme-gallery-brief.xmlui";

# Learning XMLUI

After completing the first experiment with the framework, the articles in this section will help you master XMLUI. You can quickly understand the gist of XMLUI by going through the framework's fundamental concepts.

## Components

<Callout type="info" emoji="ðŸ’¡">
  **XMLUI apps** are declarative. You define an app with an XMLUI (XML) markup.
</Callout>

```ueml
<App>
  Hello, world!
</App>
```
<Callout type="info" emoji="ðŸ’¡">
  **Components** are the basic building blocks of XMLUI apps. A component is an XML element (tag) in the markup.
</Callout>

```ueml /Avatar/
<Avatar url="https://i.pravatar.cc/100" size="md" />
```

`Avatar` is a component that displays a user's profile picture.

<Callout type="info" emoji="ðŸ’¡">
  Components have **properties** that determine their appearance and behavior. Properties are declared as XML attributes when they can be represented with strings.
</Callout>

```ueml /url/ /size/
<Avatar url="https://i.pravatar.cc/100" size="md" />
```

`url` and `size` define the location and size of the `Avatar` component instance.

<Callout type="info" emoji="ðŸ’¡">
  When properties cannot be represented with a string, you nest them into their related component with the **`<property>` tag**.
</Callout>

```ueml {2-4}
<DropdownMenu>
  <property name="triggerTemplate">
    <Button label="My Menu" icon="chevrondown" iconPosition="right"/>
  </property>
  <MenuItem>Item 1</MenuItem>
  <MenuItem>Item 2</MenuItem>
  <MenuItem>Item 3</MenuItem>
</DropdownMenu>
```

`triggerTemplate` is a property of the `DropdownMenu` component that defines the UI for the trigger that opens the dropdown menu.

<Callout type="info" emoji="ðŸ’¡">
  Besides literal values, component property values may have **expressions** (wrapped between curly braces). These use simple expression syntax, and the engine will evaluate them.
</Callout>

```ueml /{customer.name}/
<Button label="Click to delete {customer.name}" />
```

If the `customer.name` expression evaluates to "Jane Templeton", the button's label will be "Click to delete Jane Templeton."

<Callout type="info" emoji="ðŸ’¡">
  Components handle **user and system events**. As a consequence of these events, some components' properties may change. XMLUI evaluates these changes and refreshes the UI accordingly.

  Defining **event handlers** with expressions or short scripts (with statements, loops, and other constructs) can change how components respond to particular events.
</Callout>

```ueml /onClick/
<Button label="See order ID" onClick="toast('Current order: ' + orderId)" />
```
When the user clicks this button, the app will pop up a toast with the ID held by the `orderId` value.

<Callout type="info" emoji="ðŸ’¡">
  Components may have an **ID**. Other components can utilize this ID to refer to the state of that component or access component methods.
</Callout>

```ueml /id=myText/
<TextBox id="myText" />
<Text>Value in the textbox: {myText.value}</Text>
```

As the user types in the textbox, the text value is displayed in the `Text` component beneath it. 

```ueml /id=myText/
<List id="accountsList" />
<!-- Some other components -->
<Button label="Last account" onClick="accountsList.scrollToEnd()">
```

When the user clicks the button, the list above scrolls to the bottom to show the last item.

<Callout type="info" emoji="ðŸ’¡">
  Components can be hidden (or shown) in the UI conditionally. The **`when` attribute** of a component determines whether it is visible.
</Callout>

```ueml /when="{useCompression.value}"/
<Checkbox id="useCompression" label="Use compression" />
<Checkbox when="{useCompression.value}" label="Use lossless compression" />
<Checkbox label="Convert to grayscale" />
```

The "Use lossless compression" checkbox is visible only when the "Use compression" checkbox is set.

## Data and APIs

<Callout type="info" emoji="ðŸ’¡">
  Components working with data **can be bound to API endpoints**. Many XMLUI components (that may work with data) have a **`datasource` property** to define an API endpoint (GET) to fetch data.
</Callout>

```ueml copy
<List datasource="https://api.spacexdata.com/v3/history">
  <property name="itemTemplate">
    <Card title="{$item.title}" subTitle="{$item.details}"/>
  </property>  
</List>
```

The `List` component fetches data from the specified URL (an array of items). With a template definition (you will soon learn this concept in the following section), it displays the list item using the fetched data.


<Callout type="info" emoji="ðŸ’¡">
  Components can **invoke API endpoints that mutate data**. You can use the **`<event>` tag** to bind the invocation of a particular endpoint to a component's event handler. An **ApiAction component** can declare the details of the invocation.
</Callout>

```ueml copy
<Button label="Delete completed tasks">
  <event name="click">
    <ApiAction url="/api/tasks/completed" method="delete" />
  </event>
</Button>
```

## Working with code

<Callout type="info" emoji="ðŸ’¡">
  You can put event handlers and other functions into **code-behind** files. Markup files (`.xmlui` extension) may have a code-behind file using the markup file name but the `.xmlui.xs` extension.

  XMLUI **automatically binds event handlers** using the component's ID and the event name. While you follow the naming convention, you do not need to add event handlers to the component markup.
</Callout>

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
  <div style={{width: "50%", paddingRight: "0.25rem"}}>
```ueml copy filename="Main.xmlui (markup)" /calcButton/
<Button id="calcButton" 
  label="Calculate delay" />


```
  </div>
  <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```js copy filename="Main.xmlui.xs (code-behind)" /calcButton_onClick/
function calcButton_onClick() {
  const delay = 500 * 2;
  console.log('Delay calculated: ' + delay);
}
```
  </div>
</div>

The button's ID is `calcButton`. The framework observes the `calcButton_onClick` function declaration in the code-behind file and binds it to handle the `click` event.

<Callout type="info" emoji="ðŸ’¡">
  You can name the **event handler function differently** if you find it more expressive. In this case, you must add the function's invocation to the component's event handler.
</Callout>

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
  <div style={{width: "50%", paddingRight: "0.25rem"}}>
```ueml copy filename="Main.xmlui (markup)" /handleOnClick/
<Button 
  label="Calculate delay" 
  onClick="handleOnClick()" />

```
  </div>
  <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```js copy filename="Main.xmlui.xs (code-behind)" /handleOnClick/
function handleClick() {
  const delay = 500 * 2;
  toast('Delay calculated: '+ delay);
}
```
  </div>
</div>

The button is the `Main.xmlui` file utilizes the `handleOnClick` function declared in the `Main.xmlui.xs` code-behind file.

<Callout type="info" emoji="ðŸ’¡">
  Using wrapping braces, you can add **inline code expressions** to **property** and **element text values**. You can use the JavaScript syntax for them; the framework evaluates them using JavaScript semantics.
</Callout>

```ueml copy /{tasks.length}/ /initialValue="{customer.name}"/ /delay="{calculatedDelay * (1 + reservePercentage * 0.01)} minutes"/
<Text>There are {tasks.length} tasks in the list.</Text>
<TextBox initialValue="{customer.name}">
```

<Callout type="info" emoji="ðŸ’¡">
  The event handler attributes accept **inline code scripts**. As in event handlers, you do not mix string elements with (brace-wrapped) expressions; the entire value of an event handler is considered code.
  (You can break the code into multiple lines.)
</Callout>

```ueml copy /onClick/
<Button label="Calculate delay" onClick="
  const delay = 500 * 2;
  toast('Delay calculated: ' + delay);
" />
```

<Callout type="info" emoji="ðŸ’¡">
  You can declare **variables** in code-behind files with the **`var` keyword** and optionally initialize them to a particular value (with an expression).

  These variables are **reactive**: whenever any dependency in their initializing expression changes, the variable's value is reevaluated.
</Callout>

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
  <div style={{width: "50%", paddingRight: "0.25rem"}}>
```ueml copy filename="Main.xmlui (markup)" /handleOnClick/
<Button 
  label="Click to increment!" 
  onClick="count++" />
<Text>Click count: {count}</Text>  
<Text>Click count * 3: {countTimes3}</Text>  
```
  </div>
  <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```js copy filename="Main.xmlui.xs (code-behind)" /handleOnClick/
var count = 0;
var countTimes3 = count * 3;



```
  </div>
</div>

When you click the button, it incrementsÂ onlyÂ theÂ `count`Â variable. However, asÂ countTimes3Â is a reactive variable withÂ `count`Â as a dependency, updatingÂ `count`Â triggers the re-evaluation ofÂ `countTimes3`. Thus, the second text will show three times the value of the first.

<Callout type="info" emoji="ðŸ’¡">
You can use **local variables** within (and only within) function declarations. The **`let` keyword** allows using a mutable variable; **`const`** declares an immutable one (following the JavaScript semantics).
</Callout>

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
  <div style={{width: "50%", paddingRight: "0.25rem"}}>
```ueml copy filename="Main.xmlui (markup)" /handleOnClick/
<Button 
  label="Calculate the sum of 1 to 10" 
  onClick="calculate()" />
<Text>Result: {sum}</Text>  
```
  </div>
  <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```js copy filename="Main.xmlui.xs (code-behind)" /handleOnClick/
var sum = 0;
function calculate() {
  for (let i = 1; i <= 10; i++) sum += i;
}
```
  </div>
</div>

The calculate function uses the local variable `i` and stores the sum of values in the `sum` reactive variable. 

## Component composition

<Callout type="info" emoji="ðŸ’¡">
  Components may have properties that accept other component definitions (markup) as their value. We call them **template properties**. 
</Callout>

```ueml copy {2-4} /property name="itemTemplate"/
<List items="{['apple', 'banana', 'cherry', 'orange']}">
  <property name="itemTemplate">
    <Text variant="mono">{$item}</Text>
  </property>
</List>
```

This code snippet renders a list of the fruit items using monospace text to display a particular fruit name.

<Callout type="info" emoji="ðŸ’¡">
The component definitions within the template properties can access information in the hosting component (the one using the template's content) through identifiers starting with `$`. We call them **context values**.
</Callout>

In the markup above, `$item` in `<Text variant="mono">{$item}</Text>` is a context value that holds the current iteration value of the list (a particular fruit name).

<Callout type="info" emoji="ðŸ’¡">
  To avoid code repetition, you can enclose frequently occurring markup snippets in **reusable component definitions**. When you change this component's definition, all occurrences will render the modified markup.

  Reusable components go into a separate `.xmlui` file (with an arbitrary name). The framework observes them and uses them in the markup.
</Callout>

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
  <div style={{width: "50%", paddingRight: "0.25rem"}}>
```ueml copy filename="Main.xmlui (markup)" /calcButton/
<InfoCard icon="email" label="Send email" />
<InfoCard icon="phone" label="Start call" />
<InfoCard icon="home" label="Back to home" />



```
  </div>
  <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```ueml copy filename="InfoCard.xmlui (reusable component)"
<Component name="InfoCard">
  <Card>
    <Icon name="{$props.icon}" />
    <Text>{$props.label}</Text>
  </Card>
</Component>
```
  </div>
</div>

`Infocard` is a resusable component. In its definition, the `name` property of `<Component>` declares the name that can be used in the markup. The `$props` context value exposes the current property values defined for a particular `<InfoCard>` usage. This context value allows properties to be passed to the reusable component.

## Theming and styling

<Callout type="info" emoji="ðŸ’¡">
**XMLUI supports themes**. You do not have to apply markup elements to set some style information, as the default theme has a consistent design. Themes support **light and dark tone variants**.
</Callout>

<Playground
  previewOnly
  name="The default XMLUI theme (light)"
  app={`
    <Theme tone="light" themeId="xmlui">
      <ThemeGallery />
    </Theme>  
  `}
  components={[themeGallery]}
  height={260}
/>

<Playground
  previewOnly
  name="The default XMLUI theme (dark)"
  app={`
    <Theme tone="dark" themeId="xmlui">
      <ThemeGallery />
    </Theme>  
  `}
  components={[themeGallery]}
  height={260}
/>

<Callout type="info" emoji="ðŸ’¡">
  You can easily create custom themes by adding a new **theme file** that changes a few **theme variables** (the ones you intend to modify). XMLUI automatically applies the changes to light and dark themes; you do not have to handle them separately.
</Callout>

```json copy {4-5} filename="themes/myCustomTheme.json"
{
  "id": "myCustomTheme",
  "themeVars": {
    "color-primary": "#702F72",
    "radius-Input": "12px"
  }
}
```

These modifications set the primary theme color to purplish and add a bigger corner radius to the input (and only to the input) components. Check the hover effect of the "outlined/primary" button in light and dark themes!

<Playground
  previewOnly
  name="Modified theme (light)"
  defaultTheme="myCustomTheme"
  themes={[
    {
      name: "My Custom Theme",
      id: "myCustomTheme",
      themeVars: {
        "color-primary": "#702F72",
        "radius-Input": "12px",
      },
    },
  ]}
  app={`
    <Theme tone="light" themeId="myCustomTheme">
      <ThemeGallery />
    </Theme>
  `}
  components={[themeGallery]}
  height={260}
/>

<Playground
  previewOnly
  name="Modified theme (dark)"
  defaultTheme="myCustomTheme"
  themes={[
    {
      name: "My Custom Theme",
      id: "myCustomTheme",
      themeVars: {
        "color-primary": "#702F72",
        "radius-Input": "12px",
      },
    },
  ]}
  app={`
    <Theme tone="dark" themeId="myCustomTheme">
      <ThemeGallery />
    </Theme>
  `}
  components={[themeGallery]}
  height={260}
/>

<Callout type="info" emoji="ðŸ’¡">
  You can use dozens of **inline layout properties** with components such as setting component dimensions, colors, typography, etc. 
</Callout>

```ueml copy {3-7}
<Button 
  label="My custom style" 
  color="yellow" 
  fontFamily="serif" 
  fontSize="3em"
  horizontalPadding="5rem"
  radius="3rem" />
```

<Playground
  previewOnly
  name="Adding layout properties to a Button"
  app={`
    <Button 
      label="My custom style" 
      color="yellow" 
      fontFamily="serif" 
      fontSize="3em"
      horizontalPadding="5rem"
      radius="3rem" />
  `}
  components={[themeGallery]}
  height={100}
/>

<Callout emoji="âš ï¸">
  While these layout properties may be tempting for quick style modification (and helpful during development), they may cause a style maintenance nightmare in production. **Avoid using inline layout properties!**
</Callout>

## Deployment

<Callout type="info" emoji="ðŸ’¡">
  XMLUI apps have a **simple folder structure**. The app's root folder contains the `index.html` file that loads the framework as a single JavaScript file. The `Main.xmlui` (in the root) is the app's primary markup file. Other folders, like `components`, `resources`, and `themes`, contain simple markup and resource files. 
</Callout>

<Callout type="info" emoji="ðŸ’¡">
  You do not need to declare anything about the structure's content. **The framework will observe and process all source files into a working app**.
</Callout>

<Callout type="info" emoji="ðŸ’¡">
  XMLUI applications have a **simple folder structure**. You can copy this structure into the static files folder of your web server, and they are **ready to be hosted instantly** by a web server.
</Callout>

<Callout type="info" emoji="ðŸ’¡">
  The framework offers several build methods that **optimize the static file structure for size and startup performance**. 
</Callout>
