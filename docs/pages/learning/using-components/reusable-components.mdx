# Reusable Components

XLMUI has been designed with reusable components in mind. Besides the components out-of-the box, you can use the markup to create and utilize your reusable components within your app.

This article will teach you the gritty-nitty details of component creation and customization.

## Defining Reusable Components

Use the `<Component>` tag to declare a reusable component in the markup. This tag has a mandatory attribute, `name`, a unique identifier to the component. You should use this ID when you declare an instance of the component. As a convention, the component's name must start with an uppercase letter. The following characters of the ID may be letters, digits, the underscore (`_`), or the dollar sign (`$`) character.

The component must have content, at least a single nested tag to define the component's visual representation, and, optionally, it may have variables assigned to the component.

You start with a simple reusable component to display a value with a label. The blueprint of this component is just a few lines of markup:

```ueml copy 
<Component name="LabeledValue">
  <HStack>
    <Text>Label:</Text>
    &nbsp;
    <Text>Value</Text></HStack>
</Component>
```

You can immediately use the new component type, `LableledValue`, putting it into your app using the `<LabeledValue>` tag:

```ueml copy
<VStack padding="1rem" gap="1rem">
  <LabeledValue />
  -- Separator text --
  <LabeledValue />
</VStack>
```

The XMLUI engine displays all `LabeledValue` component instances:

<Playground
    previewOnly
    name="LabeledText"
    components={[`
      <Component name="LabeledValue">
        <HStack><Text>Label</Text>:&nbsp;<Text>Value</Text></HStack>
      </Component>
    `]}
    app={`
    <VStack padding="1rem" gap="1rem">
      <LabeledValue />
      -- Separator text --
      <LabeledValue />
    </VStack>
    `}
    height={150}
/>

## Using Properties

Though reusable components with a static appearance may be helpful, the real power comes when you can define component properties to influence the appearance and behavior of a particular reusable component.

With a few additions, you can allow `LabeledValue` to receive a `label` and a `value` specification:

```ueml copy
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label}:&nbsp;</Text>
    <Text>{$props.value}</Text>
  </HStack>
</Component>
```

The `$props` identifier defines the properties passed to the custom component. You can use the `.` operator to access a particular property. So, `$props.label` and `$props.value` mark the `label` and `value` properties, respectively. As you use these names in binding expressions, the engine will display their run time value.

Use the same markup to pass property values to reusable components as you do for built-in components:

```ueml
<VStack padding="1rem" gap="1rem">
  <LabeledValue label="Firstname" value="Cameron" />
  -- Separator text --
  <LabeledValue label="Lastname" value="Smith" />
</VStack>
```

<Playground
    previewOnly
    name="LabeledText with properties"
    components={[`
      <Component name="LabeledValue">
        <HStack><Text>{$props.label}</Text>:&nbsp;<Text>{$props.value}</Text></HStack>
      </Component>
    `]}
    app={`
    <VStack padding="1rem" gap="1rem">
      <LabeledValue label="Firstname" value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" value="Smith" />
    </VStack>
    `}
    height={150}
/>

> **Note**: XMLUI does not require defining component properties in advance. You just use your property through the `$props` identifier; the engine will immediately understand and render it.

Sometimes, it is helpful to have default values for properties. XMLUI makes it simple using the `??` operator, as you can see in the following component definition:

```ueml
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label ?? '[label]'}:&nbsp;</Text>
    <Text>{$props.value ?? '[none]'}</Text>
  </HStack>
</Component>
```

<Playground
    previewOnly
    name="LabeledText with default property values"
    components={[`
      <Component name="LabeledValue">
        <HStack>
          <Text>{$props.label ?? '[label]'}</Text>:&nbsp;
          <Text>{$props.value ?? '[none]'}</Text>
        </HStack>
      </Component>
    `]}
    app={`
    <VStack padding="1rem" gap="1rem">
      <LabeledValue value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" />
    </VStack>
    `}
    height={150}
/>

## Using Events

Similarly to properties, you can harness a reusable component with custom events.

Create a new reusable component, `<IncButton>`, which increments its value for every click. This component can notify its environment about increments by firing an event. This event receives the current counter as an event parameter:

```ueml copy {4}
<Component name="IncButton">
  <Button 
    label="Click to increment: {count}" var.count="{0}" 
    onClick="count++; emitEvent('incremented', count)" />
</Component>
```

The `emitEvent` function emits the `"incremented"` event attached to the reusable component's instance and triggers the particular event handler. The first argument of `emitEvent` is the event name, and the subsequent ones are the arguments of the specific event.

The following app uses the new event to append the number of clicks to a text. The handler of the `incremented` event (`onIncremented`) declares an arrow function where `v` represents the event value, namely, the count of clicks:

```ueml copy
<VStack var.text="">
  <IncButton onIncremented="v => text += ' ' + v" />
  <Text value="{text}" />
</VStack>
```

Try using `<IncButton>` with the `incremented` event:

<Playground
    previewOnly
    name="IncButton with an event"
    components={[`
      <Component name="IncButton">
        <Button 
          label="Click to increment: {count}" var.count="{0}" 
          onClick="count++; emitEvent('incremented', count)" />
      </Component>
    `]}
    app={`
    <VStack var.text="">
      <IncButton onIncremented="v => text += ' ' + v" />
      <Text value="{text}" />
    </VStack>
    `}
    height={100}
/>

## Adding Component APIs

Besides properties and events, you can add custom methods (APIs) to a particular component. You can use these methods in other components to execute an operation or query some information from the component with the API.

The following code snippet shows a modified `<IncButton>` component that offers an API method, `setValue`, to set the button's counter value from outside the component:

```ueml copy {4} 
<Component 
  name="IncButton" 
  var.count="{0}" 
  api.setValue="v => count = v">
  <Button label="Click to increment: {count}" onClick="count++" />
</Component>
```

> **Note**: Variables defined within a reusable component are invisible from outside. However, with an explicit API, you can expose them.

The updated component stores the counter value in a variable belonging to the entire component (and not enclosed within the `<Button>`. This line declares the `setValue` API method with an arrow function with the parameter receiving the new value (`v`).

The following app adds a second button to set the current value of `<IncButton>` to 123 on a click. Here, we provide an `id` for `<IncButton>` to refer to it from the second button:

```ueml copy {3,6}
<VStack>
  <HStack gap="0.2rem">
    <IncButton id="myIncButton" />
    <Button 
      label="Set count to 123!" 
      onClick="myIncButton.setValue(123)" />
  </HStack>
</VStack>
```
The click event handler (`onClick`) of the second button uses the `myIncButton.setValue()` expression to invoke the `setValue` method associated with the `myIncButton` instance.

Try using this simple app:

<Playground
    previewOnly
    name="IncButton with an API"
    components={[`
      <Component name="IncButton" var.count="{0}" api.setValue="v => count = v">
        <Button label="Click to increment: {count}" onClick="count++" />
      </Component>
`]}
    app={`
    <VStack>
      <HStack gap="0.2rem">
        <IncButton id="myIncButton" />
        <Button label="Set count to 123!" onClick="myIncButton.setValue(123)" />
      </HStack>
    </VStack>
    `}
    height={60}
/>

## `<Slot>`

You can use the `Slot` placeholder within a reusable component's definition to mark the location when the reusable component's children should be injected. Here, `Slot` is nested into `VStack` to mark the location to inject `MyStack` children:

```ueml copy {4}
<Component name="MyStack">
  <H2>This is my special Stack</H2>
  <VStack padding="1rem" gap="0.2rem" backgroundColor="cyan">
   <Slot/>
  </VStack>
</Component>
```

This sample injects children into `MyStack`:

```ueml copy {2-4}
<MyStack>
 These are the children injected into the
 <H3>MyStack</H3>
 component's Slot placeholder
</MyStack>
```

`MyStack` puts the children into the location designated by `Slot`:

<Playground
    previewOnly={true}
    name="Example: Using Slot"
    horizontal={true}
    height={200}
    components={[
        `
    <Component name="MyStack">
      <H2>This is my special Stack</H2>
      <VStack padding="1rem" gap="0.2rem" backgroundColor="cyan">
       <Slot/>
      </VStack>
    </Component>
  `,
    ]}
    app={`
    <MyStack>
     These are the children injected into the
     <H3>MyStack</H3>
     component's Slot placeholder
    </MyStack>
  `}
/>

## Reusable Components in Layout Containers

When the engine renders a reusable component in a particular layout container, the rendered component accommodates its container's layout context. 

Let's create a reusable component, `MyBoxes`, with this markup:

```ueml copy
<Component name="MyBoxes">
  <Stack width="100px" height="36px" backgroundColor="purple" />
  <Stack width="50px" height="36px" backgroundColor="orange" />
</Component>
```

`MyBoxes` displays two boxes with different sizes and background color settings. This declaration does not specify how these two boxes should relate to each other; it only says the orange box follows the purple box.

Nest `MyBox` instances into an `HStack`: 

```ueml copy
<HStack gap="1rem" >
  <MyBoxes />
  <MyBoxes />
</HStack>
```

It results in this output:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a HStack"
    horizontal={true}
    height={60}
    components={[`
      <Component name="MyBoxes">
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </Component>
    `,
    ]}
    app={`
    <HStack gap="1rem" >
      <MyBoxes />
      <MyBoxes />
    </HStack>
  `}
/>

Now, use a `VStack`:

```ueml copy
<VStack gap="0.5rem" >
  <MyBoxes />
  <MyBoxes />
</VStack>
```

The previous output changes to this:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a VStack"
    horizontal={true}
    height={200}
    components={[`
      <Component name="MyBoxes">
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </Component>
    `,
    ]}
    app={`
    <VStack gap="0.5rem" >
      <MyBoxes />
      <MyBoxes />
    </VStack>
  `}
/>

Using a `FlowLayout` wrapper results in a third display:

```ueml copy
<FlowLayout gap="1rem" >
  <MyBoxes />
  <MyBoxes />
</FlowLayout>
```

<Playground
    previewOnly={true}
    name="Example: MyBoxes in FlowLayout"
    horizontal={true}
    height={200}
    components={[`
      <Component name="MyBoxes">
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </Component>
    `,
    ]}
    app={`
    <FlowLayout gap="1rem" >
      <MyBoxes />
      <MyBoxes />
    </FlowLayout>
  `}
/>

### Component Flattening

Each layout container uses its strategy to render the nested children. Though a `<Component>` tag wraps the two boxes within `MyBoxes`, that tag does not create any extra artifact. The rendering engine puts the two children of `MyBoxes` as if you put them directly in their layout components. So, when you wrap the two `MyBoxes` instances into an `HStack`, the results is as if you used this markup:

```ueml copy
<HStack gap="1rem" >
  <Stack width="100px" height="36px" backgroundColor="purple" />
  <Stack width="50px" height="36px" backgroundColor="orange" />
  <Stack width="100px" height="36px" backgroundColor="purple" />
  <Stack width="50px" height="36px" backgroundColor="orange" />
</HStack>
```

<Playground
    previewOnly={true}
    name="Example: flattening MyBoxes in an HStack"
    horizontal={true}
    height={80}
    app={`
      <HStack gap="1rem" >
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </HStack>
  `}
/>

The same flattening happens with a `VStack`. 

However, the `FlowLayout` container does not flatten the children. It keeps the two `MyBoxes` instances as separate entities.

### Using Layout Containers Explicitly

Use an explicit layout container within the component definition to avoid child component flattening. For example, if you want the purple and orange boxes in a particular layout (within the component), you can explicitly declare that intention:

```ueml copy /HStack gap="0.2rem" border="2px dotted green"/
<Component name="MyBoxes">
  <HStack gap="0.2rem" border="2px dotted green" >
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack>
</Component>
```

> **Note**: This definition adds a border to the component to display the UI patch it fills.

Now, the output is different. You see this with an `HStack`:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a HStack (explicit layout)"
    horizontal={true}
    height={60}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0.2rem" border="2px dotted green" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <HStack gap="1rem" >
      <MyBoxes />
      <MyBoxes />
    </HStack>
  `}
/>

With a `VStack`, this is the output:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a VStack (explicit layout)"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0.2rem" border="2px dotted green" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <VStack gap="0.5rem" >
      <MyBoxes />
      <MyBoxes />
    </VStack>
  `}
/>

The display with a `FlowLayout`:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a FlowLayout (explicit layout)"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0.2rem" border="2px dotted green" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <FlowLayout gap="0.5rem" >
      <MyBoxes />
      <MyBoxes />
    </FlowLayout>
  `}
/>

## Using Explicit Component Width

Because `MyBoxes` does not use an explicit component width, nesting them into a `VStack` or a `FlowLayout` will size them to the available width. If your intention is different, you can use an explicit width specification in the `MyBoxes` declaration:

```ueml copy /width="180px"/
<Component name="MyBoxes">
  <HStack gap="0.2rem" border="2px dotted green" width="180px" >
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack>
</Component>
```

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a HStack (explicit width)"
    horizontal={true}
    height={60}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0.2rem" border="2px dotted green" width="180px" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <HStack gap="1rem" >
      <MyBoxes />
      <MyBoxes />
    </HStack>
  `}
/>

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a VStack (explicit width)"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0.2rem" border="2px dotted green" width="180px">
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <VStack gap="0.5rem" >
      <MyBoxes />
      <MyBoxes />
    </VStack>
  `}
/>

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a FlowLayout (explicit width)"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0.2rem" border="2px dotted green" width="180px" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <FlowLayout gap="0.5rem" >
      <MyBoxes />
      <MyBoxes />
    </FlowLayout>
  `}
/>
