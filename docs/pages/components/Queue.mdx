# Queue

> **Note**: This component does does not show up on the UI; it merely helps implement UI logic.

The `Queue` component provides an API to enqueue elements and defines events to process queued elements in a FIFO order.

## Using Queue

As its name suggests, the `Queue` component keeps a queue of items to process. You can add items to the queue with the `enqueueItem` (or `enqueueItems`) method. Once the queue has some items to process, the engine reads them one by one (in FIFO order) and processes an item with the `process` event handler.
Though `Queue` is a non-visual component, it can render UI for reporting progress through its `progressFeedback` property. Also, when the queue gets empty, the UI can render a result summary through the `resultFeedback` property.

The following sample demonstrates these concepts. When the user clicks the button, a new random number is queued. The sample imitates a long calculation by waiting one second within the `process` event handler and reports the progress.

A `ChangeListener` instance observes queue length changes and stores the actual length to display that in the UI.

```ueml copy {11-26}
<VStack 
  padding="1rem" 
  gap="0.5rem" 
  var.queued="{0}" 
  var.queueLength="{0}" 
  var.processed="{0}"
  var.result="{0}">
  <Button
    label="Add a new item to the queue" 
    onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
  <Queue id="myQueue"
    onProcess="processing => 
      {
         result += processing.item;
         delay(1000); 
         processed++; 
         processing.onProgress(processed)
      }
    ">
    <prop name="progressFeedback">
      <Text value="{processed} / {queued}" />
    </prop>
    <prop name="resultFeedback">
      <Text value="{result.toFixed(4)}" />
    </prop>
  </Queue>
  <ChangeListener 
    listenTo="{myQueue.getQueueLength()}" 
    onDidChange="l => queueLength = l.newValue"/>
  <Text>Items queued: {queued}</Text>
  <Text>Current queue length: {queueLength}</Text>
  <Text>Current result: {result.toFixed(4)}</Text>
</VStack>
```

<Playground
    previewOnly
    name="Example: using Queue"
    app={`
    <VStack 
      padding="1rem" 
      gap="0.5rem" 
      var.queued="{0}" 
      var.queueLength="{0}" 
      var.processed="{0}"
      var.result="{0}">
      <Button
        label="Add a new item to the queue" 
        onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
      <Queue id="myQueue"
        onProcess="processing => 
          {
             result += processing.item;
             delay(1000); 
             processed++; 
             processing.onProgress(processed)
          }
        ">
        <prop name="progressFeedback">
          <Text value="{processed} / {queued}" />
        </prop>
        <prop name="resultFeedback">
          <Text value="{result.toFixed(4)}" />
        </prop>
      </Queue>
      <ChangeListener 
        listenTo="{myQueue.getQueueLength()}" 
        onDidChange="l => queueLength = l.newValue;"/>
      <Text>Items queued: {queued}</Text>
      <Text>Current queue length: {queueLength}</Text>
      <Text>Current result: {result.toFixed(4)}</Text>
    </VStack>
  `}
    height={180}
/>

Try the app by clicking the button several times. Check how the queue processes the items and displays feedback.

## Context Variables

### `$completedItems`

A list containing the queue items that have been completed (fully processed).

## Properties

### `clearAfterFinish`

This property indicates the completed items (successful or error) should be removed from the queue after completion.

### `progressFeedback`

This property defines the component template of the UI that displays progress information whenever, the queue's `progressReport` function in invoked.

### `resultFeedback`

This property defines the component template of the UI that displays result information when the queue becomes empty after processing all queued items.

## API

This component does not provide any API.

## Events

### `complete`

The queue fires this event when the queue gets empty after processing all items. The event handler has no arguments.

The following sample displays a tick mark every time the queue is emptied:

```ueml copy {15}
<VStack 
  padding="1rem" 
  gap="0.5rem" 
  var.queued="{0}" 
  var.queueEmptied="" 
  var.result="{0}">
  <Button
    label="Add a new item to the queue" 
    onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
  <Queue id="myQueue"
    onProcess="processing => {
      result += processing.item;
      delay(1000); 
    }"
    onComplete="queueEmptied += '✅'" >
    <prop name="resultFeedback">
      <Text value="{result.toFixed(4)}" />
    </prop>
  </Queue>
  <Text>Items queued: {queued}</Text>
  <Text>Current result: {result.toFixed(4)}</Text>
  <Text>Queue emptied: {queueEmptied}</Text>
</VStack>
```

<Playground
    previewOnly
    name="Example: complete"
    app={`
    <VStack 
      padding="1rem" 
      gap="0.5rem" 
      var.queued="{0}" 
      var.queueEmptied="" 
      var.result="{0}">
      <Button
        label="Add a new item to the queue" 
        onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
      <Queue id="myQueue"
        onProcess="processing => {
          result += processing.item;
          delay(1000); 
        }"
        onComplete="queueEmptied += '✅'" >
        <prop name="resultFeedback">
          <Text value="{result.toFixed(4)}" />
        </prop>
      </Queue>
      <Text>Items queued: {queued}</Text>
      <Text>Current result: {result.toFixed(4)}</Text>
      <Text>Queue emptied: {queueEmptied}</Text>
    </VStack>
  `}
    height={180}
/>

### `didProcess`

This event is fired when the processing of a queued item has been successfully processed.

The parameter of the event handler is an object with these properties:
- `item`: the item to process
- `actionItemId`: The unique (internal) ID of the item being processed, as generated by the `Queue` component. You can pass this ID to some API methods (for example, to `remove`).
- `processItemContext`: A context object (initially empty) that you can use to add some context-specific information to the item. The event handlers of other events will see this information as the item being processed conveys it.

The following sample uses the `didProcess` event handler to add a tick symbol to the progress whenever an item has been processed:

```ueml copy {15}
<VStack 
  padding="1rem" 
  gap="0.5rem" 
  var.queued="{0}" 
  var.progressLine="" 
  var.result="{0}">
  <Button
    label="Add a new item to the queue" 
    onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
  <Queue id="myQueue"
    onProcess="processing => {
      result += processing.item;
      delay(1000); 
    }"
    onDidProcess="progressLine += '✅'" >
    <prop name="resultFeedback">
      <Text value="{result.toFixed(4)}" />
    </prop>
  </Queue>
  <Text>Items queued: {queued}</Text>
  <Text>Current result: {result.toFixed(4)}</Text>
  <Text>Progress: {progressLine}</Text>
</VStack>
```

<Playground
    previewOnly
    name="Example: didProcess"
    app={`
    <VStack 
      padding="1rem" 
      gap="0.5rem" 
      var.queued="{0}" 
      var.progressLine="" 
      var.result="{0}">
      <Button
        label="Add a new item to the queue" 
        onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
      <Queue id="myQueue"
        onProcess="processing => {
          result += processing.item;
          delay(1000); 
        }"
        onDidProcess="progressLine += '✅'" >
        <prop name="resultFeedback">
          <Text value="{result.toFixed(4)}" />
        </prop>
      </Queue>
      <Text>Items queued: {queued}</Text>
      <Text>Current result: {result.toFixed(4)}</Text>
      <Text>Progress: {progressLine}</Text>
    </VStack>
  `}
    height={180}
/>

### `process`

This event is fired to process the next item in the queue. If the processing cannot proceed because of some error, raise an exception, and the queue will handle that.

The parameter of the event handler is an object with these properties:
- `item`: the item to process
- `actionItemId`: The unique (internal) ID of the item being processed, as generated by the `Queue` component. You can pass this ID to some API methods (for example, to `remove`).
- `processItemContext`: A context object (initially empty) that you can use to add some context-specific information to the item. The event handlers of other events will see this information as the item being processed conveys it.
- `reportProgress`: A function you can use to report the progress. Invoke this method with an argument that the `progressFeedback` component's template will utilize.

See the example in the [Using Queue](#using-queue) section.

### `processError`

This event is fired when processing an item raises an error. The event handler method receives two parameters. The first is the error raised during the processing of the item; the second is an object with these properties:

- `item`: the item to process
- `actionItemId`: The unique (internal) ID of the item being processed, as generated by the `Queue` component. You can pass this ID to some API methods (for example, to `remove`).
- `processItemContext`: A context object (initially empty) that you can use to add some context-specific information to the item. The event handlers of other events will see this information as the item being processed conveys it.

If the event handler returns false, the queue does not sign the error in the UI. With other return values (including no return value), the queue displays the error.

The following sample generates an error for every fourth item, and gives an error feedback with the `processError` event handler:

```ueml copy {12-14, 19}
<VStack 
  padding="1rem" 
  gap="0.5rem" 
  var.queued="{0}" 
  var.progressLine="" 
  var.result="{0}">
  <Button
    label="Add a new item to the queue" 
    onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
  <Queue id="myQueue"
    onProcess="processing => {
      if (progressLine.length % 4 === 3) {
        throw 'Item cannot be processed';
      }
      result += processing.item;
      delay(1000); 
    }"
    onDidProcess="progressLine += '✅'"
    onProcessError="progressLine += '❌'" >
    <prop name="resultFeedback">
      <Text value="{result.toFixed(4)}" />
    </prop>
  </Queue>
  <Text>Items queued: {queued}</Text>
  <Text>Current result: {result.toFixed(4)}</Text>
  <Text>Progress: {progressLine}</Text>
</VStack>
```

Click the button several times to see how processing errors are handled in the UI.

<Playground
    previewOnly
    name="Example: processError"
    app={`
    <VStack 
      padding="1rem" 
      gap="0.5rem" 
      var.queued="{0}" 
      var.progressLine="" 
      var.result="{0}">
      <Button
        label="Add a new item to the queue" 
        onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
      <Queue id="myQueue"
        onProcess="processing => {
          if (progressLine.length % 4 === 3) {
            throw 'Item cannot be processed';
          }
          result += processing.item;
          delay(1000); 
        }"
        onDidProcess="progressLine += '✅'"
        onProcessError="progressLine += '❌'" >
        <prop name="resultFeedback">
          <Text value="{result.toFixed(4)}" />
        </prop>
      </Queue>
      <Text>Items queued: {queued}</Text>
      <Text>Current result: {result.toFixed(4)}</Text>
      <Text>Progress: {progressLine}</Text>
    </VStack>
  `}
    height={180}
/>

### `willProcess`

This event is triggered to process a particular item.

This event is fired before the next item in the queue gets processed. If the event handler returns `false`, the queue skips processing that item. With other return values (including no return value), the queue continues processing the item.

The parameter of the event handler is an object with these properties:
- `item`: the item to process
- `actionItemId`: The unique (internal) ID of the item being processed, as generated by the `Queue` component. You can pass this ID to some API methods (for example, to `remove`).
- `processItemContext`: A context object (initially empty) that you can use to add some context-specific information to the item. The event handlers of other events will see this information as the item being processed conveys it.

The following sample declares a `willProcess` event handler that will skip processing (summing) items less than 0.5; the handler counts the number of skipped items.

```ueml copy {11}
<VStack 
  padding="1rem" 
  gap="0.5rem" 
  var.queued="{0}" 
  var.skipped="{0}" 
  var.result="{0}">
  <Button
    label="Add a new item to the queue" 
    onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
  <Queue id="myQueue"
    onWillProcess="toProcess => toProcess.item < 0.5 ? (skipped++, false) : true"
    onProcess="processing => {
      result += processing.item;
      delay(1000); 
    }">
    <prop name="resultFeedback">
      <Text value="{result.toFixed(4)}" />
    </prop>
  </Queue>
  <Text>Items queued: {queued}</Text>
  <Text>Items skipped: {skipped}</Text>
  <Text>Current result: {result.toFixed(4)}</Text>
</VStack>
```

Click the button several times and see how the number of skipped items increments.

<Playground
    previewOnly
    name="Example: willProcess"
    app={`
    <VStack 
      padding="1rem" 
      gap="0.5rem" 
      var.queued="{0}" 
      var.skipped="{0}" 
      var.result="{0}">
      <Button
        label="Add a new item to the queue" 
        onClick="{myQueue.enqueueItem(Math.random()); queued++; }" />
      <Queue id="myQueue"
        onWillProcess="toProcess => toProcess.item < 0.5 ? (skipped++, false) : true"
        onProcess="processing => {
          result += processing.item;
          delay(1000); 
        }">
        <prop name="resultFeedback">
          <Text value="{result.toFixed(4)}" />
        </prop>
      </Queue>
      <Text>Items queued: {queued}</Text>
      <Text>Items skipped: {skipped}</Text>
      <Text>Current result: {result.toFixed(4)}</Text>
    </VStack>
  `}
    height={180}
/>

## Styling

This component does not have any styles.
