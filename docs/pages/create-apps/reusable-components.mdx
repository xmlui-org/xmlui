import { Callout } from 'nextra/components'

# Reusable Components

<Callout type="info" emoji="ðŸ’¡">
  XLMUI has been designed with **reusable components** in mind. Besides the components out-of-the box, you can use the markup to create and utilize your reusable components within your app.
</Callout>

This article will teach you the gritty-nitty details of component creation and customization.

## Defining Reusable Components

<Callout type="info" emoji="ðŸ’¡">
  Use the `<Component>` tag to declare a reusable component in the markup. This tag has a mandatory attribute, `name`, a unique identifier to the component. 
</Callout>

```ueml copy filename="components/LabeledValue.xmlui"
<Component name="LabeledValue">
  <HStack>
    <Text>Label:</Text>
    <Text>Value</Text>
  </HStack>
</Component>
```

You can immediately use the new component type, `LabeledValue`, putting it into your app using the `<LabeledValue>` tag:

```ueml copy filename="Main.xmlui"
<App>
  <LabeledValue />
  -- Separator text --
  <LabeledValue />
</App>
```

The XMLUI engine displays all `LabeledValue` component instances:

<Playground
    previewOnly
    name="LabeledText"
    components={[`
      <Component name="LabeledValue">
        <HStack>
          <Text>Label:</Text>
          <Text>Value</Text>
        </HStack>
      </Component>
    `]}
    app={`
    <App>
      <LabeledValue />
      -- Separator text --
      <LabeledValue />
    </App>
    `}
    height={170}
/>

<Callout type="info" emoji="ðŸ’¡">
  The component's name must start with an uppercase letter followed by letters, digits, the underscore (`_`), or the dollar sign (`$`) character. Components must be placed into separate files in the `components` folder within the app's root folder. **Use the same name for the component as its filename so that the browser can fetch the component.**
</Callout>

The component must have content, at least a single nested tag to define the component's visual representation, and, optionally, it may have variables and methods assigned to the component.

## Using Properties

<Callout type="info" emoji="ðŸ’¡">
  Component definitions can refer to properties passed to component instances.
</Callout>

Though reusable components with a static appearance may be helpful, the real power comes when you can define component properties to influence the appearance and behavior of a particular reusable component.

With a few additions, you can allow `LabeledValue` to receive a `label` and a `value` specification:

```ueml copy
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label}:</Text>
    <Text>{$props.value}</Text>
  </HStack>
</Component>
```

The `$props` context value defines the properties passed to the custom component. You can use the `.` operator to access a particular property. So, `$props.label` and `$props.value` mark the `label` and `value` properties, respectively. As you use these names in binding expressions, the engine will display their run time value.

Use the same markup to pass property values to reusable components as you do for built-in components:

```ueml
<App>
  <LabeledValue label="Firstname" value="Cameron" />
  -- Separator text --
  <LabeledValue label="Lastname" value="Smith" />
</App>
```

<Playground
    previewOnly
    name="LabeledText with properties"
    components={[`
      <Component name="LabeledValue">
        <HStack><Text>{$props.label}</Text>:<Text>{$props.value}</Text></HStack>
      </Component>
    `]}
    app={`
    <App>
      <LabeledValue label="Firstname" value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" value="Smith" />
    </App>
    `}
    height={170}
/>

<Callout type="info" emoji="ðŸ“”">
XMLUI does not require defining component properties in advance. You just use your property through the `$props` identifier; the engine will immediately understand and render it.
</Callout>

Sometimes, it is helpful to have default values for properties. XMLUI makes it simple using the `??` operator, as you can see in the following component definition:

```ueml
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label ?? '[label]'}:</Text>
    <Text>{$props.value ?? '[none]'}</Text>
  </HStack>
</Component>
```

<Playground
    previewOnly
    name="LabeledText with default property values"
    components={[`
      <Component name="LabeledValue">
        <HStack>
          <Text>{$props.label ?? '[label]'}</Text>:
          <Text>{$props.value ?? '[none]'}</Text>
        </HStack>
      </Component>
    `]}
    app={`
    <App>
      <LabeledValue value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" />
    </App>
    `}
    height={170}
/>

## Using Events

<Callout type="info" emoji="ðŸ’¡">
  Similarly to properties, you can harness a reusable component with custom events.
</Callout>

Create a new reusable component, `<IncButton>`, which increments its value for every click. This component can notify its environment about increments by firing an event. This event receives the current counter as an event parameter:

```ueml copy {4}
<Component name="IncButton">
  <Button 
    label="Click to increment: {count}" var.count="{0}" 
    onClick="count++; emitEvent('incremented', count)" />
</Component>
```

The `emitEvent` function emits the `"incremented"` event attached to the reusable component's instance and triggers the particular event handler. The first argument of `emitEvent` is the event name, and the subsequent ones are the arguments of the specific event.

The following app uses the new event to append the number of clicks to a text. The handler of the `incremented` event (`onIncremented`) declares an arrow function where `v` represents the event value, namely, the count of clicks:

```ueml copy
<App var.text="">
  <IncButton onIncremented="v => text += ' ' + v" />
  <Text value="{text}" />
</App>
```

Try using `<IncButton>` with the `incremented` event:

<Playground
    previewOnly
    name="IncButton with an event"
    components={[`
      <Component name="IncButton">
        <Button 
          label="Click to increment: {count}" var.count="{0}" 
          onClick="count++; emitEvent('incremented', count)" />
      </Component>
    `]}
    app={`
    <App var.text="">
      <IncButton onIncremented="v => text += ' ' + v" />
      <Text value="{text}" />
    </App>
    `}
    height={140}
/>

## Exposing Component Methods [#exposing-methods]

<Callout type="info" emoji="ðŸ’¡">
  In addition to properties and events, you can expose custom methods from a particular component. 
</Callout>

You can invoke these methods in other components to execute an operation or query some information in the exposing component.

The following code snippet shows a modified `<IncButton>` component that exposes a method, `setValue`, to set the button's counter value from outside the component:

```ueml copy {4} 
<Component 
  name="IncButton" 
  var.count="{0}" 
  method.setValue="v => count = v">
  <Button label="Click to increment: {count}" onClick="count++" />
</Component>
```

<Callout type="info" emoji="ðŸ“”">
  Variables defined within a reusable component are invisible from outside. **However, with methods, you can expose them**.
</Callout>

The updated component stores the counter value in a variable belonging to the entire component (and not enclosed within the `<Button>`). This line declares the `setValue` method with an arrow function with the parameter receiving the new value (`v`).

The following app adds a second button to set the current value of `<IncButton>` to 123 on a click. Here, we provide an `id` for `<IncButton>` to refer to it from the second button:

```ueml copy {3,6}
<App>
  <HStack>
    <IncButton id="myIncButton" />
    <Button 
      label="Set count to 123!" 
      onClick="myIncButton.setValue(123)" />
  </HStack>
</App>
```
The click event handler (`onClick`) of the second button uses the `myIncButton.setValue()` expression to invoke the `setValue` method associated with the `myIncButton` instance.

Try using this simple app:

<Playground
    previewOnly
    name="IncButton with an exposed method"
    components={[`
      <Component name="IncButton" var.count="{0}" method.setValue="v => count = v">
        <Button label="Click to increment: {count}" onClick="count++" />
      </Component>
`]}
    app={`
    <App>
      <HStack>
        <IncButton id="myIncButton" />
        <Button label="Set count to 123!" onClick="myIncButton.setValue(123)" />
      </HStack>
    </App>
    `}
    height={100}
/>

## `<Slot>`

<Callout type="info" emoji="ðŸ’¡">
  You can use the `Slot` placeholder within a reusable component's definition to mark the location when the reusable component's children should be injected. 
</Callout>

Here, `Slot` is nested into `VStack` to mark the location to inject `MyStack` children:

```ueml copy {4}
<Component name="MyStack">
  <H2>This is my special Stack</H2>
  <VStack backgroundColor="cyan">
    <Slot/>
  </VStack>
</Component>
```

This sample injects children into `MyStack`:

```ueml copy {2-4}
<App>
  <MyStack>
  These are the children injected into the
  <H3>MyStack</H3>
  component's Slot placeholder
  </MyStack>
</App>
```

`MyStack` puts the children into the location designated by `Slot`:

<Playground
    previewOnly={true}
    name="Example: Using Slot"
    horizontal={true}
    height={200}
    components={[
        `
    <Component name="MyStack">
      <H2>This is my special Stack</H2>
      <VStack padding="1rem" gap="0.2rem" backgroundColor="cyan">
       <Slot/>
      </VStack>
    </Component>
  `,
    ]}
    app={`
    <App>
      <MyStack>
      These are the children injected into the
      <H3>MyStack</H3>
      component's Slot placeholder
      </MyStack>
    </App>
  `}
/>

_TODO: Now that we allow named slots for reusable components with template properties, document this feature._

## Reusable Components in Layout Containers

<Callout type="info" emoji="ðŸ’¡">
  When the engine renders a reusable component in a particular layout container, the rendered component **accommodates its container's layout context**. 
</Callout>

Let's create a reusable component, `MyBoxes`, with this markup:

```ueml copy
<Component name="MyBoxes">
  <Stack width="100px" height="36px" backgroundColor="purple" />
  <Stack width="50px" height="36px" backgroundColor="orange" />
</Component>
```

`MyBoxes` displays two boxes with different sizes and background color settings. This declaration does not specify how these two boxes should relate to each other; it only says the orange box follows the purple box.

Nest `MyBoxes` instances into an `HStack`: 

```ueml copy
<App>
  <HStack>
    <MyBoxes />
    <MyBoxes />
  </HStack>
</App>
```

It results in this output:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a HStack"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </Component>
    `,
    ]}
    app={`
    <App>
      <HStack>
        <MyBoxes />
        <MyBoxes />
      </HStack>
    </App>
  `}
/>

Now, use a `VStack`:

```ueml copy
<App>
  <VStack>
    <MyBoxes />
    <MyBoxes />
  </VStack>
</App>
```

The previous output changes to this:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a VStack"
    horizontal={true}
    height={260}
    components={[`
      <Component name="MyBoxes">
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </Component>
    `,
    ]}
    app={`
    <App>
      <VStack>
        <MyBoxes />
        <MyBoxes />
      </VStack>
    </App>
  `}
/>

Using a `FlowLayout` wrapper results in a third display:

```ueml copy
<App>
  <FlowLayout>
    <MyBoxes />
    <MyBoxes />
  </FlowLayout>
</App>
```

<Playground
    previewOnly={true}
    name="Example: MyBoxes in FlowLayout"
    horizontal={true}
    height={230}
    components={[`
      <Component name="MyBoxes">
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </Component>
    `,
    ]}
    app={`
    <App>
      <FlowLayout>
        <MyBoxes />
        <MyBoxes />
      </FlowLayout>
    </App>
  `}
/>

### Component Flattening

Each layout container uses its strategy to render the nested children. Though a `<Component>` tag wraps the two boxes within `MyBoxes`, that tag does not create any extra artifact. The rendering engine puts the two children of `MyBoxes` as if you put them directly in their layout components. So, when you wrap the two `MyBoxes` instances into an `HStack`, the results is as if you used this markup:

```ueml copy
<App>
  <HStack>
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack>
</App>
```

<Playground
    previewOnly={true}
    name="Example: flattening MyBoxes in an HStack"
    horizontal={true}
    height={100}
    app={`
      <App>
        <HStack>
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </App>
  `}
/>

The same flattening happens with a `VStack`. 

However, the `FlowLayout` container does not flatten the children. It keeps the two `MyBoxes` instances as separate entities.

### Using Layout Containers Explicitly

Use an explicit layout container within the component definition to avoid child component flattening. For example, if you want the purple and orange boxes in a particular layout (within the component), you can explicitly declare that intention:

```ueml copy /HStack gap="0" border="2px dotted green"/
<Component name="MyBoxes">
  <HStack gap="0" border="2px dotted green" >
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack>
</Component>
```

<Callout type="info" emoji="ðŸ“”">
  This definition adds a border to the component to display the UI patch it fills.
</Callout>

Now, the output is different. You see this with an `HStack`:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a HStack (explicit layout)"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <HStack>
        <MyBoxes />
        <MyBoxes />
      </HStack>
    </App>
  `}
/>

With a `VStack`, this is the output:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a VStack (explicit layout)"
    horizontal={true}
    height={160}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <VStack>
        <MyBoxes />
        <MyBoxes />
      </VStack>
    </App>
  `}
/>

The display with a `FlowLayout`:

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a FlowLayout (explicit layout)"
    horizontal={true}
    height={160}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <FlowLayout>
        <MyBoxes />
        <MyBoxes />
      </FlowLayout>
    </App>
  `}
/>

## Using Explicit Component Width

Because `MyBoxes` does not use an explicit component width, nesting them into a `VStack` or a `FlowLayout` will size them to the available width. If your intention is different, you can use an explicit width specification in the `MyBoxes` declaration:

```ueml copy /width="180px"/
<Component name="MyBoxes">
  <HStack gap="0" border="2px dotted green" width="180px" >
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack>
</Component>
```

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a HStack (explicit width)"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" width="180px" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <HStack>
        <MyBoxes />
        <MyBoxes />
      </HStack>
    </App>
  `}
/>

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a VStack (explicit width)"
    horizontal={true}
    height={160}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" width="180px">
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <VStack>
        <MyBoxes />
        <MyBoxes />
      </VStack>
    </App>
  `}
/>

_We have a bug in FlowLayout; it should respect the "180px" width value, but it does not. TODO: Check the sample after fixing the bug._

<Playground
    previewOnly={true}
    name="Example: MyBoxes in a FlowLayout (explicit width)"
    horizontal={true}
    height={160}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" width="180px" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <FlowLayout>
        <MyBoxes />
        <MyBoxes />
      </FlowLayout>
    </App>
  `}
/>
