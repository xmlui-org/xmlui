import { Callout } from 'nextra/components'

# Reusable Components

<Callout type="info" emoji="ðŸ’¡">
  XLMUI has been designed with **reusable components** in mind. Besides the components out-of-the box, you can use the markup to create and utilize your reusable components within your app.
</Callout>

This article will teach you the gritty-nitty details of component creation and customization.

## Defining Reusable Components

<Callout type="info" emoji="ðŸ’¡">
  Use the `<Component>` tag to declare a reusable component in the markup. This tag has a mandatory attribute, `name`, a unique identifier to the component.
</Callout>

```ueml copy filename="components/LabeledValue.xmlui"
<Component name="LabeledValue">
  <HStack>
    <Text>Label:</Text>
    <Text>Value</Text>
  </HStack>
</Component>
```

You can immediately use the new component type, `LabeledValue`, putting it into your app using the `<LabeledValue>` tag:

```ueml copy filename="Main.xmlui"
<App>
  <LabeledValue />
  -- Separator text --
  <LabeledValue />
</App>
```

The XMLUI engine displays all `LabeledValue` component instances:

<Playground
  name="LabeledText"
  components={[`
    <Component name="LabeledValue">
      <HStack>
        <Text>Label:</Text>
        <Text>Value</Text>
      </HStack>
    </Component>
  `]}
  app={`
    <App>
      <LabeledValue />
      -- Separator text --
      <LabeledValue />
    </App>
  `}
/>

<Callout type="info" emoji="ðŸ’¡">
  The component's name must start with an uppercase letter followed by letters, digits, the underscore (`_`), or the dollar sign (`$`) character. Components must be placed into separate files in the `components` folder within the app's root folder. **Use the same name for the component as its filename so that the browser can fetch the component.**
</Callout>

The component must have content, at least a single nested tag to define the component's visual representation, and, optionally, it may have variables and methods assigned to the component.

## Using Properties

<Callout type="info" emoji="ðŸ’¡">
  Component definitions can refer to properties passed to component instances.
</Callout>

Though reusable components with a static appearance may be helpful, the real power comes when you can define component properties to influence the appearance and behavior of a particular reusable component.

With a few additions, you can allow `LabeledValue` to receive a `label` and a `value` specification:

```ueml copy
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label}:</Text>
    <Text>{$props.value}</Text>
  </HStack>
</Component>
```

The `$props` context value defines the properties passed to the custom component. You can use the `.` operator to access a particular property. So, `$props.label` and `$props.value` mark the `label` and `value` properties, respectively. As you use these names in binding expressions, the engine will display their run time value.

Use the same markup to pass property values to reusable components as you do for built-in components:

```ueml
<App>
  <LabeledValue label="Firstname" value="Cameron" />
  -- Separator text --
  <LabeledValue label="Lastname" value="Smith" />
</App>
```

<Playground
  name="LabeledText with properties"
  components={[`
    <Component name="LabeledValue">
      <HStack><Text>{$props.label}</Text>:<Text>{$props.value}</Text></HStack>
    </Component>
  `]}
  app={`
    <App>
      <LabeledValue label="Firstname" value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" value="Smith" />
    </App>
  `}
/>

<Callout type="info" emoji="ðŸ“”">
XMLUI does not require defining component properties in advance. You just use your property through the `$props` identifier; the engine will immediately understand and render it.
</Callout>

Sometimes, it is helpful to have default values for properties. XMLUI makes it simple using the `??` operator, as you can see in the following component definition:

```ueml
<Component name="LabeledValue">
  <HStack>
    <Text>{$props.label ?? '[label]'}:</Text>
    <Text>{$props.value ?? '[none]'}</Text>
  </HStack>
</Component>
```

<Playground
  name="LabeledText with default property values"
  components={[`
    <Component name="LabeledValue">
      <HStack>
        <Text>{$props.label ?? '[label]'}</Text>:
        <Text>{$props.value ?? '[none]'}</Text>
      </HStack>
    </Component>
  `]}
  app={`
    <App>
      <LabeledValue value="Cameron" />
      -- Separator text --
      <LabeledValue label="Lastname" />
    </App>
  `}
/>

## Using Events

<Callout type="info" emoji="ðŸ’¡">
  Similarly to properties, you can harness a reusable component with custom events.
</Callout>

Create a new reusable component, `<IncButton>`, which increments its value for every click. This component can notify its environment about increments by firing an event. This event receives the current counter as an event parameter:

```ueml copy {4}
<Component name="IncButton">
  <Button
    label="Click to increment: {count}" var.count="{0}"
    onClick="count++; emitEvent('incremented', count)" />
</Component>
```

The `emitEvent` function emits the `"incremented"` event attached to the reusable component's instance and triggers the particular event handler. The first argument of `emitEvent` is the event name, and the subsequent ones are the arguments of the specific event.

The following app uses the new event to append the number of clicks to a text. The handler of the `incremented` event (`onIncremented`) declares an arrow function where `v` represents the event value, namely, the count of clicks:

```ueml copy
<App var.text="">
  <IncButton onIncremented="v => text += ' ' + v" />
  <Text value="{text}" />
</App>
```

Try using `<IncButton>` with the `incremented` event:

<Playground
  name="IncButton with an event"
  components={[`
    <Component name="IncButton">
      <Button
        label="Click to increment: {count}" var.count="{0}"
        onClick="count++; emitEvent('incremented', count)" />
    </Component>
  `]}
  app={`
    <App var.text="">
      <IncButton onIncremented="v => text += ' ' + v" />
      <Text value="{text}" />
    </App>
  `}
/>

## Exposing Component Methods [#exposing-methods]

<Callout type="info" emoji="ðŸ’¡">
  In addition to properties and events, you can expose custom methods from a particular component.
</Callout>

You can invoke these methods in other components to execute an operation or query some information in the exposing component.

The following code snippet shows a modified `<IncButton>` component that exposes a method, `setValue`, to set the button's counter value from outside the component:

```ueml copy {4}
<Component
  name="IncButton"
  var.count="{0}"
  method.setValue="v => count = v">
  <Button label="Click to increment: {count}" onClick="count++" />
</Component>
```

<Callout type="info" emoji="ðŸ“”">
  Variables defined within a reusable component are invisible from outside. **However, with methods, you can expose them**.
</Callout>

The updated component stores the counter value in a variable belonging to the entire component (and not enclosed within the `<Button>`). This line declares the `setValue` method with an arrow function with the parameter receiving the new value (`v`).

The following app adds a second button to set the current value of `<IncButton>` to 123 on a click. Here, we provide an `id` for `<IncButton>` to refer to it from the second button:

```ueml copy {3,6}
<App>
  <HStack>
    <IncButton id="myIncButton" />
    <Button
      label="Set count to 123!"
      onClick="myIncButton.setValue(123)" />
  </HStack>
</App>
```
The click event handler (`onClick`) of the second button uses the `myIncButton.setValue()` expression to invoke the `setValue` method associated with the `myIncButton` instance.

Try using this simple app:

<Playground
  name="IncButton with an exposed method"
  components={[`
    <Component name="IncButton" var.count="{0}" method.setValue="v => count = v">
      <Button label="Click to increment: {count}" onClick="count++" />
    </Component>
  `]}
  app={`
    <App>
      <HStack>
        <IncButton id="myIncButton" />
        <Button label="Set count to 123!" onClick="myIncButton.setValue(123)" />
      </HStack>
    </App>
  `}
/>

## `<Slot>`

<Callout type="info" emoji="ðŸ’¡">
  You can use the `Slot` placeholder within a reusable component's definition to mark the location when the reusable component's children should be injected.
</Callout>

Here, `Slot` is nested into `VStack` to mark the location to inject `MyStack` children:

```ueml copy {4}
<Component name="MyStack">
  <H2>This is my special Stack</H2>
  <VStack backgroundColor="cyan">
    <Slot/>
  </VStack>
</Component>
```

This sample injects children into `MyStack`:

```ueml copy {2-4}
<App>
  <MyStack>
  These are the children injected into the
  <H3>MyStack</H3>
  component's Slot placeholder
  </MyStack>
</App>
```

`MyStack` puts the children into the location designated by `Slot`:

<Playground
  name="Example: Using Slot"
  horizontal={true}
  components={[`
    <Component name="MyStack">
      <H2>This is my special Stack</H2>
      <VStack padding="1rem" gap="0.2rem" backgroundColor="cyan">
       <Slot/>
      </VStack>
    </Component>
  `,
    ]}
  app={`
    <App>
      <MyStack>
      These are the children injected into the
      <H3>MyStack</H3>
      component's Slot placeholder
      </MyStack>
    </App>
  `}
/>

## Reusable Components in Layout Containers

When you use reusable components with layout containers wrapping them, displaying a particular markup is not always obvious. The reusable components may nest other layout containers. As you do not see these nested containers from the markup directly, sometimes you may not understand immediately a particular component arrangement.

In this section, you will learn a few details about how reusable components are displayed within layout containers.

Let's create a reusable component, `MyBoxes`, with this markup:

```ueml copy
<Component name="MyBoxes">
  <Stack width="100px" height="36px" backgroundColor="purple" />
  <Stack width="50px" height="36px" backgroundColor="orange" />
</Component>
```

`MyBoxes` displays two boxes with different sizes and background color settings. Its declaration only tells the orange box to follow the purple box.

### Reusable Components in a Stack

<Callout type="info" emoji="ðŸ’¡">
  When you nest a reusable component into a stack, **the engine ignores all layout-related properties decorating the reusable component instance**.
</Callout>

Nest the `MyBoxes` instances into an `HStack`:

```ueml copy /width="50%"/
<App>
  <HStack>
    <MyBoxes width="50%" />
    <MyBoxes />
  </HStack>
</App>
```

The engine renders this markup as if your declaration was this (it ignores the `width="50%` of the first `MyBoxes`):

```ueml copy
<App>
  <HStack>
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack> 
</App>
```

Thus, the markup with `MyBoxes` results in this output:

<Playground
  name="Example: MyBoxes in a HStack"
  horizontal={true}
  components={[`
    <Component name="MyBoxes">
      <Stack width="100px" height="36px" backgroundColor="purple" />
      <Stack width="50px" height="36px" backgroundColor="orange" />
    </Component>
  `,
  ]}
  app={`
    <App>
      <HStack>
        <MyBoxes width="50%" />
        <MyBoxes />
      </HStack>
    </App>
  `}
/>

When you wrap `MyBoxes` into a `VStack`:

```ueml copy
<App>
  <VStack>
    <MyBoxes />
    <MyBoxes />
  </VStack>
</App>
```

The engine renders the markup as if it were this one:

```ueml copy
<App>
  <VStack>
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </VStack>
</App>
```

Thus, the markup with `MyBoxes` in a wrapping `VStack` renders this:

<Playground
    name="Example: MyBoxes in a VStack"
    horizontal={true}
    height={260}
    components={[`
      <Component name="MyBoxes">
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </Component>
    `,
    ]}
    app={`
    <App>
      <VStack>
        <MyBoxes />
        <MyBoxes />
      </VStack>
    </App>
  `}
/>

Because stacks use a non-zero gap by default, you see this gap between the children of `MyBoxes`.

### Reusable Components in a FlowLayout

While the stack components utilize the actual children of reusable components without wrapping or transforming them, **`FlowLayout` works differently**. To provide its functionality, it wraps each direct child into an internal container and removes the direct child's width settings. This internal container takes the width from the reusable component definition.

Assume you use `MyBoxes` with a `FlowLayout`, like in this example:

```ueml copy
<App>
  <FlowLayout>
    <MyBoxes width="50%" />
    <MyBoxes />
  </FlowLayout>
</App>
```

Because of the internal wrapping, the engine renders a markup like this:

```ueml copy
<App>
  <FlowLayout>
    <FlowLayoutItem width="50%">
      <Stack height="36px" backgroundColor="purple" />
      <Stack height="36px" backgroundColor="orange" />
    </FlowLayoutItem>
    <FlowLayoutItem>
      <Stack height="36px" backgroundColor="purple" />
      <Stack height="36px" backgroundColor="orange" />
    </FlowLayoutItem>
  </FlowLayout>
</App>
```

<Callout type="info" emoji="ðŸ“”">
  Note that the original `Stack` widths within `MyBoxes` are removed, and the 50% width of the first `MyBoxes` is transposed into the first virtual `FlowLayoutItem`.
</Callout>

<Playground
  name="Example: MyBoxes in FlowLayout"
  horizontal={true}
  components={[`
    <Component name="MyBoxes">
      <Stack width="100px" height="36px" backgroundColor="purple" />
      <Stack width="50px" height="36px" backgroundColor="orange" />
    </Component>
  `,
  ]}
  app={`
    <App>
      <FlowLayout>
        <MyBoxes width="50%" />
        <MyBoxes />
      </FlowLayout>
    </App>
  `}
/>

<Callout type="info" emoji="ðŸ“”">
  The purple and orange boxes are adjacent because the virtual `FlowLayoutItem` container does not use gaps. XMLUI does not provide a `FlowLayoutItem` component; we use this name here just for explanation.
</Callout>

### Using Layout Containers Explicitly

Use an explicit layout container within the component definition to avoid child component flattening. For example, if you want the purple and orange boxes in a horizontal layout (within the component), you can explicitly declare that intention:

```ueml copy /HStack gap="0" border="2px dotted green"/
<Component name="MyBoxes">
  <HStack gap="0" border="2px dotted green" >
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack>
</Component>
```

<Callout type="info" emoji="ðŸ“”">
  This definition adds a dotted green border to the component to display the UI patch it fills for demonstration purposes.
</Callout>

Wrap two `MyBoxes` instances into an `HStack`. The output differs from the one where you did not have an explicit layout container within `MyBoxes`. There is no gap between the purple and orange boxes as the `HStack` sets the gap explicitly to zero.

<Playground
  name="Example: MyBoxes in a HStack (explicit layout)"
  horizontal={true}
  components={[`
    <Component name="MyBoxes">
      <HStack gap="0" border="2px dotted green" >
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </HStack>
    </Component>
  `,
  ]}
  app={`
    <App>
      <HStack>
        <MyBoxes />
        <MyBoxes />
      </HStack>
    </App>
  `}
/>

<Callout type="info" emoji="ðŸ“”">
Remember, an item's width in a horizontal stack (unless explicitly set) accommodates the content's width, which is 180 pixels here.
</Callout>

You get this output when you wrap the two `MyBoxes` instances into a `VStack`:

<Playground
  name="Example: MyBoxes in a VStack (explicit layout)"
  horizontal={true}
  components={[`
    <Component name="MyBoxes">
      <HStack gap="0" border="2px dotted green" >
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </HStack>
    </Component>
  `,
  ]}
  app={`
    <App>
      <VStack>
        <MyBoxes />
        <MyBoxes />
      </VStack>
    </App>
  `}
/>

<Callout type="info" emoji="ðŸ“”">
  Remember, an item's width in a vertical stack (unless explicitly set) is the entire width (100%) within the stack's parent.
</Callout>

The display with a `FlowLayout`:

<Playground
  name="Example: MyBoxes in a FlowLayout (explicit layout)"
  horizontal={true}
  components={[`
    <Component name="MyBoxes">
      <HStack gap="0" border="2px dotted green" >
        <Stack width="100px" height="36px" backgroundColor="purple" />
        <Stack width="50px" height="36px" backgroundColor="orange" />
      </HStack>
    </Component>
  `,
  ]}
  app={`
    <App>
      <FlowLayout>
        <MyBoxes />
        <MyBoxes />
      </FlowLayout>
    </App>
  `}
/>

<Callout type="info" emoji="ðŸ“”">
  Remember, an item's width in a `FlowLayout` (unless explicitly set) is the entire width (100%) within the parent.
</Callout>


### Using Explicit Component Width

When you use a layout container within a reusable component, you can assign an explicit width to that container, like in this example:

```ueml copy /width="180px"/
<Component name="MyBoxes">
  <HStack gap="0" border="2px dotted green" width="180px" >
    <Stack width="100px" height="36px" backgroundColor="purple" />
    <Stack width="50px" height="36px" backgroundColor="orange" />
  </HStack>
</Component>
```

The purple and orange boxes are in a horizontal stack set to 180 pixels wide. This definition sets a dotted green border around the horizontal stack for demonstration purposes.

Place two `MyBoxes` instances in an `HStack`:

```ueml copy
<App>
  <HStack>
    <MyBoxes />
    <MyBoxes />
  </HStack>
</App>
```

The engine renders this output:

<Playground

    name="Example: MyBoxes in a HStack (explicit width)"
    horizontal={true}
    height={100}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" width="180px" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <HStack>
        <MyBoxes />
        <MyBoxes />
      </HStack>
    </App>
  `}
/>

<Playground

    name="Example: MyBoxes in a VStack (explicit width)"
    horizontal={true}
    height={160}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" width="180px">
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <VStack>
        <MyBoxes />
        <MyBoxes />
      </VStack>
    </App>
  `}
/>

As you already learned, `FlowLayout` removes its direct children's explicit widths and uses the width assigned to the reusable component. So, even if you use a 180-pixel wide `HStack` within `MyBoxes`, `FlowLayout` ignores that width. Nonetheless, the two stacks within `HStack` are non-direct children, so their width is kept.

<Playground

    name="Example: MyBoxes in a FlowLayout (explicit width)"
    horizontal={true}
    height={160}
    components={[`
      <Component name="MyBoxes">
        <HStack gap="0" border="2px dotted green" width="180px" >
          <Stack width="100px" height="36px" backgroundColor="purple" />
          <Stack width="50px" height="36px" backgroundColor="orange" />
        </HStack>
      </Component>
    `,
    ]}
    app={`
    <App>
      <FlowLayout>
        <MyBoxes />
        <MyBoxes />
      </FlowLayout>
    </App>
  `}
/>
