import mySimpleApp from "./samples/themes/my-simple-app.xmlui";
import mySimpleAppLight from "./samples/themes/my-simple-app-light.xmlui";
import gallery from "./samples/themes/gallery.xmlui";
import galleryBrief from "./samples/themes/theme-gallery-brief.xmlui";
import myThemedApp from "./samples/themes/my-themed-app.xmlui";
import inputs from "./samples/themes/inputs.xmlui";
import { THEME_VARIABLES, THEME_VARIABLES_APP_BOUND_TRAITS, THEME_VARIABLES_PROPERTY_NAMES, THEME_VARIABLES_VISUAL_STATES, COMPONENT_THEME, THEMES_REFERENCE, THEMES, THEMES_DEFINITIONS, WORKING_WITH_RESOURCES } from "../../meta/pages";
import { Callout } from 'nextra/components';
import { LAYOUT_PROPERTIES } from "../../meta/pages";

# Themes

<Callout type="info" emoji="ðŸ’¡">
XMLUI has a powerful theme system that allows you to change the default theme. XMLUI themes are multi-tone: a single theme file defines color variants for the light and dark tones.
</Callout>

XMLUI ships with a few themes; you can check them <SmartLink href={THEMES_DEFINITIONS}>here</SmartLink>.

In this article, you will learn the basics of XMLUI's theme management, including the themes' structure, theme variables, and theme inheritance.

## Theme IDs and Tones

Each theme has an identifier. To apply a particular theme, change the "defaultTheme" property in the app's configuration file to its ID. By default, an app uses the light tone; however, you can change it to dark by setting the "defaultTone" property to "dark".

The following sample uses the default theme (its ID is "xmlui") with the default light tone:

<Playground
  previewOnly
  name="Theme: xmlui (light)"
  app={`
    <Theme tone="light" themeId="xmlui">
        <ThemeGallery />
      </Theme>  
    `}
  components={[galleryBrief]}
  height={280}
/>

Change the following properties in the configuration file:

```json
{
  "defaultTheme": "xmlui-purple",
  "defaultTone": "dark"
}
```

Now, you see the purple-shaded XMLUI theme with a dark tone.

<Playground
  previewOnly
  name="Theme: xmlui (light)"
  app={`
    <Theme tone="dark" themeId="xmlui-purple">
        <ThemeGallery />
      </Theme>  
    `}
  components={[galleryBrief]}
  height={280}
/>

## What a Theme Contains

Themes have a simple structure; they have a few properties and define theme variables and resource items. You can define a theme in a JSON file and add it to an app. A theme's JSON file has the following structure:

```json
{
  "id": "<the unique theme ID>",
  "name": "<the optional theme name>",
  "extends": ["<base theme ID 1>, <base theme ID 2>", "<...>"],
  "themeVars": {
    "<theme variable name>": "<theme variable value>",
    "<...>": "<...>",
    "light": {
      "<light tone specific theme variable name>": "<theme variable value>",
      "<...>": "<...>"
    },
    "dark": {
      "<dark tone specific theme variable name>": "<theme variable value>",
      "<...>": "<...>"
    }
  },
  "resources": {
    "<resource name>": "<resource value>",
    "<...>": "<...>"
  }
}
```

Simply said, a theme is a set of theme variables and resource definitions. Let's discuss the properties within a theme definition:
- **`id`**: This property is the unique identifier of the theme, a string.
- **`name`**: You can optionally provide a descriptive name for a theme; the framework may use it in the UI.
- **`extends`**: You do not have to define each theme from scratch; a theme can extend existing themes by defining only those theme variables and resources it intends to modify.
- **`themeVars`**: The theme variables that constitute the particular theme.
- **`resources`**: The resources defined in the particular theme.

In this article, we discuss only theme variables. You can learn more about resources in <SmartLink href={WORKING_WITH_RESOURCES}>this article</SmartLink>.

When you define theme variables, you can separate tone-independent values from tone-dependent ones. In most cases, tone-dependent variables are colors or color-including values, such as color, background color, shadow, etc. You can separate the color-dependent theme variables by using the "light" and "dark" property names as the following example shows (using theme variables of a fictional `MyComponent`):

```json
{
  "themeVars": {
    "font-size-MyComponent": "2rem",
    "radius-MyComponent": "8px",
    "style-border-MyComponent": "solid",
    "light": {
      "color-bg-MyComponent": "white",
      "color-text-MyComponent": "black"
    },
    "dark": {
      "color-bg-MyComponent": "black",
      "color-text-MyComponent": "white"
    }
  },
}
```

## Theme Scopes

You can quickly change an app's theme by configuring a different theme in the app's configuration file. Besides using the app-level theme, you can apply other themes for a particular part of the app.

You can quickly change an app's theme by configuring a different theme in the app's configuration file. In addition to using the app-level theme, you can apply other themes for a particular part of the app.

_TBD_

## Theme Variable Semantics

The concept of theme variables is pivotal in XMLUI. When you style an app, a component, or a particular part of the app, you do it with theme variables.

<Callout type="info" emoji="ðŸ’¡">
XMLUI allows the creation of new themes and the customizing of existing ones with the least amount of effort. To support this, theme variables have a unique naming convention that the engine leverages when rendering visual components.
</Callout>

Each theme variable name follows a naming convention to leverage the arsenal of features the theming engine provides:

```text
<propertyName>-<ComponentId>-<trait1>-<trait2>--<state1>--<state2>--<stateN>
```

In this convention, the `<ComponentId>` part is optional.

- Those theme variables that do not use the `<ComponentId>` segment are _app-bound_ variables, so they define visuals that can be applied to the entire application, including multiple types of components.
- Variables with a `<ComponentId>` segment are _component-bound_ variables, which influence only the component's appearance defined by the corresponding ID.

<Callout type="warning" emoji="ðŸ’¡">
You can define theme variables that do not follow this convention; we call them _unbound_ variables. You can still use them; however, the theming engine simply replaces their occurrences with their values without utilizing intelligent feaures provided for app-bound and component-bound variables.
</Callout>

### Properties, Traits, and States

<Callout type="info" emoji="ðŸ’¡">
Each theme variable is used to define the value of a property influencing the visual appearance of a particular part of the UI. The `<propertyName>` segment defines such a visual property.
</Callout>

Here are a few examples:

- `color-text`: text color (or forecolor)
- `color-bg`: background color
- `text-size`: the size of the text
- `line-height`: the height of a text line
- `padding-horizontal`: The value declaring the horizontal padding space

The `<propertyName>` segment should use lowercase letters and dashes.

For the complete list of available `<propertyName>` values, see the <SmartLink href={THEME_VARIABLES_PROPERTY_NAMES}>Theme Property Names</SmartLink> article under "Theme Variables".

The `<trait1>` and `<trait2>` segments describe one or two traits regarding a particular component.

For example, the `Button` component has two traits that define its appearance. The `themeColor` trait defines the set of colors to use with the button; its available values are `primary`, `secondary`, and `attention`. The `variant` trait specifies the general appearance of the button (whether it has a border at all, etc.) with the values of `solid`, `outlined`, or `ghost`. The `themeColor` is the first trait, and `variant` is the second. So, we can use (among others) these theme variables to modify button colors:

- `color-bg-Button-primary-solid`: Defines the background color of a button that is set up to use the `primary` theme color, displayed with the `solid` variant.
- `color-border-Button-attention-ghost`: Specifies the border color of a ghost button displayed with the `attention` theme color.

See the <SmartLink href={THEME_VARIABLES_APP_BOUND_TRAITS}>App-Bount Traits</SmartLink> article under "Theme Variables" for the complete list of app-bound traits. You can check the traits of a particular component on its reference page.

The `<state1>`, ..., `<stateN>` values define visual states that may modify the appearance of a particular UI element or component (regarding a specific trait). Here are a few examples:

- `hover`: The mouse is hovered over the component
- `active`: The particular component is being activated by the user (for example, a user presses down the mouse button while over a button element)
- `focus`: The particular element (e.g., a textbox) currently has the focus

When defining a theme variable, you can define multiple state values (in any order). Let's see a few examples:

- `color-bg-Button-primary-solid--hover`: The background color to use with a `solid` button and with the `primary` theme color while the mouse hovers over it.
- `color-border-Button-attention-ghost--focus`: Specifies the border color of a focused ghost button displayed with the `attention` theme color.

For the complete list of available `<state>` values, see the <SmartLink href={THEME_VARIABLES_VISUAL_STATES}>Visual States</SmartLink> article in the "Theme Variables" reference.

### Theme Variable Chaining

Earlier, you have learned that theme variables following the naming conventions above are either app- or component-bound. When the name contains a `<ComponentId>` section, it is bound to the component with that ID. The component ID is always the name of the component (with the exact case) as you use them in the markup. For example, `Button` for the `<Button>` component, `Card` for the `<Card>` component, and so on.

<Callout type="info" emoji="ðŸ“”">
The individual XMLUI components are built to leverage as many app-bound theme properties as possible. Their design ensures that you can change their visual appearance by modifying only a few theme variables and also allows you to fine-tune component styles.
</Callout>

The theming engine uses several techniques to achieve this behavior. One of them is _theme variable chaining_.

This approach means that theme variables compose a chain and most fall back to a previous variable on that chain that is more generic. For example, here is a chain that sets the border color of a solid button using the primary color when the mouse hovers over it:

```text
color-primary
  color-Button
    color-bg-Button
      color-bg-Button-solid
        color-bg-Button-primary
          color-bg-Button-primary-solid
            color-bg-Button-primary-solid--hover
```

Theme variable chaining has two significant behaviors:

- **Traversal from the chain's last (bottom) element toward the first (top).** When the engine looks for a particular theme variable value, it searches it from the bottom toward the top until it finds the particular variable value to use. 
- **Tail pruning**. When you set the value of a theme variable somewhere in the chain, the other variables toward the bottom of the chain get cleared (they lose their values).

<Callout type="info" emoji="ðŸ“”">
Components may add logic to generate undefined lower-level theme variable values from upper-level values. For example, the `Button` component automaticaly creates fallback colors when the `color-Button` theme variable is set.
</Callout>

### Changing App-Bound Variables

Let's examine these behaviors with examples! Here, you see a gallery of assorted buttons, a badge, and a few text components using the default theme (light):

<Playground 
  previewOnly 
  name="Gallery with the default theme" 
  height={400} 
  app={gallery} />

Let's update the value of `color-primary`. This theme variable is at the top of the theme variable chain.

```json
{
  "color-primary": "orangered"
}
```

Due to the theme variable chaining, all components using the primary color (`Button` instances with their theme color property set to `primary` and `Badge` leverage the primary color) immediately change their appearance:

<Playground
  previewOnly
  name="Changing 'color-primary'"
  height={400}
  app={gallery}
  defaultTheme="sample"
  themes={[
    {
      name: "Sample",
      id: "sample",
      tone: "light",
      themeVars: {
        "color-primary": "orangered",
      },
    },
  ]}
/>

Try moving the mouse over the buttons labeled as primary and click them! You can see that the change in the `color-primary` theme variable affects other button colors, like the one used to indicate the hovered and pressed states. The theming engine ensures that the changes in `color-primary` update the related visual properties automatically. Besides the hover color, the border color changes, too.

### Changing Component-Bound Variables

Changing `color-primary` updated the primary color of all components, including the `Badge`. Suppose you want to keep the `Badge` component intact, because you intend to change only button colors. In that case, you should use the more specific `color-Button` theme variable, which (as it is a component-bound theme variable), affects only the `Button` component:

```json
{
  "color-Button": "orangered"
}
```

The result demonstrates that the `Badge` component remained intact. However, all buttons, independently of their color theme (`primary`, `secondary`, or `attention`) and variant (`solid`, `outlined`, or `ghost`) use the same colors.

<Callout type="info" emoji="ðŸ“”">
The `Button` component responds to the changes of the `color-Button` and updates the background, text, and border colors accordingly. It also updates the colors to use with the hover and active states.
</Callout>

<Playground
    previewOnly={true}
    name="Changing 'color-Button'"
    height={400}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-Button": "orangered",
            },
        },
    ]}
/>

### More Specific Variable Changes

The single change of `color-Button` redefined all button colors, which goes against the intention of having several theme colors. If you intend to change only the solid button using the primary color, the best theme variable to modify is `color-Button-primary-solid`:

```json
{
  "color-Button-primary-solid": "orangered"
}
```

The name of the property tells everything about its effect. Here, you can check that it affects only one of the buttons, as expected. Buttons with secondary and attention colors or using the outlined and ghost variants are intact.

<Playground
    previewOnly={true}
    name="Changing 'color-Button-primary-solid'"
    height={400}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-Button-primary-solid": "orangered",
            },
        },
    ]}
/>

Sometimes, you want to override a single visual property of a component, like the background color of the button when it is hovered:

```json
{
  "color-bg-Button--hover": "orangered"
}
```

This theme variable works as you expect! Move the mouse over any button to test the hover effect:

<Playground
    previewOnly={true}
    name="Changing 'color-bg-Button--hover'"
    height={400}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-bg-Button--hover": "orangered",
            },
        },
    ]}
/>

Following this pattern, you can tighten the theme variable to affect only a single button type's hover color, like in this sample:

```json
{
  "color-bg-Button-primary-solid--hover": "orangered"
}
```

Try the hover effect now! You can see now it affects only the top-left button (using the primary color theme with the solid variant):

<Playground
    previewOnly={true}
    name="Changing 'color-bg-Button-primary-solid--hover'"
    height={400}
    horizontal={true}
    app={gallery}
    defaultTheme="sample"
    themes={[
        {
            name: "Sample",
            id: "sample",
            tone: "light",
            themeVars: {
                "color-bg-Button-primary-solid--hover": "orangered",
            },
        },
    ]}
/>

### Component Theme Classes

Components can form a theming hierarchy. For example, many components represent some input fields, as the following example shows:

```ueml {3,4}
<Form id="driveForm" subject="{{car: 'Toyota Celica', year: '1999'}}" padding=1em>
  <FlowLayout paddingBottom=1em gap=1em>
    <FormItem width="50%" label="Car Type" bindTo="car" autoFocus="true" type="text" />
    <FormItem width="50%" label="Year" bindTo="year" autoFocus="true" type="integer" />
  </FlowLayout>
</Form>
```

<Playground previewOnly={true} name="Input components" height={200} horizontal={true} app={inputs} />

If you want to change their border rounding while keeping other components, such as the buttons intact, you could create a derived theme like this:

```json
{
  "id": "rounded",
  "name": "Rounded theme",
  "themeVars": {
    "radius-TextBox": "160px",
    "radius-NumberBox": "160px"
  }
}
```

The new theme works as you expect:

<Playground
    previewOnly={true}
    name="Input components with theme #1"
    height={200}
    horizontal={true}
    app={inputs}
    defaultTheme="rounded"
    themes={[
        {
            name: "Rounded",
            id: "rounded",
            themeVars: {
                "radius-TextBox": "160px",
                "radius-NumberBox": "160px",
            },
        },
    ]}
/>

Many components function as inputs. When you change some of their more generic visual attributes, such as the rounding of borders, you will likely change the same attribute of multiple component types. For example, you changed the border rounding of two components in the previous sample.

What if you intend to change the rounding of ten input component types? Following the pattern above, you would end up with a theme with ten different `radius-<component-name>` theme variables.

XMLUI provides a faster way to do this. Define the theme like this:

```json
{
  "id": "rounded",
  "name": "Rounded theme",
  "themeVars": {
    "radius-Input": "160px",
    "color-bg-Input": "papayawhip"
  }
}
```

This theme changes the rounding and the background color of **all** input components:

<Playground
    previewOnly={true}
    name="Input components with theme #2"
    height={200}
    horizontal={true}
    app={inputs}
    defaultTheme="rounded"
    themes={[
        {
            name: "Rounded",
            id: "rounded",
            themeVars: {
                "radius-Input": "160px",
                "color-bg-Input": "papayawhip",
            },
        },
    ]}
/>

The key to this behavior is the `Input` component name within the `radius-Input` and `color-bg-Input` variable names.

There is no `Input` component. `Input` is just an abstract *theme class name* used from theming. The `TextBox`, `NumberBox`, and other input components inherit visual attributes from this abstraction. This abstraction adds new theme variables to the theme variable chain of input components.

For example, the border rounding-related theme variable chain is the following for the `TextBox`:

```text
radius
  radius-Input
    radius-TextBox
```

<Callout type="info" emoji="ðŸ“”">
The reference information of components describes the theme classes a particular component inherits from.
</Callout>

## Theme Inheritance

You can descend new themes from existing themes. This pattern helps in the creation and maintainability of different theme variations.

Suppose you need to construct new theme variants (e.g. multiple color options) for your product leveraging your brand design. You can create a new theme for the primary brand elements, such as fonts, sizes, spacing, and other typography styles. Then, you can derive a few others to have different color options using the newly created theme as a base. In the derived themes, you define only the colors that distinguish the inherited theme from the base.

### Theme Inheritance Example

Let's create a new theme that applies typography elements according to your company's brand design. This theme defines some font-specific settings, spacings, and a few other traits:

```json
{
  "id": "brand-base",
  "name": "Brand Base Theme",
  "themeVars": {
    "space-base": "0.5rem",
    "font-family": "serif",
    "font-family-Heading": "sans-serif",
    "font-weight-H1": "font-weight-medium",
    "radius": "8px"
  }
}
```

Note how this theme modification changes the font (now it uses a serif font), lightens the heading text's weight, and increases spacing (see the Button).

<Playground
    previewOnly
    name="Base theme according the company brand design"
    height={200}
    horizontal
    app={myThemedApp}
    defaultTheme="brand-base"
    themes={[
        {
            name: "Brand Base Theme",
            id: "brand-base",
            themeVars: {
                "space-base": "0.5rem",
                "font-family": "serif",
                "font-family-Heading": "sans-serif",
                "font-weight-H1": "font-weight-medium",
                radius: "8px",
            },
        },
    ]}
/>

Leveraging theme inheritance, we can create several new themes based on the new company brand design:

```json
[
  {
    "id": "brand-purple",
    "name": "Brand Purple",
    "extends": ["brand-base"],
    "themeVars": {
      "color-primary": "purple"
    }
  },
  {
    "id": "brand-green",
    "name": "Brand Green",
    "extends": ["brand-base"],
    "themeVars": {
      "color-primary": "green"
    }
  }
]
```

All themes use the `extends` property to declare their base theme:

- `brand-purple` inherits `brand-base`. It overrides `color-primary` to get a purplish color.
- `brand-green` is derived from `brand-base`; it changes the primary color to green.

Let's see how the new themes alter the app's appearance:

<Playground
    previewOnly={true}
    name="Purple theme based on the basic brand design"
    height={200}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="brand-purple"
    themes={[
        {
            name: "Brand Base Theme",
            id: "brand-base",
            themeVars: {
                "space-base": "0.5rem",
                "font-family": "serif",
                "font-family-Heading": "sans-serif",
                "font-weight-H1": "font-weight-medium",
                radius: "8px",
            },
        },
        {
            name: "Brand Purple",
            id: "brand-purple",
            extends: ["brand-base"],
            themeVars: {
                "color-primary": "purple",
            },
        },
    ]}
/>

<Playground
    previewOnly={true}
    name="Green theme based on the basic brand design"
    height={200}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="brand-green"
    themes={[
        {
            name: "Brand Base Theme",
            id: "brand-base",
            themeVars: {
                "space-base": "0.5rem",
                "font-family": "serif",
                "font-family-Heading": "sans-serif",
                "font-weight-H1": "font-weight-medium",
                radius: "8px",
            },
        },
        {
            name: "Brand Green",
            id: "brand-green",
            extends: ["brand-base"],
            themeVars: {
                "color-primary": "green",
            },
        },
    ]}
/>

### Resolving Tone Conflicts

When deriving a new theme from an existing one, theme variable changes may cause undesired effects when the inherited theme changes its tone (for example, from light to dark). Let's see an example demonstrating such a situation!

We change the default theme of the app to emphasize button borders:

```json {5-7}
{
  "id": "em-border",
  "name": "Emphasized Button Border Theme",
  "themeVars": {
    "color-border-Button-primary-solid": "navy",
    "color-border-Button-primary-solid--hover": "purple",
    "thickness-border-Button": "0.25em"
  }
}
```

When you move the mouse over the button (try it!), the border changes to a purple color:

<Playground
    previewOnly={true}
    name="Custom theme"
    height={230}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="em-border"
    themes={[
        {
            name: "Emphasized Button border theme",
            id: "em-border",
            themeVars: {
                "color-border-Button-primary-solid": "navy",
                "color-border-Button-primary-solid--hover": "purple",
                "thickness-border-Button": "0.25em",
            },
        },
    ]}
/>

Now, create a variant of this theme with the following definition, which changes the Button's color from blue to contrasting orange and adds a darker border color:

```json {6-7}
{
  "id": "em-border-orange",
  "name": "Emphasized Button border with orange",
  "extends": ["em-border"],
  "themeVars": {
    "color-Button": "orange",
    "color-border-Button-primary-solid": "orangered"
  }
}
```

Because the base theme defines the `color-border-Button-primary-solid--hover` theme variable with the `purple` value, we expect that due to the inheritance, the dark theme uses this value and displays a purple color when you hover the mouse over the button.

However, when you try the modified theme, the hover effect changes the border to an orangish color, reflecting the buttons's base color:

<Playground
    previewOnly={true}
    name="Emphasized Button border with orange"
    height={230}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="em-border-orange"
    themes={[
        {
            name: "Emphasized Button Border Theme",
            id: "em-border",
            themeVars: {
                "color-border-Button-primary-solid": "navy",
                "color-border-Button-primary-solid--hover": "mediumorchid",
                "thickness-border-Button": "0.25em",
            },
        },
        {
            name: "Emphasized Button border dark theme",
            id: "em-border-orange",
            extends: ["em-border"],
            themeVars: {
                "color-Button": "orange",
                "color-border-Button-primary-solid": "orangered",
            },
        },
    ]}
/>

*This is not a bug!* When you override the `color-border-Button-primary-solid` theme variable in the derived theme to reflect the dark nature of the theme, the theming engine applies tail pruning and undefines all theme variables behind `color-border-Button-primary-solid` in the theme variable chain. The hovered border color is (`color-border-Button-primary-solid
--hovered`) among the undefined ones; thus, the hovered color does not reflect the purple color declared in the base theme.

You can easily handle tail pruning; add the pruned theme variable definition with a new value that matches the dark theme. In this case, use medium-purple instead of purple:

```json {8}
{
  "id": "em-border-orange",
  "name": "Emphasized Button border orange theme",
  "extends": ["em-border"],
  "themeVars": {
    "color-Button": "orange",
    "color-border-Button-primary-solid": "orangered",
    "color-border-Button-primary-solid--hover": "mediumpurple"
  }
}
```

<Playground
    previewOnly={true}
    name="Emphasized Button border with fixed orange"
    height={230}
    horizontal={true}
    app={myThemedApp}
    defaultTheme="em-border-dark"
    themes={[
        {
            name: "Emphasized Button Border Theme",
            id: "em-border",
            themeVars: {
                "color-border-Button-primary-solid": "navy",
                "color-border-Button-primary-solid--hover": "purple",
                "thickness-border-Button": "0.25em",
            },
        },
        {
            name: "Emphasized Button border dark theme",
            id: "em-border-dark",
            tone: "dark",
            extends: ["em-border"],
            themeVars: {
                "color-Button": "orange",
                "color-border-Button-primary-solid": "orangered",
                "color-border-Button-primary-solid--hover": "mediumpurple",
            },
        },
    ]}
/>

### Inheriting from Multiple Themes

XMLUI supports multiple theme inheritance. You can create a new theme by inheriting properties from more than one theme. This feature is beneficial when you create theme matrixes.

When you create multiple templates for an app, those can be divided into two main groups. Some theme groups define the general appearance, such as font, spacing, sizes, etc. Other groups define only colors. This division offers an opportunity to create theme matrixes where rows convey the general appearance and columns represent the different color variants.

With the multiple theme inheritance in XMLUI, it is easy to create such theme matrixes. Assume you want to define a small theme matrix with three general appearance theme types and three color variants:

| Themes           | Color #1      | Color #2      | Color #3      |
| ---------------- | ------------- | ------------- | ------------- |
| **Apperance #1** | `app1-color1` | `app1-color2` | `app1-color3` |
| **Apperance #2** | `app2-color1` | `app2-color2` | `app2-color3` |
| **Apperance #3** | `app3-color1` | `app3-color2` | `app3-color3` |

By defining six base themes (three for the general appearance and three for the color variants), you can leverage multiple theme inheritance:

- `app1-base`: the theme variants for the first general appearance theme variants with no colors.
- `app2-base`: the theme variants for the second general appearance theme variants with no colors.
- `app3-base`: the theme variants for the third general appearance theme variants with no colors.
- `color1`: the theme variants for the colors variants #1.
- `color2`: the theme variants for the colors variants #2.
- `color3`: the theme variants for the colors variants #3.

Now, you can define the theme matrix cell-by-cell using multiple inheritance:

```json
[
  {
    "id": "app1-color1",
    "name": "App1-Color1",
    "extends": ["app1-base", "color1"]
  },
  {
    "id": "app1-color2",
    "name": "App1-Color2",
    "extends": ["app1-base", "color2"]
  },
  {
    "id": "app1-color3",
    "name": "App1-Color3",
    "extends": ["app1-base", "color3"]
  },
  {
    "id": "app2-color1",
    "name": "App2-Color1",
    "extends": ["app2-base", "color1"]
  },
  {
    "id": "app2-color2",
    "name": "App2-Color2",
    "extends": ["app2-base", "color2"]
  },
  {
    "id": "app2-color3",
    "name": "App2-Color3",
    "extends": ["app2-base", "color3"]
  },
  {
    "id": "app3-color1",
    "name": "App3-Color1",
    "extends": ["app3-base", "color1"]
  },
  {
    "id": "app3-color2",
    "name": "App3-Color2",
    "extends": ["app3-base", "color2"]
  },
  {
    "id": "app3-color3",
    "name": "App3-Color3",
    "extends": ["app3-base", "color3"]
  }
]
```

Though you have nine themes, if, for some reason, you need to modify any of them, it is usually enough to change two of the base themes: one for the general appearance traits and another for colors.

Due to the multiple inheritance, you can be sure that changes in the base themes flow down to derived themes; you do not have to cope with maintaining nine separate themes.
