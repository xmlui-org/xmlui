import { Callout } from 'nextra/components';
import { COMPONENT_ITEMS, COMPONENT_LIST, COMPONENT_TABLE, THE_APP_COMPONENT } from "../../meta/pages.js";

# Working with data

Real apps consume data. XMLUI provides a straightforward way to reach data from the backend and display them in the UI. It also lets you execute actions that change backend data.

This section will teach you how to access backend APIs through XMLUI components. In addition to the data access techniques, you will learn about a few data-aware components, such as `List` and `Table`.

## The `data` property

Each component in the framework (including the built-in and reusable components ) may have a `data` property. XMLUI specially handles this property:
- First, it gets the property values; if it is an expression, it evaluates it.
- If the property value is a string, the framework handles it as a URL and fetches the data from it. The retrieved data is passed to the component when the fetch is completed.
- If the value is a `DataSource,` the framework fetches the data from that `DataSource` and passes it to the component when the fetch is completed.
- In other cases, the value is passed to the component.

As you learned, property changes trigger UI refresh, so when the `data` property's value gets the actual data, the UI is updated accordingly.

### Using `data` with Explicit Value

When you pass an explicit (non-string) value to the `data` property, the framework directly passes it to the component, which renders it.

Here is a sample demonstrating this case:

```ueml copy
<App>
  <List data="{['one', 'two', 'three']}">
    <Card title="{$item}" />
  </List>
</App>  
```

This code passes an array of strings to `data`. A `List` component displays each item in `data` according to the template described by its children. The `$item` context value in the template represents the current item to display.

<Playground
  name="Example: Explicit data"
  app={`
    <App>
      <List data="{['one', 'two', 'three']}">
        <Card title="{$item}" />
      </List>
    </App>  
  `}
  height={240}
/>

### Using `data` with a valid URL

When you pass a string value to `data`, XMLUI considers it a URL and fetches the data from it. When the fetch is complete, the UI is refreshed accordingly.

```ueml copy
<App>
  <List data="https://api.spacexdata.com/v4/launchpads">
    <Card title="{$item.name}" />
  </List>
</App>  
```

This markup uses the endpoint in `data` to fetch launchpad information from the SpaceX API.

<Playground
  name="Example: Data with a URL"
  app={`
    <App>
      <List data="https://api.spacexdata.com/v4/launchpads">
        <Card title="{$item.name}" />
      </List>
    </App>  
  `}
  height={240}
/>

### Using `data` with a non-functional URL

When you use a string value in `data` but not a valid URL or the data fetch results in an error, the `data` is set to an empty value. The following example demonstrates this case:

```ueml copy
<App var.myData="{[]}">
  <Button label="Fetch Data" onClick="myData = 'bla-bla-bla'" />
  <List data="{myData}">
    <Card title="{$item}" />
  </List>
</App>  
```

By default, the value passed to `data` is an empty list (the UI displays "No data available"); however, when you click the button that sets the `data` property to an invalid URL ("bla-bla-bla"), an error is raised while the framework fetches the data from that URL.

<Playground
  name="Example: Data with a non-functional URL"
  app={`
    <App var.myData="{[]}">
      <Button label="Fetch Data" onClick="myData = 'bla-bla-bla'" />
      <List data="{myData}">
        <Card title="{$item}" />
      </List>
    </App>  
  `}
  height={180}
/>

<Callout type="info" emoji="ðŸ“”">
When you click the button again, the value of `data` does not change (it remains "bla-bla-bla"), so the framework does not trigger the fetch again.
</Callout>

### Using `data` with a `DataSource`

You can bind the `data` property to a `DataSource` instance. Similarly to a single URL, `DataSource` fetches the data from that URL. 

```ueml copy /rocketsData/
<App>
  <DataSource id="rocketsData" url="https://api.spacexdata.com/v4/rockets" />
  <List data="{rocketsData}">
    <Card title="{$item.rocket_name}" subtitle="{$item.success_rate_pct}%" />
  </List>
</App>  
```

You can refer to the `DataSource` instance with its identifier, `rocketsData`.

<Playground
  name="Example: Using DataSource in Data"
  app={`
    <App>
      <DataSource id="rocketsData" url="https://api.spacexdata.com/v4/rockets" />
      <List data="{rocketsData}">
        <Card title="{$item.name}" subtitle="{$item.success_rate_pct}%" />
      </List>
    </App>  
  `}
  height={260}
/>

This sample has the same effect as using a URL in the `data` property. However, when you need additional configuration to issue a fetch request (for example, changing the `GET` method or adding some custom headers), `DataSource` provides that flexibility over a single string URL.

## Using `DataSource`

Though using the `data` property is extremely easy, there are situations when you need more control over the fetched data than just automatically getting it. Here are a few of them:
- You need to extract some part of the response and consider that part as the data you want to display.
- You need to transform the data from the backend before displaying it.
- You want to know that the data is being fetched to indicate that the fetch operation is in progress.
- Initiating the fetch request is more complex than issuing a GET request with the specified URL; for example, you must pass some information in the request header.  

<Callout type="info" emoji="ðŸ’¡">
  The `DataSource` component provides **more control of the fetch operation** with its methods and state information.
</Callout>

<Callout type="info" emoji="ðŸ“”">
This samples in this section use XMLUI's emulated API feature.
</Callout>

### Accessing the Data

You can use `DataSource` with any component (even if that one does not handle data natively). When the fetch is complete, the `value` property represents retrieved data.

In the following example, you use the `value` property to set the contents of `H3`:

```ueml copy /fruits.value/
<App>
  <DataSource id='fruits' url='/api/fruits'/>
  <HStack verticalAlignment="center">
  <H3>These are the {fruits.value.length} fruits:</H3>
  <Items data="{fruits}">
    <Badge value="{$item}" />
  </Items>
  </HStack>
</App>
```

<Playground
  name="Example: Use data from a DataSource"
  api={{
    initialize: `
      $state.fruits = ['apple', 'banana', 'cherry', 'pear'];
    `,
    operations: {
      'get-fruits': {
        method: 'get',
        url: '/api/fruits',
        handler: `
          return $state.fruits;
        `,
      },
    }
  }}
  app={`
    <App>
      <DataSource id='fruits' url='/api/fruits'/>
      <HStack verticalAlignment="center">
      <H3>These are the {fruits.value.length} fruits:</H3>
      <Items data="{fruits}">
        <Badge value="{$item}" />
      </Items>
      </HStack>
    </App>
  `}
  height={100}
/>

### Refreshing the data

`DataSource` exposes a method, `refetch`, which you can use imperatively to re-query the data. The following markup demonstrates using it:

```ueml copy /coords.refetch()/
<App>
  <DataSource id='coords' url='/api/coords'/>
  <Button label="Refresh" onClick="coords.refetch()" />
  <Text>Satelite position: x={coords.value.x}, y={coords.value.y}</Text>
</App>
```

<Playground
  name="Example: Refreshing data"
  api={{
    initialize: `
      $state.click = 0;
    `,
    operations: {
      'get-coords': {
        method: 'get',
        url: '/api/coords',
        handler: `
          const coords = { x: ($state.click * 1.523).toFixed(4), y: ($state.click * 2.421).toFixed(4) };
          $state.click++;
          return coords;
        `,
      },
    }
  }}
  app={`
    <App>
      <DataSource id='coords' url='/api/coords'/>
      <Button label="Refresh" onClick="coords.refetch()" />
      <Text>Satelite position: x={coords.value.x}, y={coords.value.y}</Text>
    </App>
  `}
  height={140}
/>

### Periodic Polling

`DataSource` allows you to periodically poll the backend for data. Use the `pollIntervalInSeconds` property to set this period, as the following example shows:

```ueml copy /pollIntervalInSeconds="3"/
<App var.pollCount="{0}">
  <DataSource 
    id='rand' 
    url='/api/random' 
    pollIntervalInSeconds="3" 
    onLoaded="pollCount++"/>
  <H3>Poll temperature in every 3 seconds (#{pollCount})</H3>
  <Text>Current random temperature: {rand.value}</Text>
</App>
```

Besides getting the data, this app uses the `loaded` event of `DataSource` to count the number of polls.

<Playground
  name="Example: Automatic polling"
  api={{
    initialize: `
      $state.click = 0;
    `,
    operations: {
      'get-coords-2': {
        method: 'get',
        url: '/api/random',
        handler: `
          return (Math.random() * 40 + 40).toFixed(4);
        `,
      },
    }
  }}
  app={`
    <App var.pollCount="{0}">
      <DataSource 
        id='rand' 
        url='/api/random' 
        pollIntervalInSeconds="3" 
        onLoaded="pollCount++"/>
      <H3>Poll temperature in every 3 seconds (#{pollCount})</H3>
      <Text>Current random temperature: {rand.value}</Text>
    </App>
  `}
  height={120}
/>

### In-Progress State

You can quickly determine if a data fetch operation is in progress. `DataSource` offers a property, `inProgress,` which indicates whether the data is currently being fetched. The following sample shows using this property:


```ueml copy /orders.inProgress/
<App var.pollCount="{0}">
  <DataSource id='orders' url='/api/monthly-total' />
  <Button onClick="orders.refetch()">Query #of total orders</Button>
  <Text when="{orders.inProgress}">Calculating...</Text>
  <H2 when="{!orders.inProgress}">Total Orders: {orders.value}</H2>
</App>
```

<Playground
  name="Example: Checking in-progress state"
  api={{
    initialize: `
      $state.click = 0;
    `,
    operations: {
      'get-total': {
        method: 'get',
        url: '/api/monthly-total',
        handler: `
          delay(2000);
          return Math.random() * 12000 + 800;
        `,
      },
    }
  }}
  app={`
    <App var.pollCount="{0}">
      <DataSource id='orders' url='/api/monthly-total' />
      <Button onClick="orders.refetch()">Query #of total orders</Button>
      <Text when="{orders.inProgress}">Calculating...</Text>
      <H2 when="{!orders.inProgress}">Total Orders: {orders.value}</H2>
    </App>
  `}
  height={140}
/>

### Binding Component Properties to DataSource

When you bind a `DataSource` component instance to a property, XMLUI starts the data fetch and changes the component property as soon as the retrieval has been completed.

The following sample demonstrates this scenario:

```ueml copy /orders.value.title/ /orders.value.author/
<App>
  <DataSource id='orders' url='/api/title-info' />
  <Card title="{orders.value.title}" subtitle="{orders.value.author}" />
</App>
```

<Playground
  name="Example: Binding component properties to DataSource"
  api={{
    initialize: `
      $state.click = 0;
    `,
    operations: {
      'get-titles': {
        method: 'get',
        url: '/api/title-info',
        handler: `
          return {author: "Douglas Adams", title: "Hichhiker's Guide to the Galaxy"};
        `,
      },
    }
  }}
  app={`
    <App>
      <DataSource id='orders' url='/api/title-info' />
      <Card title="{orders.value.title}" subtitle="{orders.value.author}" />
    </App>
  `}
/>

### Adding Header information

Some API endpoints may ask for a particular header. You can send it with the request using the `headers` property of `DataSource`.

In the following example, the backend requires a header named `x-api-key` with the value of `1111` to accept the request.

```ueml copy /headers="{{ 'x-api-key': '1111' }}/
<App>
  <DataSource id='orders' url='/api/title-info-header' headers="{{ 'x-api-key': '1111' }}" />
  <Card title="{orders.value.title}" subtitle="{orders.value.author}" />
</App>
```

Pop out this example in the playground and check what happens when you change or remove the `headers` property.

<Playground
  name="Example: Using Headers"
  api={{
    initialize: `
      $state.click = 0;
    `,
    operations: {
      'get-title-with-header': {
        method: 'get',
        url: '/api/title-info-header',
        handler: `
        const token = $requestHeaders['x-api-key'];
        if (token === "1111") {
          return {author: "Cixin Liu", title: "The Three-Body Problem"};
        }
        throw Errors.HttpError(400, { message: "No valid API key provided in header!" });
        `,
      },
    }
  }}
  app={`
    <App>
      <DataSource id='orders' url='/api/title-info-header' headers="{{ 'x-api-key': '1111' }}" />
      <Card title="{orders.value.title}" subtitle="{orders.value.author}" />
    </App>
  `}
/>

## Persisting Data

In contrast to fetching data, where the framework can be smart about when to initiate the data fetch operation, persisting data requires an explicit user (or system) trigger to invoke a related API endpoint.

<Callout type="info" emoji="ðŸ’¡">
  XMLUI has an **`APICall` component** that manages API endpoint invocations that persist data (or cause other state changes at the backend).
</Callout>

An `APICall` component requires a URL and an operation method (such as POST, PUT, DELETE, etc.) to do its job. It must also be configured with other details to convey the request information between the UI and the backend.

Besides managing the request-response protocol, `APICall` provides a few UI services:

- It can ask you for confirmation and cancel the operation on refusing it.
- You can check if an operation is in progress.
- It may display toast messages (if you ask so) when the operation is completed.
- You can define a toast message to show while the operation is in progress.
- Other components may ask the APICall whether it is in progress.
- You can define event handlers for handling successful/failed operations.

### Using APICall to Persist Data

The following sample demonstrates how to use `APICall` to send a request with a particular body. The sample allows you to add a new fruit to a list; you send the new fruit's name in the request body.

```ueml copy  {6-12}
<App>
  <DataSource id='myFruits' url='/api/my-fruits' />
  <HStack>
    <TextBox id="newFruit" placeholder="Enter a new fruit" width="50%" />
    <Button enabled="{newFruit.value.trim()}" label="Add">
      <event name="click">
        <APICall 
          method="post" 
          url="/api/my-fruits" 
          body="{newFruit.value}" 
          onSuccess="newFruit.setValue('')" />
      </event> 
    </Button>
  </HStack>
  <HStack wrapContent="true">
    <Items data="{myFruits}">
      <Badge value="{$item.name}"/>
    </Items>
  </HStack>
</App>
```

Observe the `onSuccess` event handler: the code deletes the textbox after completing the API call.

<Playground
  name="Example: Persisting data"
  height={240}
  api={{
    initialize: `
      $state.fruits = [{id: 1, name: 'apple'}, {id: 2, name: 'banana'}, {id: 3, name: 'cherry'}];
    `,
    operations: {
      'get-fruits-with-persist': {
        method: 'get',
        url: '/api/my-fruits',
        handler: `
          return $state.fruits;
        `,
      },
      'post-fruit': {
        method: 'post',
        url: '/api/my-fruits',
        handler: `
          $state.fruits.push({id: $state.fruits.length + 1, name: $requestBody});
        `,
      },
    }
  }}
  app={`
    <App>
      <DataSource id='myFruits' url='/api/my-fruits' />
      <HStack>
        <TextBox id="newFruit" placeholder="Enter a new fruit" width="50%" />
        <Button enabled="{newFruit.value.trim()}" label="Add">
          <event name="click">
            <APICall 
              method="post" 
              url="/api/my-fruits" 
              body="{newFruit.value}" 
              onSuccess="newFruit.setValue('')" />
          </event> 
        </Button>
      </HStack>
      <HStack wrapContent="true">
        <Items data="{myFruits}">
          <Badge value="{$item.name}"/>
        </Items>
      </HStack>
    </App>
  `}
/>

### Confirming and Notifications

`APICall` allows you to request user confirmation before issuing a particular call. The operation continues if the answer is affirmative; otherwise, it will not be sent. You can also display a notification message when the operation is completed.

The following example demonstrates these features:

```ueml copy {10, 12} /confirmTitle/ /confirmMessage/ /completedNotificationMessage/
<App>
  <List data="/api/components">
    <HStack padding="$padding-tight" verticalAlignment="center">
      <H3 width="20%">{$item.name}</H3>
      <Button label="Delete" size="xs">
        <event name="click">
          <APICall 
            url="/api/components/{$item.id}" 
            method="delete" 
            confirmTitle="Delete a Component"
            confirmMessage="Are you sure you want to remove '{$item.name}' from your list?" 
            completedNotificationMessage="{$item.name} component deleted." />
        </event>
      </Button>
    </HStack>        
  </List>
</App>
```

<Playground
  name="Example: Confirmation"
  height={320}
  api={{
    initialize: `
      $state.components = [
        {id: 1, name: 'Button'}, 
        {id: 2, name: 'Checkbox'}, 
        {id: 3, name: 'Switch'},
        {id: 4, name: 'TextBox'},
        {id: 5, name: 'RadioButton'},
        {id: 6, name: 'Slider'},
      ];
    `,
    operations: {
      'get-components': {
        method: 'get',
        url: '/api/components',
        handler: `
          return $state.components;
        `,
      },
      'post-fruit': {
        method: 'delete',
        url: '/api/components/:id',
        pathParamTypes: {
          id: "integer",
        },
        handler: `
          $state.components = $state.components.filter(c => c.id !== $pathParams.id);
        `,
      },
    }
  }}
  app={`
    <App>
      <List data="/api/components">
        <HStack padding="$padding-tight" verticalAlignment="center">
          <H3 width="20%">{$item.name}</H3>
          <Button label="Delete" size="xs">
            <event name="click">
              <APICall 
                url="/api/components/{$item.id}" 
                method="delete" 
                confirmTitle="Delete a Component"
                confirmMessage="Are you sure you want to remove '{$item.name}' from your list?" 
                completedNotificationMessage="{$item.name} component deleted." />
            </event>
          </Button>
        </HStack>        
      </List>
    </App>
  `}
/>


## Data-Aware Components

XMLUI comes with several data-aware components. In this section, you will learn about them.

### Items 

The `Items` component maps sequential data into component instances, representing each data item as a particular component.

<Callout type="info" emoji="ðŸ“”">
Learn more about this component in the <SmartLink href={COMPONENT_ITEMS}>`Items`</SmartLink> reference documentation.
</Callout>

The following sample uses the `data` property to define the source of backend data displayed in the component:

```ueml copy {3-5}
<App>
  <Items data="https://api.spacexdata.com/v3/rockets">
    <Image height="80px" width="110px" fit="cover" src="{$item.flickr_images[0]}"/>
  </Items>
</App>
```

<Playground
  name="Example: Items with data binding"
  height={300}
  app={`
  <App>
    <Items data="https://api.spacexdata.com/v3/rockets">
      <Image height="80px" width="110px" fit="cover" src="{$item.flickr_images[0]}"/>
    </Items>
  </App>
  `}
/>

The `Items` component does not use virtualization; it maps each data item into a component.
Thus, passing many items to a component instance will use many resources and slow down your app.
If you plan to work with many items (more than a few dozen), use the [`List`](./List) and [`Table`](./Table) components instead.

Items also can be used when you provide a list of options for components such as `Select`, or `Combobox`:

```ueml copy {3-5}
<App>
  <Select id="landpads">
    <Items data="https://api.spacexdata.com/v4/landpads">
      <Option label="{$item.full_name}" value="{$item.name}" />
    </Items>
  </Select>
  <Text>Selected ID: {landpads.value ?? '(none)'}</Text>
</App>
```

<Playground
  name="Example: Items with data binding"
  height={300}
  app={`
  <App>
    <Select id="landpads">
      <Items data="https://api.spacexdata.com/v4/landpads">
        <Option label="{$item.full_name}" value="{$item.name}" />
      </Items>
    </Select>
    <Text>Selected ID: {landpads.value ?? '(none)'}</Text>
  </App>
  `}
/>


### List

The `List` component is a robust layout container that renders associated data items as a list of components. `List` is virtualized; it renders only items visible in the viewport.

<Callout type="info" emoji="ðŸ“”">
Learn more about this component in the <SmartLink href={COMPONENT_LIST}>`List`</SmartLink> reference documentation.
</Callout>

The following sample demonstrates using `List`:

```ueml copy
<App>
  <List data="https://api.spacexdata.com/v4/ships">
    <HStack padding="$padding-tight">
      <Text variant="strong" width="30%">{$item.name}</Text>
      <Text width="15%">Built: {$item.year_built ?? '(unknown)'}</Text>
      <Image when="{$item.image}" height="80px" width="110px" fit="cover" src="{$item.image}"/>
      <Text when="{!$item.image}" width="*">No image available</Text>
    </HStack>
  </List>
</App>
```

<Playground
  name="Example: List with data binding"
  app={`
    <App>
      <List data="https://api.spacexdata.com/v4/ships">
        <HStack padding="$padding-tight">
          <Text variant="strong" width="30%">{$item.name}</Text>
          <Text width="15%">Built: {$item.year_built ?? '(unknown)'}</Text>
          <Image when="{$item.image}" height="80px" width="110px" fit="cover" src="{$item.image}"/>
          <Text when="{!$item.image}" width="*">No image available</Text>
        </HStack>
      </List>
    </App>  
  `}
  height={300}
/>

You can order the items on the list with its `orderBy` property, which names a field and a sorting direction. Observe how the following sample uses a `DataSource` and maps the result into a new data array to create the `launchCount` field:

```ueml copy /orderBy="{{ field: 'launchCount', direction: 'desc' }}"/
<App>
  <DataSource id="shipsData" url="https://api.spacexdata.com/v4/ships" />
  <List 
    data="{shipsData.value.map(s => ({...s, launchCount: s.launches.length ?? 0}))}"
    orderBy="{{ field: 'launchCount', direction: 'desc' }}">
    <HStack padding="$padding-tight">
      <Text variant="strong" width="30%">{$item.name}</Text>
      <Text width="15%">Launches: {$item.launchCount}</Text>
      <Image when="{$item.image}" height="80px" width="110px" fit="cover" src="{$item.image}"/>
      <Text when="{!$item.image}" width="*">No image available</Text>
    </HStack>
  </List>
</App>  
```

As you expect, the list displays ships in descending order by the number of their launches.

<Playground
  name="Example: List with data binding"
  app={`
    <App>
      <DataSource id="shipsData" url="https://api.spacexdata.com/v4/ships" />
      <List 
        data="{shipsData.value.map(s => ({...s, launchCount: s.launches.length ?? 0}))}"
        orderBy="{{ field: 'launchCount', direction: 'desc' }}">
        <HStack padding="$padding-tight">
          <Text variant="strong" width="30%">{$item.name}</Text>
          <Text width="15%">Launches: {$item.launchCount}</Text>
          <Image when="{$item.image}" height="80px" width="110px" fit="cover" src="{$item.image}"/>
          <Text when="{!$item.image}" width="*">No image available</Text>
        </HStack>
      </List>
    </App>  
  `}
  height={300}
/>

As the following sample demonstrates, a `List` can group its items according to a particular field. You can optionally define a section header and footer for the list.

```ueml copy {10-12} /sectionBy="type"/
<App>
  <List data="https://api.spacexdata.com/v4/ships"
    sectionBy="type">
    <HStack padding="$padding-tight">
      <Text variant="strong" width="30%">{$item.name}</Text>
      <Text width="15%">Type: {$item.type}</Text>
      <Image when="{$item.image}" height="80px" width="110px" fit="cover" src="{$item.image}"/>
      <Text when="{!$item.image}" width="*">No image available</Text>
    </HStack>
    <property name="sectionTemplate">
      <Card title="{$item.sectionKey}" />
    </property>
  </List>
</App>  
```

<Playground
  name="Example: List with data grouping"
  app={`
    <App>
      <List data="https://api.spacexdata.com/v4/ships"
        sectionBy="type">
        <HStack padding="$padding-tight">
          <Text variant="strong" width="30%">{$item.name}</Text>
          <Text width="15%">Type: {$item.type}</Text>
          <Image when="{$item.image}" height="80px" width="110px" fit="cover" src="{$item.image}"/>
          <Text when="{!$item.image}" width="*">No image available</Text>
        </HStack>
        <property name="sectionTemplate">
          <Card title="{$item.sectionKey}" />
        </property>
      </List>
    </App>  
  `}
  height={300}
/>

### Table

`Table` is a component that displays cells organized into rows and columns. The `Table` component is virtualized so it only renders visible cells.

<Callout type="info" emoji="ðŸ“”">
Learn more about this component in the <SmartLink href={COMPONENT_TABLE}>`Table`</SmartLink> reference documentation.
</Callout>

The following sample demonstrates using `Table`. You can use `Column` components to specify table column templates.

```ueml copy
<App>
  <Table data="https://api.spacexdata.com/v4/rockets">
    <Column header="Image" width="100">
      <Image height="80px" width="110px" fit="cover" src="{$item.flickr_images[0]}"/>
    </Column>
    <Column header="Name" bindTo="name" width="110">
      <Text variant="strong">{$item.name}</Text>
    </Column>
    <Column header="Description" bindTo="description" width="*">
      <Text maxLines="5">{$item.description}</Text>
    </Column>
  </Table>
</App>  
```

<Playground
  name="Example: Table"
  app={`
    <App>
      <Table data="https://api.spacexdata.com/v4/rockets">
        <Column header="Image" width="100">
          <Image height="80px" width="110px" fit="cover" src="{$item.flickr_images[0]}"/>
        </Column>
        <Column header="Name" bindTo="name" width="110">
          <Text variant="strong">{$item.name}</Text>
        </Column>
        <Column header="Description" bindTo="description" width="*">
          <Text maxLines="5">{$item.description}</Text>
        </Column>
      </Table>
    </App>  
  `}
  height={300}
/>
