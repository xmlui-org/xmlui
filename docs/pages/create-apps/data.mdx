import { Callout } from 'nextra/components';
import { THE_APP_COMPONENT } from "../../meta/pages.js";

# Working with data

Real apps consume data. XMLUI provides a straightforward way to reach data from the backend and display them in the UI. It also lets you execute actions that change backend data.

This section will teach you how to access backend APIs through XMLUI components. In addition to the data access techniques, you will learn about a few data-aware components, such as `List` and `Table`.

## The `data` property

Each component in the framework (including the built-in and reusable components ) may have a `data` property. XMLUI specially handles this property:
- First, it gets the property values; if it is an expression, it evaluates it.
- If the property value is a string, the framework handles it as a URL and fetches the data from it. The retrieved data is passed to the component when the fetch is completed.
- If the value is a `DataSource,` the framework fetches the data from that `DataSource` and passes it to the component when the fetch is completed.
- In other cases, the value is passed to the component.

As you learned, property changes trigger UI refresh, so when the `data` property's value gets the actual data, the UI is updated accordingly.

### Using `data` with Explicit Value

When you pass an explicit (non-string) value to the `data` property, the framework directly passes it to the component, which renders it.

Here is a sample demonstrating this case:

```ueml copy
<App>
  <List data="{['one', 'two', 'three']}">
    <Card title="{$item}" />
  </List>
</App>  
```

This code passes an array of strings to `data`. A `List` component displays each item in `data` according to the template described by its children. The `$item` context value in the template represents the current item to display.

<Playground
  previewOnly
  name="Example: Explicit data"
  app={`
    <App>
      <List data="{['one', 'two', 'three']}">
        <Card title="{$item}" />
      </List>
    </App>  
  `}
  height={240}
/>

### Using `data` with a valid URL

When you pass a string value to `data`, XMLUI considers it a URL and fetches the data from it. When the fetch is complete, the UI is refreshed accordingly.

```ueml copy
<App>
  <List data="https://api.spacexdata.com/v4/launchpads">
    <Card title="{$item.name}" />
  </List>
</App>  
```

This markup uses the endpoint in `data` to fetch launchpad information from the SpaceX API.

<Playground
  previewOnly
  name="Example: Data with a URL"
  app={`
    <App>
      <List data="https://api.spacexdata.com/v4/launchpads">
        <Card title="{$item.name}" />
      </List>
    </App>  
  `}
  height={240}
/>

### Using `data` with a non-functional URL

When you use a string value in `data` but not a valid URL or the data fetch results in an error, the `data` is set to an empty value. The following example demonstrates this case:

```ueml copy
<App var.myData="{[]}">
  <Button label="Fetch Data" onClick="myData = 'bla-bla-bla'" />
  <List data="{myData}">
    <Card title="{$item}" />
  </List>
</App>  
```

By default, the value passed to `data` is an empty list (the UI displays "No data available"); however, when you click the button that sets the `data` property to an invalid URL ("bla-bla-bla"), an error is raised while the framework fetches the data from that URL.

<Playground
  previewOnly
  name="Example: Data with a non-functional URL"
  app={`
    <App var.myData="{[]}">
      <Button label="Fetch Data" onClick="myData = 'bla-bla-bla'" />
      <List data="{myData}">
        <Card title="{$item}" />
      </List>
    </App>  
  `}
  height={180}
/>

<Callout type="info" emoji="ðŸ“”">
When you click the button again, the value of `data` does not change (it remains "bla-bla-bla"), so the framework does not trigger the fetch again.
</Callout>

### Using `data` with a `DataSource`

You can bind the `data` property to a `DataSource` instance. Similarly to a single URL, `DataSource` fetches the data from that URL. 

```ueml copy /rocketsData/
<App>
  <DataSource id="rocketsData" url="https://api.spacexdata.com/v4/rockets" />
  <List data="{rocketsData}">
    <Card title="{$item.rocket_name}" subtitle="{$item.success_rate_pct}%" />
  </List>
</App>  
```

You can refer to the `DataSource` instance with its identifier, `rocketsData`.

<Playground
  previewOnly
  name="Example: Using DataSource in Data"
  app={`
    <App>
      <DataSource id="rocketsData" url="https://api.spacexdata.com/v4/rockets" />
      <List data="{rocketsData}">
        <Card title="{$item.name}" subtitle="{$item.success_rate_pct}%" />
      </List>
    </App>  
  `}
  height={260}
/>

This sample has the same effect as using a URL in the `data` property. However, when you need additional configuration to issue a fetch request (for example, changing the `GET` method or adding some custom headers), `DataSource` provides that flexibility over a single string URL.

## Using `DataSource`

Though using the `data` property is extremely easy, there are situations when you need more control over the fetched data than just automatically getting it. Here are a few of them:
- You need to extract some part of the response and consider that part as the data you want to display.
- You need to transform the data from the backend before displaying it.
- You want to know that the data is being fetched to indicate that the fetch operation is in progress.
- Initiating the fetch request is more complex than issuing a GET request with the specified URL; for example, you must pass some information in the request header.  

<Callout type="info" emoji="ðŸ’¡">
  The `DataSource` component provides **more control of the fetch operation** with its methods and state information.
</Callout>

### Accessing the Data

You can use `DataSource` with any component that does not handle data natively. The `value` property represents retrieved data when the fetch is complete.

_TBD_

### Refreshing the data

`DataSource` exposes a method, `refetch`, which you can use imperatively to re-query the data. The following markup demonstrates using it:

_TBD_ 

### In-Progress State

You can quickly determine if a data fetch operation is in progress. `DataSource` offers a property, `inProgress,` which indicates whether the data is currently being fetched. The following sample shows using this property:

_TBD_

### Binding Component Properties to DataSource

When you bind a `DataSource` component instance to a property, XMLUI starts the data fetch and changes the component property as soon as the retrieval has been completed.

The following sample demonstrates this scenario:

_TBD_

## Persisting Data

In contrast to fetching data, where the framework can be smart about when to initiate the data fetch operation, persisting data requires an explicit user (or system) trigger to invoke a related API endpoint.

<Callout type="info" emoji="ðŸ’¡">
  XMLUI has an **`APICall` component** that manages API endpoint invocations that persist data (or cause other state changes at the backend).
</Callout>

An `APICall` component requires a URL and an operation method (such as POST, PUT, DELETE, etc.) to do its job. It must also be configured with other details to convey the request information between the UI and the backend.

Besides managing the request-response protocol, `APICall` provides a few UI services:

- It can ask you for confirmation and cancel the operation on refusing it.
- You can check if an operation is in progress.
- It may display toast messages (if you ask so) when the operation is completed.
- You can define a toast message to show while the operation is in progress.
- Other components may ask the APICall whether it is in progress.
- You can define event handlers for handling successful/failed operations.

_TODO: Add examples of APICall usage when API interceptor can be used with the documentation platform._