import { Callout } from 'nextra/components';

# Working with Text

<Callout type="warning" emoji="⚠️">
  This article is about to be reviewed.
</Callout>

Text elements are frequently used in most apps as a part of the UI:
in menu items, titles, headings, labels, descriptions, etc.
This article treats the nitty-gritty details of working with text components.

## Implicit and Explicit Text

The engine makes it easy to use text.
When you nest text in any component that renders its children (such as layout containers and many others), the engine converts them to a body of text:

```ueml copy {2, 4}
<App>
  This is a text!
  <Button label="I'm just a button" />
  This is another text!
</App>
```

<Playground
  previewOnly
  name="Implicit text"
  horizontal
  app={`
    <App>
      This is a text!
      Another line
      <Button label="I'm just a button" />
      This is another text!
    </App>
  `}
/>

This "implicit" text is often unsuitable for a particular context, as you intend to modify the appearance of the text or attach events to it.
In this case, you can use the `Text` component to handle such customization.
The following example shows how you can use `Text`:

```ueml copy {2, 4}
<App>
  <Text fontSize="1.5rem" color="purple">This is a text!</Text>
  <Button label="I'm just a button" />
  <Text backgroundColor="green">This is another text!</Text>
</App>
```

<Playground
  previewOnly
  name="Explicit text"
  horizontal
  app={`
    <App>
      <Text fontSize="1.5rem" color="purple">This is a text!</Text>
      <Button label="I'm just a button" />
      <Text backgroundColor="green">This is another text!</Text>
    </App>
  `}
/>

Besides the `Text` component, other components rendering text do so with custom formatting.
For example, the heading family of components (`Heading`, `H1`, `H2`, ..., and `H6`) display the text as headings:

```ueml copy {2, 4}
<App>
  <H1>My Main Title</H1>
  This document contains several sections.
  <H2>Section Title</H2>
</App>
```

<Playground
  previewOnly
  name="Explicit text with Headings"
  horizontal
  app={`
    <App>
      <H1>My Main Title</H1>
      This document contains several sections.
      <H2>Section Title</H2>
    </App>
  `}
/>

## Specifying Text Content

Components displaying text offer two ways to set the content to display:

- **Using a component property.** You can set the value of this property to tell the component what to display.
- **Nested text**. You nest the text to display in the component.

> **Note**: All the examples shown earlier in this article used the nested text approach.

In the following example, all text-related components use their corresponding property to set their text:

```ueml copy {2, 3}
<App>
  <H2 value="Text Content with Properties" />
  <Text value="This text is set in the 'value' property of 'Text'." />
</App>
```

<Playground
  previewOnly
  name="Using Properties for Text Contents"
  horizontal
  app={`
    <App>
      <H2 value="Text Content with Properties" />
      <Text value="This text is set in the 'value' property of 'Text'." />
    </App>
  `}
/>

There is a significant difference between the two ways you can define text:

- The nested text uses HTML whitespace collapsing.
- The `value` property ignores HTML whitespace collapsing.

> **Note**: If you add extra or consecutive white spaces or newlines to the code, HTML will regard it as one white space.
> This feature is known as HTML whitespace collapsing.

Whitespace collapsing is a helpful feature. The following code shows how this feature combines text into one continuous text that is broken into multiple lines (this ensures better readability):

```ueml copy
<App>
  This is a long text broken into multiple lines

  to demonstrate HTML whitespace collapsing.  The

  source markup would be challenging to read if

  the entire text were specified in a single line.

  Breaking into lines helps this situation, and the

  text renders neatly.
</App>
```

<Playground
    previewOnly
    name="HTML Whitespace Collapsing"
    horizontal
    app={`
    <App>
     This is a long text broken into multiple lines

     to demonstrate HTML whitespace collapsing.  The

     source markup would be challenging to read if

     the entire text were specified in a single line.

     Breaking into lines helps this situation, and the

     text renders neatly.
    </App>
  `}
/>

The following sample demonstrates the differences between the two ways of specifying text content:

```ueml copy
<App>
  <H3 value="       Text with a lot   of   spaces (property)    "></H3>
  <H3>     Text with a lot   of
     spaces (nested)
  </H3>
</App>
```

<Playground
  previewOnly
  name="Properties versus Nested text"
  horizontal
  app={`
    <App>
      <H3 value="       Text with a lot   of   spaces (property)    "></H3>
      <H3>  Text with a lot   of   spaces (nested)  </H3>
    </App>
  `}
/>

## Using Binding Expressions

You can utilize binding expressions to define text content, like in the following example:

```ueml copy
<App>
  <var name="myValue"
    value="    Text   with   spaces to show   seconds: { getDate().getSeconds() }"/>
  <H3 value="{myValue}" />
  <H3>{myValue}</H3>
</App>
```

<Playground
  previewOnly
  name="Vertical Stack (by default)"
  horizontal
  app={`
    <App>
      <var name="myValue" 
        value="    Text   with   spaces to show   seconds: { getDate().getSeconds() }"/>
      <H3 value="{myValue}" />
      <H3>{myValue}</H3>
    </App>
  `}
/>

You can use binding expressions in property values and nested content like text literals. They handle whitespace collapsing the same way as if you used text literals.

> **Note**: You can click the **Reset** button to load the app again.
> You can observe that the `getDate().getSeconds()` expression is evaluated at every load.

## Inline and Block Rendering

When you render text, it accommodates the current layout context.
If that context uses inline rendering, the text is rendered inline; otherwise, it renders as a block.

In the following sample, `HStack` uses an inline context, so the text segments render in a line:

```ueml copy
<App>
  <HStack>
    Show me a trash
    <Icon name="trash"/>
    icon!
  </HStack>
</App>
```

<Playground
  previewOnly
  name="Text Rendering in Inline Context"
  horizontal
  app={`
    <App>
      <HStack>
        Show me a trash
        <Icon name="trash"/>
        icon!
      </HStack>
    </App>
  `}
/>

In the following sample, `VStack` uses a block context.
So, the engine renders the text segments as blocks in new lines:

```ueml copy
<App>
  <VStack>
    Show me a trash
    <Icon name="trash"/>
    icon!
  </VStack>
</App>
```

<Playground
  previewOnly
  name="Text Rendering in Block Context"
  horizontal
  app={`
    <App>
      <VStack>
        Show me a trash
        <Icon name="trash"/>
        icon!
      </VStack>
    </App>
  `}
/>

## Non-Breakable Spaces

You can use the `&nbsp;` character entity declaration to specify non-breakable spaces within a text.
They behave the same way as the `&nbsp;` HTML entity.

```ueml copy
<App>
  <H2>Here are four non-breakable spaces between square brackets: [&nbsp;&nbsp;&nbsp;&nbsp;]</H2>
</App>
```

<Playground
  previewOnly
  name="Rendering Non-Breakable Spaces"
  horizontal
  app={`
    <App>
      <H2>Here are four non-breakable spaces between square brackets: [&nbsp;&nbsp;&nbsp;&nbsp;]</H2>
    </App>
  `}
/>

## Working with Long Text

Everything works intuitively when the text fits in its container (a single line).
However, with long text, you need to control how that text is broken into new lines (if at all) and how to handle overflows.

By default, a long text breaks into multiple lines (understanding word boundaries):

```ueml copy
<App>
  <Text width="200" backgroundColor="olive">
    This long text does not fit into a width constraint of 200 pixels.
  </Text>
</App>
```

<Playground
  previewOnly
  name="Example: Rendering Long Text #1"
  horizontal
  app={`
    <App>
      <Text width="200" backgroundColor="goldenrod">
        This long text does not fit into a width constraint of 200 pixels.
      </Text>
    </App>
  `}
/>

With very long words, where word boundaries do not work, the text is broken within a word:

```ueml copy
<App>
  <Text width="200" backgroundColor="goldenrod">
    ThisLongTextDoesNotFitInTheGivenContrants of a 200 pixel width (and long words).
  </Text>
</App>
```

<Playground
  previewOnly
  name="Example: Rendering Long Text #2"
  horizontal
  app={`
    <App>
      <Text width="200" backgroundColor="goldenrod">
        ThisLongTextDoesNotFitInTheGivenContrants of a 200 pixel width (and long words).
      </Text>
    </App>
  `}
/>

### Disable Breaking the Text

You can set the `maxLines` property of a `Text` component to **1** to avoid breaking it into multiple lines.
If the text does not fit into a single line its ending will be cropped and the cropping is indicated by ellipses:

```ueml copy {5}
<App>
  <Text 
    width="200" 
    backgroundColor="goldenrod"
    maxLines="1">
    Though this long text does not fit into a single line, please do not break it!
  </Text>
</App>
```

<Playground
  previewOnly
  name="Example: Avoid Breaking Long Text"
  horizontal
  app={`
    <App>
      <Text 
        width="200" 
        backgroundColor="goldenrod"
        maxLines="1">
        Though this long text does not fit into a single line, please do not break it!
      </Text>
    </App>
  `}
/>

If you do want to hide the ellipses, set the `ellipses` property to `false`:

```ueml copy {6}
<App>
  <Text 
    width="200" 
    backgroundColor="goldenrod"
    maxLines="1"
    ellipses="false">
    Though this long text does not fit into a single line, please do not break it!
  </Text>
</App>
```

<Playground
  previewOnly
  name="Example: No Ellipses"
  horizontal
  app={`
    <App>
      <Text 
        width="200" 
        backgroundColor="goldenrod"
        maxLines="1"
        ellipses="false">
        Though this long text does not fit into a single line, please do not break it!
      </Text>
    </App>
  `}
/>

### Limiting the Rendered Lines

Use the `maxLines` property to set the maximum number of lines when displaying long text.
If the text fits into the allowed range, it is fully rendered.
Otherwise, it will be cropped at the maximum specified. For example, the following sample allows up to two lines:

```ueml copy {2}
<App>
  <Text
    width="200"
    backgroundColor="goldenrod"
    maxLines="2">
    This long text does not fit into a width constraint of 200 pixels, even with two lines.
  </Text>
</App>
```

<Playground
  previewOnly
  name="Example: Limiting the Number of Lines"
  horizontal
  app={`
    <App>
      <Text
        width="200"
        backgroundColor="goldenrod"
        maxLines="2">
        This long text does not fit into a width constraint of 200 pixels, even with two lines.
      </Text>
    </App>
  `}
/>

> **Note**: Remember, you can use the `ellipses` prop to remove the ellipses from the end of the cropped text.

### Preserving Linebreaks

Occasionally, you need to preserve linebreaks within a text.
You can set the `preserveLinebreaks` property to `true` to achieve this behavior:

```ueml copy {4}
<App>
  <Text
    backgroundColor="goldenrod"
    preserveLinebreaks="true"
    value="(preserve) This long text
with several line breaks
        does not fit into its container." />
  <Text
    backgroundColor="goldenrod"
    value="(do not preserve) This long text
with several line breaks
        does not fit into its container." />
</App>
```
Observe the effect of using `preserveLinebreaks`:

<Playground
    previewOnly
    name="Example: Preserve Linebreaks"
    horizontal
    app={`
    <App>
      <Text
        backgroundColor="goldenrod"
        preserveLinebreaks="true"
        value="(preserve) This long text
    with several line breaks
            does not fit into its container." />
      <Text
        backgroundColor="goldenrod"
        value="(do not preserve) This long text
    with several line breaks
            does not fit into its container." />
    </App>
  `}
/>

> **Note**: Remember to use the `value` property of `Text`.
> Linebreaks are converted to spaces when nesting the text into the `Text` component.

## Working with Overflowing Text

In the previous sections, the text was its own container.
Most containers (e.g., `Stack`) automatically grow in size (like in height) to embed the entire text.
However, when the container width and height are constrained, it cannot accommodate the entire text.

The following example tries to contain a long text into a 200x60 pixel box:

```ueml copy
<App>
  <VStack width="200" height="60" backgroundColor="goldenrod" >
    <Text>
      As its container width and height are fixed, this long text does not
      fit into it; it will overflow.
    </Text>
  </VStack>
</App>
```

The text does not fit, and it overflows its container.
This behavior is not a design flaw or a bug; it is intentional.
By perceiving the overflow, you can decide how to handle it.

<Playground
  previewOnly
  name="Example: Text Overflow"
  horizontal
  app={`
    <App>
      <VStack width="200" height="60" backgroundColor="goldenrod" >
        <Text>
          As its container width and height are fixed, this long text does not
          fit into it; it will overflow.
        </Text>
      </VStack>
    </App>
  `}
/>

### Hiding the Overflown Text

The `verticalOverflow` layout property of container component allows for defining their behavior in case of overflow.
By default, this value is set to `visible`, so the container displays the overflown text.

By setting its value to `hidden`, the container crops the overflown part of the text.
Observe in the sample below, not the text, but how the `verticalOverflow` property of the container is set:

```ueml copy {3}
<App>
  <VStack
    verticalOverflow="hidden"
    width="200" height="60" backgroundColor="goldenrod">
    <Text>
      As its container width and height are fixed, this long text does not
      fit into it; it will overflow.
    </Text>
  </VStack>
</App>
```

<Playground
  previewOnly
  name="Example: Hiding Text Overflow"
  horizontal
  app={`
    <App>
      <VStack
        verticalOverflow="hidden"
        width="200" height="60" backgroundColor="goldenrod">
        <Text>
          As its container width and height are fixed, this long text does not
          fit into it; it will overflow.
        </Text>
      </VStack>
    </App>
  `}
/>

### Scrolling the Text

You can set `verticalOverflow` to `scroll`.
In this case, the container will display a vertical scrollbar to reach the non-visible parts of the overflowing text:

```ueml copy {2}
<App>
  <VStack 
    verticalOverflow="scroll"
    width="200" height="60" backgroundColor="goldenrod">
    <Text>
      As its container width and height are fixed, this long text does not
      fit into it; it will overflow.
    </Text>
  </VStack>
</App>
```

<Playground
  previewOnly
  name="Example: Scrolling the Text"
  horizontal
  app={`
    <App>
      <VStack 
        verticalOverflow="scroll"
        width="200" height="60" backgroundColor="goldenrod">
        <Text>
          As its container width and height are fixed, this long text does not
          fit into it; it will overflow.
        </Text>
      </VStack>
    </App>
  `}
/>

### Overflowing Dimensions

The text accommodates the available space of the container.
However, you can change this behavior by setting the text dimensions to be bigger than the container:

```ueml copy {4}
<App>
  <VStack height="40" width="300" backgroundColor="goldenrod">
    <Text
      width="400"
      backgroundColor="silver" opacity="0.7">
      This text sets its size explicitly bigger than its container.
      As it does not fit into the space provided by its container - thus it overflows.
    </Text>
  </VStack>
</App>
```

Behind the semi-transparent background of the text, you can see its container in a blueish shade:

<Playground
  previewOnly
  name="Example: Explicit Text Dimensions"
  horizontal
  app={`
    <App>
      <VStack height="40" width="300" backgroundColor="goldenrod">
        <Text
          width="400"
          backgroundColor="silver" opacity="0.7">
          This text sets its size explicitly bigger than its container.
          As it does not fit into the space provided by its container - thus it overflows.
        </Text>
      </VStack>
    </App>
  `}
/>

### Horizontal Scrolling

Besides `verticalOverflow`, XMLUI containers provide another layout property, `horizontalOverflow`, which has the same values (`visible`, `hidden`, `scroll`).
The following sample allows horizontal scrolling:

```ueml copy
<App>
  <VStack
    horizontalOverflow="scroll"
    height="60" width="300" backgroundColor="goldenrod">
    <Text width="400" backgroundColor="silver" opacity="0.7">
      This text sets its size explicitly bigger than its container. 
      As it does not fit into the container, it overflows.
      However, its container supports horizontal scrolling so you can 
      see its content.
    </Text>
  </VStack>
</App>
```
> **Note**: When you set `horizontalOverflow` to `scroll,` it will automatically set `verticalOverflow` to `scroll` if the text exceeds its container vertically.

<Playground
  previewOnly
  name="Example: Scrolling the Text Horizontally"
  horizontal
  app={`
    <App>
      <VStack
        horizontalOverflow="scroll"
        height="60" width="300" backgroundColor="goldenrod">
        <Text width="400" backgroundColor="silver" opacity="0.7">
          This text sets its size explicitly bigger than its container. 
          As it does not fit into the container, it overflows.
          However, its container supports horizontal scrolling so you can 
          see its content.
        </Text>
      </VStack>
    </App>
`}
/>
