import { COMMON_VISUAL_PROPERTY_UNITS, COMMON_VISUAL_PROPERTY_UNITS_SIZE, LAYOUT_PROPERTIES, LAYOUT_PROPERTIES_COMPONENT_WIDTH_HEIGHT, REUSABLE_COMPONENTS, THEME_VARIABLES_SPACING_IN_LAYOUT_CONTAINERS } from "../../meta/pages";
import { Callout } from 'nextra/components';

# Layout

<Callout type="warning" emoji="âš ï¸">
  This article is about to be reviewed.
</Callout>

An XMLUI app is a **hierarchical component tree** where parent components nest their children. While displaying children, each component arranges them with a particular strategy. For example, it puts children from in the same row horizontally, providing some gap among them.

Some components' only role is to arrange their nested children in a particular layout. We call them **layout components**. They can nest other layout components in arbitrary depths. This arrangement allows the creation of complex app and component layouts.

In this article, you will learn the basics of the XMLUI layout system and get acquainted with the fundamental layout components. 

## Layout Terminology

We use a few terms to help us understand the topics quickly when discussing layout.

### Viewport

<Callout type="info" emoji="ðŸ’¡">
Each component has a rectangular UI patch for rendering its content (and nested children). **This is the component's viewport**. The component decides (according to its rendering strategy) how it places its contents into the viewport. It may fill that partially, stretch the content for the entire viewport, or even overflow it vertically and horizontally.
</Callout>

The following app contains two components, an `App`, and a `Text`:

```ueml copy
<App>
  <Text>Hello from XMLUI</Text>
</App>
```

<Playground
  previewOnly={true}
  name="Component viewports"
  height={108}
  horizontal={true}
  app={`
    <App border="2px dotted red">
      <Text border="2px dotted green">Hello from XMLUI</Text>
    </App>
  `}
/>

The borders mark the viewport boundaries of the components:

- `App`: The dotted red border is the app's viewport boundary. An `App` has the entire browser window as its viewport; however, it reserves some space to the left and right for scrollbars (to avoid viewport resizing when a vertical scrollbar appears or gets removed).
- `Text`: The dotted green border is the text's viewport boundary. Its parent, `App`, uses some padding around its children.

### Orientation

<Callout type="info" emoji="ðŸ’¡">
When rendering its children, a component may render them with vertical or horizontal orientation. 
</Callout>

- Vertical orientation: Each child enters a new row when its parent displays it.
- Horizontal orientation: Each child gets to the same row as its previous sibling. The component can decide when to enter a child component into a new row. For example, when the child does not fit into the remaining part of the row, the parent may enter it into a new row.

`App` uses vertical orientation, while `HStack` (horizontal stack) applies horizontal orientation.

```ueml copy
<App>
  <Text>First item</Text>
  <HStack>
    <Text>Second item</Text>
    <Text>Third item</Text>
    <Text>Fourth item</Text>
  </HStack>
  <Text>Fifth item</Text>
</App>
```

<Playground
  previewOnly={true}
  name="Orientation"
  height={160}
  horizontal={true}
  app={`
    <App>
      <Text>First item</Text>
      <HStack>
        <Text>Second item</Text>
        <Text>Third item</Text>
        <Text>Fourth item</Text>
      </HStack>
      <Text>Fifth item</Text>
    </App>
  `}
/>

### Direction

<Callout type="info" emoji="ðŸ’¡">
Some languages (such as Hebrew and Arabic) are read from right to left. XMLUI components use this information to change their children's rendering direction.
</Callout>

This example shows what happens when the browser uses right-to-left direction:

```ueml copy /direction="rtl"/
<App direction="rtl">
  <Text>First item</Text>
  <HStack>
    <Text>Second item</Text>
    <Text>Third item</Text>
    <Text>Fourth item</Text>
  </HStack>
  <Text>Fifth item</Text>
</App>
```

<Playground
  previewOnly={true}
  name="Right-to-left direction"
  height={160}
  horizontal={true}
  app={`
    <App direction="rtl">
      <Text>First item</Text>
      <HStack>
        <Text>Second item</Text>
        <Text>Third item</Text>
        <Text>Fourth item</Text>
      </HStack>
      <Text>Fifth item</Text>
    </App>
  `}
/>

### Paddings and Gaps

<Callout type="info" emoji="ðŸ’¡">
Each component may apply padding and constrain the viewport its children can use. They can also add gaps between adjacent children. 
</Callout>

The following sample demonstrates it:

```ueml copy
<App>
  <Text>First item</Text>
  <HStack>
    <Text>Second item</Text>
    <Text>Third item</Text>
    <Text>Fourth item</Text>
  </HStack>
  <Text>Fifth item</Text>
</App>
```

<Playground
  previewOnly={true}
  name="Paddings and gaps"
  height={200}
  horizontal={true}
  app={`
    <App border="2px dotted red">
      <Text border="2px dotted green">First item</Text>
      <HStack border="2px dotted green">
        <Text border="2px dotted purple">Second item</Text>
        <Text border="2px dotted purple">Third item</Text>
        <Text border="2px dotted purple">Fourth item</Text>
      </HStack>
      <Text border="2px dotted green">Fifth item</Text>
    </App>
  `}
/>

- `App` applies vertical and horizontal padding, which is why the top left corner of the red border and the green border do not meet. It also adds gaps, which are the spaces between the green border areas.
- `HStack` uses zero paddings; thus, the top-left corner of its green border and the first item's top-left corner (the purple border) meet. Similarly to `App`, `HStack` adds gaps, which are the spaces between the purple border areas.

### Margins

<Callout type="info" emoji="ðŸ’¡">
Most web and desktop UI frameworks use another concept of spacing  (margins) when establishing the layout. **XMLUI layout components do not use margins**; they only use paddings and gaps.
</Callout>

<Callout type="warning" emoji="ðŸ’¡">
Using both margins and paddings complicates layout arrangements due to side effects (such as margin collapse applied by HTML). Though you can use margins when creating your components, use them as a last resort. For most layouts, paddings must be enough.
</Callout>

### Dimensions

<Callout type="info" emoji="ðŸ’¡">
Each component has a strategy for determining its contents' dimensions (height and width). You can change the component dimensions if this default strategy is unsuitable for your particular layout.
</Callout>

By default, the VStack component determines its dimensions according to its content. However, if we want to display a 40px high and 60px wide orange-red box with empty content, we must explicitly set dimensions (and background color), as the default strategy won't work.

```ueml copy
<App>
  <VStack height="40px" width="60px" backgroundColor="orangered" />
</App>
```

<Playground
  previewOnly={true}
  name="Dimensions"
  height={100}
  horizontal={true}
  app={`
    <App>
      <VStack height="40px" width="60px" backgroundColor="orangered" />
    </App>
  `}
/>

### Alignment

<Callout type="info" emoji="ðŸ’¡">
Components can align their children in the viewport both vertically and horizontally.
</Callout>

The following sample demonstrates it:

<Playground
  previewOnly={true}
  name="Alignment"
  height={260}
  horizontal={true}
  app={`
    <App>
      <HStack>
        <VStack width="50%" border="2px dotted red" height="200" horizontalAlignment="end">
          <Text>Item #1</Text>
          <Text>Item #2</Text>
          <Text>Item #3</Text>
        </VStack>
        <VStack width="50%" border="2px dotted green" height="200" verticalAlignment="center">
          <Text>Item #1</Text>
          <Text>Item #2</Text>
          <Text>Item #3</Text>
        </VStack>
      </HStack>
    </App>
  `}
/>

The component with the red border aligns its children vertically to the start and horizontally to the end. The green-bordered component aligns its children vertically to the center and horizontally to the start.

<Callout type="info" emoji="ðŸ“”">
Later in this article, you will learn how to establish the markup for such a layout.
</Callout>

## Fundamental Layout Containers

XMLUI uses only two fundamental layout containers, `Stack`, and `FlowLayout`. All other container-like components (such as `Card`, `List`, and others) apply these to establish more sophisticated layout arrangements.

`Stack` is a layout container that uses a particular orientation (vertical or horizontal) to render its children in a single column or row. If the children do not fit into the viewport, they overflow. `Stack` has two specialized variants, `HStack` (horizontal stack) and `VStack` (vertical stack), the orientation of which is suggested by their names.

`FlowLayout` is a layout container that renders its children horizontally while they fit into the current row; otherwise, the child enters a new row. If the children do not fit into the viewport, they overflow.

<Callout type="info" emoji="ðŸ“”">
Your application markup must have a single root component. The browser window is an implicit `VStack` layout container with that root element as its single child. 
</Callout>

### Dimension Units

Layout containers use a particular strategy to render their child components; they calculate their children's dimensions. Sometimes, you want to set a child's dimensions explicitly (not about the content of the particular child). You can set one or more of these component properties to set a particular <SmartLink href={LAYOUT_PROPERTIES_COMPONENT_WIDTH_HEIGHT}>dimension</SmartLink>: `width`, `height`, `minWidth`, `minHeight`, `maxWidth`, and `maxHeight`.

A child can declare one of these kind of <SmartLink href={COMMON_VISUAL_PROPERTY_UNITS_SIZE}>values</SmartLink> for a specific dimension:

- **No value**. The layout container determines the default size of the child element according to its strategy.
- **Container-independent size value**. All sizes except percentage (`%`) and star sizes (`*`) belong to this category. The container respects the child's requested size.
- **Percentage size**. The container calculates the child's requested size as a percentage of the viewport's corresponding dimension.
- **Star size**. The child provides a weight the parent container utilizes when distributing the _remaining space_ among its children. The remaining space is the parent viewport's size minus the sum sizes of child components within the first two categories (no value, container-independent size value).

<Callout type="info" emoji="ðŸ“”">
  The article includes examples of these dimension value categories in the sections discussing a particular layout container.
</Callout>

While rendering the child components within the parent's viewport, specific components may overflow the provided viewport size. The layout container's strategy determines how to display (or hide) the exceeding child components.

### Gaps

All fundamental layout containers apply a default gap, ensuring that child components have some space between them.

The following sample shows how a `HStack` renders button children:

```ueml copy
<App>
  <HStack>
    <Button>First button</Button>
    <Button>Second button</Button>
    <Button>Third button</Button>
  </HStack>
</App>
```

<Playground
  previewOnly={true}
  name="Example: Layout containers use default gaps"
  height={100}
  horizontal={true}
  app={`
    <App>
      <HStack>
        <Button>First button</Button>
        <Button>Second button</Button>
        <Button>Third button</Button>
      </HStack>
    </App>
  `}
/>

You can remove the gaps if you intend to omit them entirely:

```ueml copy /gap="0"/
<App>
  <HStack gap="0">
    <Button>First button</Button>
    <Button>Second button</Button>
    <Button>Third button</Button>
  </HStack>
</App>
```

<Playground
  previewOnly={true}
  name="Example: Layout containers with no gaps"
  height={100}
  horizontal={true}
  app={`
    <App>
      <HStack gap="0">
        <Button>First button</Button>
        <Button>Second button</Button>
        <Button>Third button</Button>
      </HStack>
    </App>
  `}
/>

XMLUI offers several predefined gap values. Instead of inline literals (such as "16px", "0.5rem", etc.), use these values, as they can be themed, and it ensures a consistent design. You can learn about them <SmartLink href={THEME_VARIABLES_SPACING_IN_LAYOUT_CONTAINERS}>here</SmartLink>.

The following sample demonstrated using them:

```ueml copy /gap="$gap-tight"/ /gap="$gap-loose"/
<App>
  <VStack>
    <HStack gap="$gap-tight">
      <Button>First button</Button>
      <Button>Second button</Button>
      <Button>Third button</Button>
    </HStack>
    <HStack gap="$gap-loose">
      <Button>First button</Button>
      <Button>Second button</Button>
      <Button>Third button</Button>
    </HStack>
  </VStack>
</App>
```

<Playground
  previewOnly={true}
  name="Example: Layout containers with theme-controlled gaps"
  height={150}
  horizontal={true}
  app={`
    <App>
      <VStack>
        <HStack gap="$gap-tight">
          <Button>First button</Button>
          <Button>Second button</Button>
          <Button>Third button</Button>
        </HStack>
        <HStack gap="$gap-loose">
          <Button>First button</Button>
          <Button>Second button</Button>
          <Button>Third button</Button>
        </HStack>
      </VStack>
    </App>
  `}
/>


### Rendering Children

All layout container renders their children in declaration order; they consider the current page direction (left-to-right or right-to-left).

<Callout type="info" emoji="ðŸ“”">
  You should know a few additional layout-related things about <SmartLink href={REUSABLE_COMPONENTS + "#reusable-components-in-layout-containers"}>reusable components</SmartLink>.
</Callout>

Let's see a few samples to see how they work! The samples use the following code (replacing `Some_Container`) with a particular layout container:

```ueml copy /Some_Container/ /width="80%"/
<App> 
  <Some_Container>
    <Stack height="20px" width="20%" backgroundColor="orangered" />
    <Stack height="20px" width="20%" backgroundColor="orangered" />
    <Stack height="20px" width="80%" backgroundColor="orangered" />
    <Stack height="20px" width="20%" backgroundColor="orangered" />
    <Stack height="20px" width="20%" backgroundColor="orangered" />
  </Some_Container>
</App>
```

This markup displays five boxes; the third is four times wider than the others.

**Vertical stack**: Each child takes a new row.

<Playground
  previewOnly={true}
  name="Example: Vertical stack (VStack)"
  height={240}
  horizontal={true}
  app={`
    <App>
      <VStack>
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="80%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
      </VStack>
    </App>
  `}
/>

**Horizontal stack**: All children take a single row.

Observe that the content overflows the width of a single row, and the app displays a horizontal scrollbar.

<Playground
  previewOnly={true}
  name="Example: Horizontal stack (HStack)"
  height={100}
  horizontal={true}
  app={`
    <App>
      <HStack>
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="80%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
      </HStack>
    </App>
  `}
/>

**FlowLayout**: The component breaks a child into a new row when it does not fit into the remaining part of the row.

<Playground
  previewOnly={true}
  name="Example: FlowLayout"
  height={160}
  horizontal={true}
  app={`
    <App>
      <FlowLayout>
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="80%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
        <Stack height="20px" width="20%" backgroundColor="orangered" />
      </FlowLayout>
    </App>
  `}
/>

### Container Height

<Callout type="info" emoji="ðŸ’¡">
If you set an explicit height (with the `height` layout property), the layout container will use that height; otherwise, it accommodates its content (children) height. 
</Callout>

Check these examples:

```ueml copy
<VStack 
  backgroundColor="cyan" 
  horizontalAlignment="center" 
  verticalAlignment="center">
  This is some text within a VStack
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with implicit height"
  height={80}
  app={`
    <VStack 
      backgroundColor="cyan" 
      horizontalAlignment="center" 
      verticalAlignment="center">
      This is some text within a VStack
    </VStack>
  `}
/>

```ueml copy /height="160px"/
<VStack 
  height="160px" 
  backgroundColor="cyan" 
  horizontalAlignment="center" 
  verticalAlignment="center">
  This is some text within a VStack
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with *explicit* height"
  height={180}
  app={`
    <VStack 
      height="160px" 
      backgroundColor="cyan" 
      horizontalAlignment="center" 
      verticalAlignment="center">
      This is some text within a Stack
    </VStack>
  `}
/>

Check how the stack height changed (the cyan background) between the two examples!

When you explicitly set the height of a layout container, and the content is taller, that will overflow from the container:

```ueml copy /height="20px"/
<VStack height="40px" backgroundColor="cyan">
  <Text fontSize="3rem">This is some text within a Stack</Text>
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with vertical content overflow"
  height={120}
  app={`
    <VStack height="40px" backgroundColor="cyan">
      <Text fontSize="3rem">This is some text within a Stack</Text>
    </VStack>
  `}
/>

### Container Width

<Callout type="info" emoji="ðŸ’¡">
Unless you use an explicit width, a layout container uses the entire width of its viewport.
</Callout>

Check these examples:

```ueml copy
<VStack 
  backgroundColor="cyan" 
  horizontalAlignment="center" 
  verticalAlignment="center">
  This is some text within a VStack
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with implicit width"
  height={80}
  app={`
    <VStack 
      backgroundColor="cyan" 
      horizontalAlignment="center" 
      verticalAlignment="center">
      This is some text within a VStack
    </VStack>
  `}
/>

```ueml copy /height="200px"/
<VStack 
  width="400px" 
  backgroundColor="cyan" 
  horizontalAlignment="center" 
  verticalAlignment="center">
  This is some text within a VStack
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with *explicit* width"
  height={100}
  app={`
    <VStack 
      width="400px"
      backgroundColor="cyan" 
      horizontalAlignment="center" 
      verticalAlignment="center">
      This is some text within a Stack
    </VStack>
  `}
/>

Check how the stack width changed (the cyan background) between the two examples!

When you explicitly set the width of a layout container, and the content is wider, that will either break or overflow from the container.

For example, when you use text, the content can be broken into multiple lines, like in the following example:

```ueml copy /width="400px"/
<VStack width="400px" backgroundColor="cyan">
  <Text fontSize="2rem">This is some text within a Stack</Text>
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack and text with *explicit* width"
  height={160}
  app={`
    <VStack width="300px" backgroundColor="cyan">
      <Text fontSize="2rem">This is some text within a Stack</Text>
    </VStack>
  `}
/>

Other components, such as a box, may overflow horizontally:

```ueml copy /width="300px"/ /width="400px"/
<VStack width="300px" backgroundColor="cyan">
  <HStack height="40px" border="2px solid red" width="400px"/>
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack and text with *explicit* width"
  height={80}
  app={`
    <VStack width="300px" backgroundColor="cyan">
      <HStack height="40px" border="2px solid red" width="400px"/>
    </VStack>
  `}
/>

## Stack

The `Stack` component is an essential layout container. It renders its child items horizontally or vertically according to its `orientation` property, optionally providing some gap between child components.

You can assign the `horizontal` or `vertical` values to the `Stack` component's `orientation` property to declare its rendering orientation. The default value is `vertical`.

<Callout type="info" emoji="ðŸ“”">
Use the Stack component when its `orientation` property comes from an expression evaluated run time. If the orientation is static (it does not change run time), use `VStack` (equivalent with `<Stack orientation="vertical">`) and `HStack` (`<Stack orientation="horizontal">`). This style is straightforward and concise.
</Callout>

## VStack

<Callout type="info" emoji="ðŸ’¡">
A `VStack` component displays each of its children in a new row. If a child has no explicit (or component-specific) width, the `VStack` stretches the component to the entire viewport width. `VStack` keeps the child components' heights intact.
</Callout>

Here is an example:

```ueml copy
<VStack>
  <H2 backgroundColor="orangered">I'm a heading with colored background</H2>
  <Button>I'm a button</Button>
</VStack>
```

The `H2` component has no explicit size, so its width is set to the width of the text content (as the background color indicates). Though the `Button` component has no explicit size, it has a component-specific one (according to its content), so it is not stretched horizontally. The button is taller than the `VStack`, so its height determines the `VStack` height, and the text height is stretched to that.

<Playground
  previewOnly
  name="Example: VStack children width"
  height={120}
  app={`
    <VStack>
      <H2 backgroundColor="orangered">I'm a heading with colored background</H2>
      <Button>I'm a button</Button>
    </VStack>
  `}
/>

### VStack with Percentage Height

<Callout type="info" emoji="ðŸ’¡">
When you use a `VStack` child with percentage height, the child's height is calculated from the entire stack height.
</Callout>

Such a setup may cause overflow if the sum of percentages equals 100%, as the gaps between children are also included in the stack height. The following example demonstrates an overflow:

```ueml copy
<VStack height="200px" border="4px dotted green">
  <Stack backgroundColor="cyan" height="50%" />
  <Stack backgroundColor="orangered" height="50%" />
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with percentage height (with gaps)"
  height={240}
  app={`
    <VStack height="200px" border="4px dotted green">
      <Stack backgroundColor="cyan" height="50%" />
      <Stack backgroundColor="orangered" height="50%" />
    </VStack>
  `}
/>

When the stack does not apply gaps, there is no overflow:

```ueml copy /gap="0"/
<VStack gap="0" height="200px" border="4px dotted green">
  <Stack backgroundColor="cyan" height="50%" />
  <Stack backgroundColor="orangered" height="50%" />
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with percentage height (no gaps)"
  height={240}
  app={`
    <VStack gap="0" height="200px" border="4px dotted green">
      <Stack backgroundColor="cyan" height="50%" />
      <Stack backgroundColor="orangered" height="50%" />
    </VStack>
  `}
/>

### VStack with Star Height

<Callout type="info" emoji="ðŸ’¡">
When you use a `VStack` child height with star-sizing, the child's height is calculated from the remaining height of the entire stack after subtracting the heights of explicitly sized children and gaps.
</Callout>

Such a configuration will not cause overflow. Here is a sample:

```ueml copy
<VStack height="240px" border="4px dotted green">
  <Stack backgroundColor="cyan" height="*" />
  <H3>I'm a heading</H3>
  <Stack backgroundColor="orangered" height="2*" />
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with percentage height (with gaps)"
  height={260}
  app={`
    <VStack height="240px" border="4px dotted green">
      <Stack backgroundColor="cyan" height="*" />
      <H3>I'm a heading</H3>
      <Stack backgroundColor="orangered" height="2*" />
    </VStack>
  `}
/>

## HStack

<Callout type="info" emoji="ðŸ’¡">
A `HStack` component displays each of its children in a single row. If a child has no explicit (or component-specific) width, the `HStack` fits the component width to its content. `HStack` sets the child components' heights to the stack's viewport height.
</Callout>

Here is an example:

```ueml copy
<HStack>
  <H2 backgroundColor="orangered">I'm a heading with colored background</H2>
  <Button>I'm a button</Button>
</HStack>
```

The `H2` component has no explicit size, so it's stretched to the viewport width (as the background color indicates). Though `Button` has no explicit size, it has a component-specific one (according to its content), so it is not stretched.

<Playground
  previewOnly
  name="Example: HStack children width"
  height={80}
  app={`
    <HStack>
      <H2 backgroundColor="orangered">I'm a heading with colored background</H2>
      <Button>I'm a button</Button>
    </HStack>
  `}
/>

### HStack with Percentage Width

_To review_

<Callout type="info" emoji="ðŸ’¡">
When you use a `VStack` child with percentage height, the child's height is calculated from the entire stack height.
</Callout>

Such a setup may cause overflow if the sum of percentages equals 100%, as the gaps between children are also included in the stack height. The following example demonstrates an overflow:

```ueml copy
<VStack height="200px" border="4px dotted green">
  <Stack backgroundColor="cyan" height="50%" />
  <Stack backgroundColor="orangered" height="50%" />
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with percentage height (with gaps)"
  height={240}
  app={`
    <VStack height="200px" border="4px dotted green">
      <Stack backgroundColor="cyan" height="50%" />
      <Stack backgroundColor="orangered" height="50%" />
    </VStack>
  `}
/>

When the stack does not apply gaps, there is no overflow:

```ueml copy /gap="0"/
<VStack gap="0" height="200px" border="4px dotted green">
  <Stack backgroundColor="cyan" height="50%" />
  <Stack backgroundColor="orangered" height="50%" />
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with percentage height (no gaps)"
  height={240}
  app={`
    <VStack gap="0" height="200px" border="4px dotted green">
      <Stack backgroundColor="cyan" height="50%" />
      <Stack backgroundColor="orangered" height="50%" />
    </VStack>
  `}
/>

### HStack with Star Width

_To review_

<Callout type="info" emoji="ðŸ’¡">
When you use a `VStack` child height with star-sizing, the child's height is calculated from the remaining height of the entire stack after subtracting the heights of explicitly sized children and gaps.
</Callout>

Such a configuration will not cause overflow. Here is a sample:

```ueml copy
<VStack height="240px" border="4px dotted green">
  <Stack backgroundColor="cyan" height="*" />
  <H3>I'm a heading</H3>
  <Stack backgroundColor="orangered" height="2*" />
</VStack>
```

<Playground
  previewOnly
  name="Example: VStack with percentage height (with gaps)"
  height={260}
  app={`
    <VStack height="240px" border="4px dotted green">
      <Stack backgroundColor="cyan" height="*" />
      <H3>I'm a heading</H3>
      <Stack backgroundColor="orangered" height="2*" />
    </VStack>
  `}
/>

### Content Wrapping

`HStack` has a `wrapContent` property. If you set it to `true`, the engine starts a new line (or column) when the subsequent child to render would overflow in the current line.

In the following example, the fourth child does not fit in the first line entirely, so it overflows:

```ueml copy {2}
<HStack>
  <Stack backgroundColor="red" height="36" width="25%" />
  <Stack backgroundColor="green" height="36" width="40%" />
  <Stack backgroundColor="blue" height="36" width="20%" />
  <Stack backgroundColor="purple" height="36" width="30%" />
</HStack>
```

<Playground
  previewOnly={true}
  name="Horizontal stack with overflow"
  height={90}
  horizontal={true}
  app={`
    <HStack>
      <Stack backgroundColor="red" height="36" width="25%" />
      <Stack backgroundColor="green" height="36" width="40%" />
      <Stack backgroundColor="blue" height="36" width="20%" />
      <Stack backgroundColor="purple" height="36" width="30%" />
    </HStack>
  `}
/>

By setting the `wrapContent` flag, the forth child gets into a new line:

```ueml copy {2} /wrapContent="true"/
<HStack wrapContent="true">
  <Stack backgroundColor="red" height="36" width="25%" />
  <Stack backgroundColor="green" height="36" width="40%" />
  <Stack backgroundColor="blue" height="36" width="20%" />
  <Stack backgroundColor="purple" height="36" width="30%" />
</HStack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with content wrapping"
  height={120}
  horizontal={true}
  app={`
    <HStack wrapContent="true">
      <Stack backgroundColor="red" height="36" width="25%" />
      <Stack backgroundColor="green" height="36" width="40%" />
      <Stack backgroundColor="blue" height="36" width="20%" />
      <Stack backgroundColor="purple" height="36" width="30%" />
    </HStack>
  `}
/>


### Stack with Paddings

When you apply paddings, the available space of the Stack is decreased with the size of the corresponding paddings. The following example uses a stack with horizontal and vertical paddings and three children that fill the available space.

```ueml copy {2}
<Stack orientation="horizontal" backgroundColor="lightgray"
  horizontalPadding="4rem" verticalPadding="1rem">
  <Text backgroundColor="cyan" width="25%">W: 25%</Text>
  <Text backgroundColor="yellow" width="50%">W: 50%</Text>
  <Text backgroundColor="lightgreen" width="25%">W: 25%</Text>
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with paddings"
  height={68}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" backgroundColor="lightgray"
      horizontalPadding="4rem" verticalPadding="1rem">
      <Text backgroundColor="cyan" width="25%">W: 25%</Text>
      <Text backgroundColor="yellow" width="50%">W: 50%</Text>
      <Text backgroundColor="lightgreen" width="25%">W: 25%</Text>
    </Stack>
  `}
/>

The stack has a light gray background, indicating the padded area. Of course, the same concept works with vertical stacks:

```ueml copy {3}
<Stack orientation="vertical" backgroundColor="lightgray"
  height="240"
  horizontalPadding="4rem" verticalPadding="1rem">
  <Text backgroundColor="cyan" height="25%">H: 25%</Text>
  <Text backgroundColor="yellow" height="50%">H: 50%</Text>
  <Text backgroundColor="lightgreen" height="25%">H: 25%</Text>
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with paddings"
  height={250}
  horizontal={true}
  app={`
    <Stack orientation="vertical" backgroundColor="lightgray"
      height="240"
      horizontalPadding="4rem" verticalPadding="1rem">
      <Text backgroundColor="cyan" height="25%">W: 25%</Text>
      <Text backgroundColor="yellow" height="50%">W: 50%</Text>
      <Text backgroundColor="lightgreen" height="25%">W: 25%</Text>
    </Stack>
  `}
/>

### Items with Paddings

Setting paddings in nested items does not change their rendering.

```ueml copy
<Stack orientation="horizontal" backgroundColor="lightgray">
  <Text padding="12" backgroundColor="cyan" width="25%">W: 25%</Text>
  <Text padding="12" backgroundColor="yellow" width="50%">W: 50%</Text>
  <Text padding="12" backgroundColor="lightgreen" width="25%">W: 25%</Text>
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal stack, items have paddings"
  height={68}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" backgroundColor="lightgray">
      <Text padding="12" backgroundColor="cyan" width="25%">W: 25%</Text>
      <Text padding="12" backgroundColor="yellow" width="50%">W: 50%</Text>
      <Text padding="12" backgroundColor="lightgreen" width="25%">W: 25%</Text>
    </Stack>
  `}
/>

```ueml copy
<Stack orientation="vertical" backgroundColor="lightgray">
  <Text padding="12" backgroundColor="cyan" width="25%">W: 25%</Text>
  <Text padding="12" backgroundColor="yellow" width="50%">W: 50%</Text>
  <Text padding="12" backgroundColor="lightgreen" width="25%">W: 25%</Text>
</Stack>
```

<Playground
  previewOnly={true}
  name="Vertical stack, items have paddings"
  height={160}
  horizontal={true}
  app={`
    <Stack orientation="vertical" backgroundColor="lightgray">
      <Text padding="12" backgroundColor="cyan" width="25%">W: 25%</Text>
      <Text padding="12" backgroundColor="yellow" width="50%">W: 50%</Text>
      <Text padding="12" backgroundColor="lightgreen" width="25%">W: 25%</Text>
    </Stack>
  `}
/>

### Items with Margins

Item margins are not considered as spacing between items; the `Stack` does not calculate with them when sizing the item. Margins may cause overflow with percentage sizing, as the following sample indicates:

```ueml copy
<Stack orientation="horizontal" backgroundColor="lightgray">
  <Text margin="12" backgroundColor="cyan" width="25%">W: 25%</Text>
  <Text margin="12" backgroundColor="yellow" width="50%">W: 50%</Text>
  <Text margin="12" backgroundColor="lightgreen" width="25%">W: 25%</Text>
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal stack, items with margins"
  height={68}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" backgroundColor="lightgray">
      <Text margin="12" backgroundColor="cyan" width="25%">W: 25%</Text>
      <Text margin="12" backgroundColor="yellow" width="50%">W: 50%</Text>
      <Text margin="12" backgroundColor="lightgreen" width="25%">W: 25%</Text>
    </Stack>
  `}
/>

However, with star sizing, when spaces are not considered during the size calculation, they work without overflow:

```ueml copy
<Stack orientation="horizontal" backgroundColor="lightgray">
  <Text margin="12" backgroundColor="cyan" width="*">W: 25%</Text>
  <Text margin="12" backgroundColor="yellow" width="2*">W: 50%</Text>
  <Text margin="12" backgroundColor="lightgreen" width="*">W: 25%</Text>
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal stack, items with margins"
  height={68}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" backgroundColor="lightgray">
      <Text margin="12" backgroundColor="cyan" width="*">W: * (25%)</Text>
      <Text margin="12" backgroundColor="yellow" width="3*">W: 2* (50%)</Text>
      <Text margin="12" backgroundColor="lightgreen" width="2*">W: * (25%)</Text>
    </Stack>
  `}
/>

### Stack with Gaps

You can define gaps (with the `gap` property) between the child components of a stack; they can use the size units the same way as the children.

```ueml copy {2}
<Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem"
  gap="2rem">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="36" />
  <Stack backgroundColor="blue" height="36" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with gaps"
  height={80}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem"
      gap="2rem">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="36" />
      <Stack backgroundColor="blue" height="36" width="36" />
    </Stack>
  `}
/>

```ueml copy {2}
<Stack orientation="vertical" backgroundColor="lightgray" padding="1rem"
  gap="2rem">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="36" />
  <Stack backgroundColor="blue" height="36" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Vertical Stack with gaps"
  height={216}
  horizontal={true}
  app={`
    <Stack orientation="vertical" backgroundColor="lightgray" padding="1rem"
      gap="2rem">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="36" />
      <Stack backgroundColor="blue" height="36" width="36" />
    </Stack>
  `}
/>

#### Gaps and Percentage Sizing

**Unlike paddings, gaps are omitted when calculating the _available space_ of a particular stack dimension**. A significant consequence of using gaps is that you must consider gap size when using percentage sizes. The following example shows what happens when you use three percentage-sized children (sum width is 100%) with and without gaps:

```ueml copy
<Stack gap="0.5rem">
  <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem"
    gap="2rem">
    <Stack backgroundColor="red" height="36" width="25%" />
    <Stack backgroundColor="green" height="36" width="50%" />
    <Stack backgroundColor="blue" height="36" width="25%" />
  </Stack>
  <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem">
    <Stack backgroundColor="red" height="36" width="25%" />
    <Stack backgroundColor="green" height="36" width="50%" />
    <Stack backgroundColor="blue" height="36" width="25%" />
  </Stack>
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with and without gaps"
  height={180}
  horizontal={true}
  app={`
    <Stack gap="0.5rem">
      <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem"
        gap="2rem">
        <Stack backgroundColor="red" height="36" width="25%" />
        <Stack backgroundColor="green" height="36" width="50%" />
        <Stack backgroundColor="blue" height="36" width="25%" />
      </Stack>
      <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem">
        <Stack backgroundColor="red" height="36" width="25%" />
        <Stack backgroundColor="green" height="36" width="50%" />
        <Stack backgroundColor="blue" height="36" width="25%" />
      </Stack>
    </Stack>
  `}
/>

While the second stack (with no gaps) is rendered as expected, the first one overflows with the size of the two gaps applied.

#### Gaps and Star Sizing

You can resolve the overflow issue with gaps and percentage sizing. To remove the overflow issue, you should use star sizing as in the following example:

```ueml copy
<Stack gap="0.5rem">
  <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem"
    gap="2rem">
    <Stack backgroundColor="red" height="36" width="*" />
    <Stack backgroundColor="green" height="36" width="*" />
    <Stack backgroundColor="blue" height="36" width="*" />
    <Stack backgroundColor="purple" height="36" width="*" />
  </Stack>
  <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem">
    <Stack backgroundColor="red" height=36 width="*" />
    <Stack backgroundColor="green" height=36 width="*" />
    <Stack backgroundColor="blue" height=36 width="*" />
    <Stack backgroundColor="purple" height=36 width="*" />
  </Stack>
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with and without gaps"
  height={180}
  horizontal={true}
  app={`
    <Stack gap="0.5rem">
      <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem"
        gap="2rem">
        <Stack backgroundColor="red" height="36" width="*" />
        <Stack backgroundColor="green" height="36" width="*" />
        <Stack backgroundColor="blue" height="36" width="*" />
        <Stack backgroundColor="purple" height="36" width="*" />
      </Stack>
      <Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem">
        <Stack backgroundColor="red" height="36" width="*" />
        <Stack backgroundColor="green" height="36" width="*" />
        <Stack backgroundColor="blue" height="36" width="*" />
        <Stack backgroundColor="purple" height="36" width="*" />
      </Stack>
    </Stack>
  `}
/>

### Rendering Direction

The Stack component respects the reading direction set for the browser. If that is from right to left, the Stack renders its children accordingly.

The following example shows how a language with the right-to-left reading renders the Stack (look at the `direction` property's `rtl` value):

```ueml copy {2}
<Stack orientation="horizontal" padding="1rem" gap="1rem"
  direction="rtl">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="36" />
  <Stack backgroundColor="blue" height="36" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with right to left reading direction"
  height={80}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" padding="1rem" gap="1rem"
      direction="rtl">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="36" />
      <Stack backgroundColor="blue" height="36" width="36" />
    </Stack>
  `}
/>

The Stack has a property, `reverse`, which you can use to reverse the rendering order suggested by the current reading direction. While the `direction` value affects only the horizontal stack, the `reverse` value affects the vertical one, too.

```ueml copy {2}
<Stack orientation="horizontal" padding="1rem" gap="1rem"
  reverse="true">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="36" />
  <Stack backgroundColor="blue" height="36" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with the reverse flag"
  height={80}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" padding="1rem" gap="1rem"
      reverse="true">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="36" />
      <Stack backgroundColor="blue" height="36" width="36" />
    </Stack>
  `}
/>

```ueml copy {2}
<Stack orientation="vertical" padding="1rem" gap="1rem"
  reverse="true">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="36" />
  <Stack backgroundColor="blue" height="36" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Vertical Stack with the reverse flag"
  height={180}
  horizontal={true}
  app={`
    <Stack orientation="vertical" padding="1rem" gap="1rem"
      reverse="true">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="36" />
      <Stack backgroundColor="blue" height="36" width="36" />
    </Stack>
  `}
/>

### Content Wrapping

The Stack has a `wrapContent` property to start a new line (or column) when the subsequent child to render would overflow.

In the following example, the fourth child does not fit in the first line entirely, so it overflows:

```ueml copy {2}
<Stack orientation="horizontal" padding="1rem" gap="1rem">
  <Stack backgroundColor="red" height="36" width="25%" />
  <Stack backgroundColor="green" height="36" width="40%" />
  <Stack backgroundColor="blue" height="36" width="20%" />
  <Stack backgroundColor="purple" height="36" width="30%" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with overflow"
  height={90}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" padding="1rem" gap="1rem">
      <Stack backgroundColor="red" height="36" width="25%" />
      <Stack backgroundColor="green" height="36" width="40%" />
      <Stack backgroundColor="blue" height="36" width="20%" />
      <Stack backgroundColor="purple" height="36" width="30%" />
    </Stack>
  `}
/>

By setting the `wrapContent` flag, the forth child gets into a new line:

```ueml copy {2}
<Stack orientation="horizontal" padding="1rem" gap="1rem"
  wrapContent="true">
  <Stack backgroundColor="red" height="36" width="25%" />
  <Stack backgroundColor="green" height="36" width="40%" />
  <Stack backgroundColor="blue" height="36" width="20%" />
  <Stack backgroundColor="purple" height="36" width="30%" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with content wrapping"
  height={120}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" padding="1rem" gap="1rem"
      wrapContent="true">
      <Stack backgroundColor="red" height="36" width="25%" />
      <Stack backgroundColor="green" height="36" width="40%" />
      <Stack backgroundColor="blue" height="36" width="20%" />
      <Stack backgroundColor="purple" height="36" width="30%" />
    </Stack>
  `}
/>

> **Note**: Content wrapping is unavailable with the vertical stack.

### Content Alignment

With the `horizontalAlignment` and `verticalAlignment` properties, you can define the corresponding alignment of children within a stack.

```ueml copy {2}
<Stack orientation="horizontal" gap="1rem"
  horizontalAlignment="center">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="36" />
  <Stack backgroundColor="blue" height="36" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with centered contents"
  height={80}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" gap="1rem"
      horizontalAlignment="center">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="36" />
      <Stack backgroundColor="blue" height="36" width="36" />
    </Stack>
  `}
/>

```ueml copy {2}
<Stack orientation="vertical" gap="1rem"
  horizontalAlignment="end">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="36" />
  <Stack backgroundColor="blue" height="36" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Verical Stack with right-aligned contents"
  height={180}
  horizontal={true}
  app={`
    <Stack orientation="vertical" gap="1rem"
      horizontalAlignment="end">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="36" />
      <Stack backgroundColor="blue" height="36" width="36" />
    </Stack>
  `}
/>

```ueml copy {2}
<Stack orientation="horizontal" gap="1rem"
  verticalAlignment="center">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="72" width="36" />
  <Stack backgroundColor="blue" height="48" width="36" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with vertically centered contents"
  height={80}
  horizontal={true}
  app={`
    <Stack orientation="horizontal" gap="1rem"
      verticalAlignment="center">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="72" width="36" />
      <Stack backgroundColor="blue" height="48" width="36" />
    </Stack>
  `}
/>

## CHStack

<Callout type="info" emoji="ðŸ’¡">
`CHStack` is a shorthand version of `Stack` with a horizontal orientation with its contents centered.

```ueml copy {2-4}
<Stack
  orientation="horizontal"
  verticalAlignment="center"
  horizontalAlignment="center"
/>
```
</Callout>

Here is an example:

```ueml copy
<CHStack height="100" width="200" backgroundColor="lightgray">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="72" width="36" />
  <Stack backgroundColor="blue" height="48" width="36" />
</CHStack>
```

<Playground
  previewOnly={true}
  name="CHStack example"
  height={120}
  horizontal={true}
  app={`
    <CHStack height="100" width="200" backgroundColor="lightgray">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="72" width="36" />
      <Stack backgroundColor="blue" height="48" width="36" />
    </CHStack>
  `}
/>

## CVStack

<Callout type="info" emoji="ðŸ’¡">
`CVStack` is a shorthand version of `Stack` with a vertical orientation with its contents centered.

```ueml copy {2-4}
<Stack
  orientation="vertical"
  verticalAlignment="center"
  horizontalAlignment="center"
/>
```
</Callout>

Here is an example:

```ueml copy
<CVStack height="200" width="100" backgroundColor="lightgray">
  <Stack backgroundColor="red" height="36" width="36" />
  <Stack backgroundColor="green" height="36" width="72" />
  <Stack backgroundColor="blue" height="36" width="48" />
</CVStack>
```

<Playground
  previewOnly={true}
  name="CVStack example"
  height={220}
  horizontal={true}
  app={`
    <CVStack height="200" width="100" backgroundColor="lightgray">
      <Stack backgroundColor="red" height="36" width="36" />
      <Stack backgroundColor="green" height="36" width="72" />
      <Stack backgroundColor="blue" height="36" width="48" />
    </CVStack>
  `}
/>

## FlowLayout

The `FlowLayout` component resembles a horizontal stack by way of content wrapping.
It implements the same behavior: automatically breaking overflowing components into a new line.
Besides this behavior, it adds some quality of life features when sizing components:

- **Percentage sizing**: `FlowLayout` considers the gaps between child elements when using percentage sizing, unlike `Stack`.
- **Responsiveness**: `FlowLayout` resizes percentage-sized children on mobile devices.

<Playground
  previewOnly={true}
  name="FlowLayout"
  height={120}
  horizontal={true}
  app={`
    <FlowLayout padding="1rem" gap="1rem">
      <Stack backgroundColor="red" height="36" width="25%" />
      <Stack backgroundColor="green" height="36" width="40%" />
      <Stack backgroundColor="blue" height="36" width="20%" />
      <Stack backgroundColor="purple" height="36" width="30%" />
    </FlowLayout>
  `}
/>

### Aligned Percentage Sizing

An overflow can occur when you render multiple children in a row while using percentage sizing and gaps.
The following sample (similar to the one above with the Stack) demonstrates such a situation:

```ueml copy
<Stack orientation="horizontal" backgroundColor="lightgray" padding="1rem" gap="1rem">
  <Stack backgroundColor="red" height="36" width="25%" />
  <Stack backgroundColor="green" height="36" width="50%" />
  <Stack backgroundColor="blue" height="36" width="25%" />
</Stack>
```

<Playground
  previewOnly={true}
  name="Horizontal Stack with percentage widths and overflow"
  height={100}
  horizontal={true}
  app={`
      <Stack orientation="horizontal" backgroundColor="lightgray" 
        padding="1rem" gap="1rem">
        <Stack backgroundColor="red" height="36" width="25%" />
        <Stack backgroundColor="green" height="36" width="50%" />
        <Stack backgroundColor="blue" height="36" width="25%" />
      </Stack>  
    `}
/>

The FlowLayout component handles this sizing issue by adjusting the child component dimensions accounting for the gaps:

```ueml copy
<FlowLayout backgroundColor="lightgray" padding="1rem" gap="1rem">
  <Stack backgroundColor="red" height="36" width="25%" />
  <Stack backgroundColor="green" height="36" width="50%" />
  <Stack backgroundColor="blue" height="36" width="25%" />
</FlowLayout>
```

<Playground
  previewOnly={true}
  name="FlowLayout children with 100% combined widths"
  height={100}
  horizontal={true}
  app={`
      <FlowLayout backgroundColor="lightgray" padding="1rem" gap="1rem">
        <Stack backgroundColor="red" height="36" width="25%" />
        <Stack backgroundColor="green" height="36" width="50%" />
        <Stack backgroundColor="blue" height="36" width="25%" />
      </FlowLayout>  
  `}
/>

### Size Capping

The FlowLayout component caps the size of items exceeding the available width:

```ueml copy {2}
<FlowLayout backgroundColor="lightgray" padding="1rem" gap="1rem">
  <Stack backgroundColor="red" height="36" width="1000000rem" />
  <Stack backgroundColor="green" height="36" width="50%" />
  <Stack backgroundColor="blue" height="36" width="25%" />
</FlowLayout>
```

Note how the extreme width of the first child is capped to the space available for the FlowLayout, while the other children's sizes remain unmodified:

<Playground
  previewOnly={true}
  name="FlowLayout with sum of 100% percentage widths"
  height={150}
  horizontal={true}
  app={`
      <FlowLayout backgroundColor="lightgray" padding="1rem" gap="1rem">
        <Stack backgroundColor="red" height="36" width="1000000rem" />
        <Stack backgroundColor="green" height="36" width="50%" />
        <Stack backgroundColor="blue" height="36" width="25%" />
      </FlowLayout>  
  `}
/>
