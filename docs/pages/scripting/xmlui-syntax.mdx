import { Callout } from 'nextra/components';
import { XMLUI_EXPRESSIONS, XMLUI_EXPRESSIONS_ARROW_FUNCTIONS } from "../../meta/pages";

# Scripts in XMLUI

<Callout type="info" emoji="ðŸ’¡">
XMLUI uses a scripting language, which is a **subset of JavaScript**. 
</Callout>

When an application runs, the framework precompiles scripts into an intermediate representation and processes (interprets) that. It uses the same expression evaluation and statement executing semantics as JavaScript.

<Callout type="info" emoji="ðŸ“”">
When we designed scripting, we opted to create the scripting language as a subset of JavaScript because of these primary reasons:
- JavaScript is an easy language to learn at the level needed to productively use XMLUI; its language constructs are mature and proven.
- Using JavaScript semantics allows us to leverage the entire JS runtime and utilize them with the original semantics; we do not need to create a separate runtime library.
</Callout>

## Sync and Async Evaluation

<Callout type="info" emoji="ðŸ’¡">
The scripting engine is smart about using sync and async evaluation.
</Callout>

When resolving property values, the engine uses sync evaluation; event handlers are asynchronous. You do not have to know how it happens; they just get the operation result.

You do not need to use `async` or `await` keywords or do anything to manage asynchronous execution. More accurately, these keywords are not part of the scripting language.

When evaluating the initial value of variables or setting and changing property values, the engine expects sync evaluation. It needs the initial values instantly to render the UI. Thus, the engine raises an error message if the initial variable evaluation contains async parts.

The UI remains responsive even if you create an infinite loop with an event handler.

## Language Constraints

The scripting language is just a subset of JavaScript. This section describes what is not implemented in XMLUI.

**No `import` and `export` statements**

XMLUI does not support modules, so the language does not yet include the `import` and `export` keywords.

<Callout type="info" emoji="ðŸ“”">
We are already working on implementing simplified module handling within the framework. So, you will be able to separate some utility code into separate files and use them similarly to JavaScript modules. Nonetheless, this feature is not available yet.
</Callout>

**No labels**

You cannot use labels: no label declarations; the `break` and `continue` statements do not accept labels.

**No class declarations**

XMLUI does not allow declaring classes.

**No `debugger` statement**

XMLUI does not support using the `debugger` statement.

<Callout type="info" emoji="ðŸ“”">
When we have debugging tools for XMLUI, we may implement this statement.
</Callout>

**No default value and rest syntax with destructuring constructs**

You can use destructure operators with variable declarations and function arguments with a syntax matching JavaScript. However, the current implementation does not support extracting rest values and providing default values.

So, these example constructs work in XMLUI:

```js
const {a, b} = someObject;

val {a, b, other: { c, d }} = someObject;

let {a, b:myB} = someObject;

function example ({a, b, other: { c:myC }}) {
  // ...
}
```

However, these constructs are not supported:

```js
const {a, b, ...rest} = someObject;

let {a, b = 0} = someObject;
```

**Destructuring with left-hand value is unavailable**

While destructuring works with left-hand values in JavaScript, XMLUI does not support this construct. For example, swapping two variables with this construct is available in JavaScript but not in XMLUI:

```js
let a = 1, b = 2;
[a, b] = [b, a];
```

**The `new`, `void`, `yield`, and `await` operators are unavailable**

You cannot instantiate objects with the `new` operator. This feature is missing for code security reasons.

<Callout type="info" emoji="ðŸ“”">
We plan to relax this constraint in a future release, at least allowing the new operator for the core, frequently used JavaScript object types.
</Callout>

We opted to omit `the void` and `yield` operators as we guess they do not add value to the XMLUI scripting. Not only `yield` but generator functions are unavailable.

As you learned earlier, XMLUI handles async execution, so there is no need for `async` or `await`. Async functions and loops are not available.

**Restricted use of the optional chaining operator**

XMLUI supports using the optional chaining operator(`?.`) only for member access but not for calculated member access (`?.[]`) and function invocation (`?.()`).

<Callout type="info" emoji="ðŸ“”">
We plan to add these operators in a future release.
</Callout>

## Semantic differences

There are a few semantic differences between JavaScript and XMLUI that you should consider when working with scripts.

### Standard and optional member access operators

In the current version, the member access operator `.` and its optional pair, `?.` both work with the semantics as the optional operator. 

So, using the `myResult.customerName` expression, it is evaluated as if it were `myResult?.customerName`. In JavaScript, the first would give an error if `myResult` were `undefined`, while the second would result in undefined without raising an error.

In XMLUI, both would retrieve `undefined`.

<Callout type="info" emoji="ðŸ“”">
We decided on this implementation because we have experienced that it relaxes the syntax and makes it easier to code with `null` and `undefined` values. In the future, we will include configurable switches for the scripting engine to turn this behavior on or off. 
</Callout>

### Variable declarations

Like JavaScript, XMLUI supports declaring variables with the keywords `var`, `let`, and `const`. However, XMLUI restricts their usage:

`var` can be used only in the top code level behind files; it is not allowed within function declarations or event handlers.
`let` and `const` can be used only within event handlers and function declarations.

### Reactive Variables

Variables declared with `var` are reactive. **They automatically update when their dependencies (in the expression the variable is initialized with) change, such as components or other variables they rely on**. 

Look at these variable declarations:

```js
let count = 0;
let countTimesThree = count * 3;
```

If you change the `count` variable, the `countTimesThree` variable will automatically update:

```js
count = 5;
```

This statement will update the `countTimesThree` variable to 15 even without explicitly assigning the value due to the reactive nature of XMLUI variables.

However, the first time you assign a runtime-evaluated value to the `countTimesThree` variable, it will lose its dependency on `count`:

```js
countTimesThree = 12;
```

<Callout type="info" emoji="ðŸ“”">
Observe that this statement is an assignment, not a variable declaration.
</Callout>

After that assignment, changing the value of `counter` will never modify `counterTimesThree`; you cannot restore its reactive behavior. If you assign this value to `countTimesThree` somewhere in an event handler:

```js
countTimesThree = count * 3;
```

`countTimesThree` will have three times the current value of `count` but will no longer depend on `count`.  Any future updates to count will not update `countTimesThree` automatically.

This article contains a [How Reactiveness Works](#reactiveness) section where you can learn more details about this topic.

### No `Error` object

XMLUI supports the `throw` statement and the `try..catch..finally` block. However, you cannot throw native JavaScript `Error` objects; you should provide your error objects (even strings, numbers, or other composite object values).

Here are a few examples:

```js copy {3}
function sum(values) => {
  if (values.some(function (v) {typeof v !== "number"})) {
    throw "Can only add numbers";
  }
  let sum = 0;
  for (let v of values) {
    sum += v;
  }  
  return sum;
}
```

```js copy {3}
try {
  readData(); // may throw three types of exceptions
} catch (e) {
  if (e === "DataReadError") {
    // Statements to handle data read errors
  } else if (typeof e === "number") {
    // Statements to handle a particular numeric error code
  } else if (e.errorType) {
    // Statements to handle some other error
  } else {
    // Statements to handle any unspecified exceptions
    console.log(e);
  }
}
```
## Event Handlers [#event-handlers]

The engine transforms the script of event handlers into arrow functions. The compiler recognizes several patterns and helps you make the code more concise.

### Empty Code

The engine considers the empty code (whitespaces only) a no-op declaration and turns them into a no-op arrow function:

```js
() => {}
```

### Identifiers

The engine considers the identifiers to be arrow function names. It transforms these identifiers into arrow functions with as many arguments as the corresponding event. Provided an event has *N* arguments (*N* can be zero), the engine applies this transform:

```js
(arg1, arg2, /* ... */, argN) => idUsed(arg1, arg2, /* ... */, argN)
```

<Callout type="info" emoji="ðŸ“”">
Here, `idUsed` is the identifier used as the event handler, and `arg1`,  `arg2`, and `argN` are the event arguments.
</Callout>

### Member Access Chain

The engine considers the member access chains to be evaluated to arrow function expressions. It transforms them into arrow functions with as many arguments as the corresponding event. Provided an event has *N* arguments (*N* can be zero), the engine applies this transform:

```js
(arg1, arg2, /* ... */, argN) => memberAccessChain(arg1, arg2, /* ... */, argN)
```

The engine takes identifiers chained together with the member access (`.`) operator or the calculated member access operator (`[<literal>]`) as a member access chain. Here are a few examples:

```js
action.execute
operation[0].handler.fire
operation["do-it"].handler.fire
```

However, the calculated member access operator with expressions (and not literals) breaks this chain. For example, these expressions do not turn the member access expression chain into an arrow function:

```js
operation[index + 3].handler.fire
operation["do" + "it"].handler.fire
```

### Expressions

When the event handler code is an expression, the engine transforms it into an arrow expression, like in this sample:

Original event handler:

```js
count++;
```

Transformed event handler:

```js
() => count++;
```

### Code Blocks with Single Expression

Though binding expressions are wrapped into curly braces (e.g., `{doThis()}`), event handlers are not; nonetheless, users often forget about this fact. The engine recognizes the braces as block statement delimiters and transforms code blocks into the appropriate arrow function:

Original event handler:

```js
{count++;}
```

Transformed event handler:

```js
() => count++;
```

### Code Blocks with Multiple Statement

If the block statement contains a single non-expression statement or multiple statements, the engine provides a different transformation:

Original event handler:

```js
{ if (x) counter++; }
```

Transformed event handler:

```js
() => { 
  if (x) counter++; 
}
```

Original event handler:

```js
{ doThis(); count++; }
```

Transformed event handler:

```js
() => { 
  doThis(); 
  count++;
}
```

In this situation, the engine cannot infer if you intended to return the `count++` value from the event handler. You must use the `return` statement to indicate the intention explicitly:

Original event handler:

```js
{ doThis(); return count++; }
```

Transformed event handler:

```js
() => { 
  doThis(); 
  return count++;
}
```

### Multiple Statements

The engine recognizes multiple statements and transforms them similarly to the body of block statements:

Original event handler:

```js
doThis(); count++;
```

Transformed event handler:

```js
() => { 
  doThis(); 
  count++;
}
```

<Callout type="info" emoji="ðŸ“”">
Be aware of using the `return` statement explicitly to retrieve a value from an event handler.
</Callout>


## Functions and Arrow Expressions

_TBD_ 

## How Reactiveness Works [#reactiveness]

The reactive feature works with XMLUI-managed objects such as variables and components. However, it does not work with objects managed by other entities.

For example, the following variable declaration assigns the current timestamp to the `thisIsNow` variable:

```js
let thisIsNow = getDate();
```

The timestamp continuously changes; nonetheless, `this is now` (though it is still a reactive variable) does not have any dependencies, as the execution of the body of the `getDate()` function is managed by the JavaScript runtime and not XMLUI. 

The exact time at which this automatic update occurs is indeterministic. Updating a value and all reactive variables depending on it is far from atomic. If there are more dependencies of paticular value, the order of updating them is also indeterministic.

Without the exact details, this is what happens when you modify a dependency of a reactive variable:
- After completing the execution of an operation (for example, an assignment), the engine detects the update in a dependency (or even more dependencies).
- The engine initiates a UI refresh.
- This UI refresh evaluates all reactive variables that depend on the updated dependency (or dependencies). The UI is displayed accordingly.

You can create circular dependencies among reactive variables that could cause an infinite loop. However, the mechanism above (based on UI refresh) will settle down the value of such variables and avoid infinite updates.

Because the update mechanism triggers only after executing an entire XMLUI statement, after processing all statements in an event handler, there is no more trigger, so there is no chance for an infinite loop.

Look at this example, where variables `b` and `c` form a circular reference and depend on variable `a`. Clicking the button increments `a` and triggers the update mechanism:

```ueml
<App 
  var.a="{0}" 
  var.b="{a + (c ?? 0) * 2}" 
  var.c="{a + (b ?? 0) * 2}">
  <Button label="Increment 'a'" onClick="a++"/>
  <Text>a = {a}</Text>
  <Text>b = {b}</Text>
  <Text>c = {c}</Text>
</App>
```

<Playground
  name="Example: No infinite updates"
  app={`
    <App 
      var.a="{0}" 
      var.b="{a + (c ?? 0) * 2}" 
      var.c="{a + (b ?? 0) * 2}">
      <Button label="Increment 'a'" onClick="a++"/>
      <Text>a = {a}</Text>
      <Text>b = {b}</Text>
      <Text>c = {c}</Text>
    </App>
  `}
/>

The values you see are displayed after two UI updates:
- The completion of `a++` statements in `onClick` event handler triggers a UI update.
- The completion of the entire event handler triggers another UI update.

Only the value of `a` is deterministic; it is one after a single click. The other variable values are indeterministic due to the circular reference between them and the unknown order of re-evaluating `b` and `c`. This order may be different for the two UI refreshes. 

<Callout type="info" emoji="ðŸ“”">
A future release of XMLUI may display different values for `b` and `c`. However, it will not change the fact that there are now infinite update loops.
</Callout>