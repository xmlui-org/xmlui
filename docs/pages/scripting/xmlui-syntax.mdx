import { Callout } from 'nextra/components';
import { XMLUI_EXPRESSIONS } from "../../meta/pages";

# Script Syntax

XMLUI uses a script language (XMLUIScript, similar to JavaScript) to declare and execute application logic. The language syntax comprises *expression* and *statement* definitions.

In the <SmartLink href={ XMLUI_EXPRESSIONS }>Expressions</SmartLink> document,
you could learn about the expression syntax. Here, you will learn the statement syntax.

## Comments

XMLUIScript allows you two kinds of comments:
- **Block comments**. Any text wrapped between `/*` and `*/` is a block comment. Note you cannot nest block comments to each other, and block comments within a string literal are not considered a comment but part of the string.
- **End-of-line comments**. Any text following the `//` token till the end of the current line is considered a comment.

Examples:

```js
const nums = [ 12, 31, 23, 117 /* , 123 */];
const sqrNums = nums.map(n => n * n); // Create the squares of numbers
```

## Statements

XMLUIScript provides several statements to express programming logic. Most of these statements have the same semantics as their counterpart in JavaScript.

<Callout type="info" emoji="ðŸ“”">
The statements can be optionally closed with a semicolon. There are a few contexts where the closing semicolons are required to avoid ambiguity. It is a suggested practice to conclude statements with a semicolon always.
</Callout>

### Variable declarations

You can use the `let` and `const` statements to declare variables and optionally set their initial values. While an initial value is optional for the `let` statement, it is required for `const`. You can change the values of variables declared with `let`. However, the value of `const` variables can be set only once, at their initialization. The engine raises an error if you try to modify the value of a variable.

Here are a few examples:

```js
let x; // No initial value
let y = 0, z; // Multiple declarations
let sum = 0; // Initialize sum to zero
const factor = 1.5; // Factor cannot be changed later
```

<Callout type="info" emoji="ðŸ“”">
Though identifiers can start with a dollar sign (`$`), variable declarations do not allow you to start variable names with a dollar sign. `$` is reserved for context values.
</Callout>

### Destructuring

You can use destructure operators with variable expressions. XMLUIScript supports a similar syntax to JavaScript; however, it does not support extracting rest values and providing default values.

Examples:

```js
const {a, b} = someObject;
// const a = someObject.a, b = someObject.b

const {a, b, other: { c, d }} = someObject;
// const a = someObject.a, b = someObject.b, c = someObject.other.c, d = someObject.other.d

const {a, b:myB} = someObject;
// const a = someObject.a, myB = someObject.b

let {a, b, other: { c:myC }} = someObject;
// let a = someObject.a, b = someObject.b, myC = someObject.other.c

const [a, b] = someArray;
// const a = someArray[0], b = someArray[1}

const [a, b,, c] = someArray;
// const a = someArray[0], b = someArray[1}, c = someArray[3]

let [a,,, {b:myB, c}] = someArray;
// let a = someArray[0], myB = someArray[3].b, c = someArray[3].c 
```

### Empty Statement

An `empty statement` is used to provide no statement, although the JavaScript syntax would expect one. XMLUIScript indicates it with a semicolon (`;`).

> **Hint**: It is a good idea to comment on the intentional use of the empty statement, as it is not apparent to distinguish from a usual semicolon.

Example:

```js
// This for loop has no iteration body
for (let i = 0; i < 10; i++); // The closing ";" indicates the empty statement
```

### Block Statement

You can group multiple statements into a single *block statement*, wrapping them between `{` and `}`. For example, you can put multiple individual statements into the body of a for-loop:

```js
let sum = 0;
for (let i = 0; i < 10; i++) {
  sum += i;
  console.log("Current sum is", sum);
}
```

Block statements have their separate identifier scope. Variables declared within them will hide external variables with the same name. For example, in the following sample, the log output will show 42 in the first line and 1234 in the second, as the declaration of `myNumber` in the block statement hides `myNumber` declared outside of the block statement:

```js
let myNumber = 1234;
{
  let myNumber = 42;
  console.log(myNumber); 
}
console.log(myNumber);
```

<Callout type="info" emoji="ðŸ“”">
You do not need to put a closing semicolon after a block statement.
</Callout>

### Expression Statement

When you write an expression in the context of other statements, XMLUIScript represents that expression as an expression statement. For example, here, the highlighted line are expression statements:

```js {3,4,5}
let sum = 0;
for (let i = 0; i < 10; i++) {
  sum += i;
  console.log("Current sum is", sum);
  123 + 456;
}
```

<Callout type="info" emoji="ðŸ“”">
Though there is no use in evaluating the value of `123 + 456` expression statement, the engine does that (in every iteration) and omits the result.
</Callout>

### The `if...else` Statement

The `if...else` statement executes a statement if a specified condition is *truthy*. If the condition is *falsy*, another statement in the optional else clause will be executed.

<Callout type="info" emoji="ðŸ“”">
A *truthy* value is a value that is considered `true` when encountered in a Boolean context: All values are *truthy* unless they are defined as *falsy*. That is, all values are *truthy* except `false`, `0`, `-0`, `""`, `null`, `undefined`, and `NaN`.
</Callout>

Here are a few examples:

```js
// Example #1
if (a > 3) doThis();

// Example #2
if (a > 3) doThis(); else doThat();

// Example #3
if (a > 3) {
  doThisFirst();
  andThen()
}
else doThat();
```

<Callout type="info" emoji="ðŸ“”">
Example #2 shows that you need a closing semicolon before `else`, as the consequent ("then") branch of the `if...else` statement is a single (non-block) statement.
</Callout>

### The `while` Statement

The `while` statement creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

Here are a few examples:

```js
// Example #1
let sum = 0;
let counter = 1;
while (counter <= 10) sum += counter++; 
```
```js
// Example #2
let sum = 0;
let counter = 1;
while (counter <= 10) {
  sum += counter;
  counter++;
} 
```

### The `do...while` Statement

The `do...while` statement creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

```js
// Example #1
let sum = 0;
let counter = 1;
do sum += counter++; while (counter <= 10)  
```
```js
// Example #2
let sum = 0;
let counter = 1;
do {
  sum += counter;
  counter++;
} while (counter <= 10)
```

### The `for` Statement

The for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement) to be executed in the loop.

- **Initialization**. An expression or variable declaration that is evaluated once before the loop begins. This expression may optionally declare new variables with the `let` keyword; these variables are local to the loop.
- **Condition**. An expression to be evaluated before each loop iteration. If this expression evaluates to true, the loop's body is executed. Otherwise, execution exits the loop and goes to the first statement after the loop construct. This conditional test is optional. If omitted, the condition always evaluates to true.
- **Update**. An optional expression to be evaluated at the end of each iteration before the next evaluation of the condition.

Examples:

```js
// Example #1
let sum = 0;
for (let i = 0; i < 10; i++) {
  sum +=i;  
}
```

```js
// Example #2
let sum = 0;
let i;
for (i = 0; i < 10; i++) {
  sum += i;  
}
```

You can declare multiple variables in the loop initialization and add multiple update expressions (as a sequence expression):

```js
let sum = 0;
for (let i = 0, j = 3; i < 10; i++, j += 3) {
  sum += i + j;  
}
```

### The `for...in` Statement

The `for...in` statement iterates over all enumerable string properties of an object including inherited enumerable properties.

- **Variable**. This variable receives a string property name on each iteration. It may be either a declaration with const, or let, or a variable name. Variables declared with `const` or `let` are local to the `for...in` loop's scope.
- **Object**. An object whose enumerable properties are iterated over.

Examples:

```js
const obj = { a: 12, b: 34, c: "Hello" }
for (const key in obj) {
  console.log(obj[key]);
}
```

This code snippet will display this output:

```text
12
34
Hello
```

### The `for...of` Statement

The `for...of` statement executes a loop that operates on a sequence of values sourced from an iterable object (such as `Array`, `String`, `Map`, `Set`, and others.

- **Variable**. This variable receives a value from the sequence on each iteration. It may be either a declaration with const, or let, or a variable name. Variables declared with `const` or `let` are local to the `for...in` loop's scope.
- **Object**. An iterable object. The source of the sequence of values on which the loop operates.

Examples: 

```js
const values = [1, 2, 3, 5, 8, 13, 21]
for (const value of values) {
  console.log(value);  
}
```

### The `break` Statement

The `break` statement terminates the current loop or switch statement and transfers program control to the statement following the terminated statement.

Examples:

```js
// Sum up numbers from 1 to 10
let sum = 0;
let counter = 1;
while (true) {
  if (counter > 10) break;
  sum += counter++;
}
```

```js
// Dispatch options
switch (option) {
  case 0:
    doThis();
    break;
  case 1:
    doThat();
    break;
  case 2:
    doSpecial();
    break;
  default:
    doExceptional();  
    break;  
}
```

### The `continue` Statement

The `continue` statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

In contrast to the `break` statement, `continue` does not terminate the execution of the loop entirely, but instead:
- In a `while` or `do...while` loop, it jumps back to the condition.
- In a `for` loop, it jumps to the update expression.
- In a `for...in`, or `for...of` loop, it jumps to the next iteration.

Example:

```js
  
let sum = 0;
for (let i = 1; i <= 100; i++) {
  if (i % 3 === 2) continue;
  sum += i;
  console.log("Current sum", sum);
}
```

### The `return` Statement

The `return` statement ends function execution and specifies a value to be returned to the function caller. If the value is omitted, `undefined` is returned.

Examples:

```js
(n) => {
  let sum = 0;
  for (let i = 1; i <= n; i++) sum += i;
  return sum;
}
```

```js
(n) => {
  if (n % 3 === 2) return;
  console.log("Remainder of " + n + " is not equal to 2");
}
```

### The `switch` Statement

The `switch` statement evaluates an expression, matching the expression's value against a series of `case` clauses, and executes statements after the first case clause with a matching value until a break statement is encountered. The `default` clause of a switch statement will be executed if no case matches the expression's value.

If the control flow of the executing `case` clause does not reach a `break` statement concluding the particular case, the execution continues with the subsequent `case` clause until there remains any.

Examples:

```js
// Dispatch options
switch (option) {
  case 0:
    doThis();
    break;
  case 1:
    doThat();
    break;
  case 2:
    doSpecial();
    break;
  default:
    doExceptional();  
    break;  
}
```

```js
// Case 0 flows to case 1
switch (option) {
  case 0:
    doThis();
  case 1:
    doThat();
    break;
  case 2:
    doSpecial();
    break;
}
```

```js
// Multiple cases with the same execution
switch (option) {
  case 0:
  case 3:
  case 6:
    doThis();
    break;
  case 1:
  case 2:
  case 5:
    doThat();
    break;
  default:
    doExceptional();  
    break;  
}
```

### The `throw` Statement

The `throw` statement throws a user-defined error value. Execution of the current function will stop (the statements after throw won't be executed), and control will be passed to the first `catch` block in the call stack. If no `catch` block exists among caller functions, the code will terminate.

The `throw` keyword can be followed by any kind of expression.

Examples:

```js
(values) => {
  if (!values.every(v => typeof v === "number")) {
    throw "Can only add numbers";
  }
  return values.reduce((a, b) => a + b);
}
```

```js
const handler = (err, data) => {
  if (err) {
    throw err;
  }
  console.log(data);
}
```

### The `try...catch` Statement

The `try...catch` statement comprises a try block and either a `catch` block, a `finally` block, or both. The code in the `try` block is executed first, and if it throws an exception, the code in the `catch` block will be executed. The code in the `finally` block will always be executed before the control flow exits the entire construct.

The `catch` block can have an optional identifier to hold the caught error for the associated `catch` block. If the `catch` block does not use the exception's value, you can omit the identifier.

Examples:

**Unconditional error**

```js
try {
  throw "myError";
} catch (e) {
  // Log the error
  console.log(e);
}
```

Log:

```text
myError
```

**Testing the error condition**

```js
try {
  readData(); // may throw three types of exceptions
} catch (e) {
  if (e === "DataReadError") {
    // Statements to handle data read errors
  } else if (typeof e === "number") {
    // Statements to handle a particular numeric error code
  } else if (e.errorType) {
    // Statements to handle some other error
  } else {
    // Statements to handle any unspecified exceptions
    console.log(e);
  }
}
```

**Nested try blocks**

```js
try {
  try {
    throw "Something strange";
  } catch (e) {
    console.error("inner", e);
    throw e;
  } finally {
    console.log("finally");
  }
} catch (e) {
  console.error("outer", e);
}
```

Log:

```text
inner Something strange
finally
outer Something strange
```

**Returning from finally**

```js
(() => {
  try {
    try {
      throw "weird";
    } catch (e) {
      console.error("inner", e);
      throw e;
    } finally {
      console.log("finally");
      return;
    }
  } catch (e) {
    console.error("outer", e);
  }
})();
```

Log:

```text
inner weird
finally
```

## Event Handlers [#event-handlers]

The engine transforms the script of event handlers into arrow functions. The compiler recognizes several patterns and helps you make the code more concise.

### Empty Code

The engine considers the empty code (whitespaces only) a no-op declaration and turns them into a no-op arrow function:

```js
() => {}
```

### Identifiers

The engine considers the identifiers to be arrow function names. It transforms these identifiers into arrow functions with as many arguments as the corresponding event. Provided an event has *N* arguments (*N* can be zero), the engine applies this transform:

```js
(arg1, arg2, /* ... */, argN) => idUsed(arg1, arg2, /* ... */, argN)
```

<Callout type="info" emoji="ðŸ“”">
Here, `idUsed` is the identifier used as the event handler, and `arg1`,  `arg2`, and `argN` are the event arguments.
</Callout>

### Member Access Chain

The engine considers the member access chains to be evaluated to arrow function expressions. It transforms them into arrow functions with as many arguments as the corresponding event. Provided an event has *N* arguments (*N* can be zero), the engine applies this transform:

```js
(arg1, arg2, /* ... */, argN) => memberAccessChain(arg1, arg2, /* ... */, argN)
```

The engine takes identifiers chained together with the member access (`.`) operator or the calculated member access operator (`[<literal>]`) as a member access chain. Here are a few examples:

```js
action.execute
operation[0].handler.fire
operation["do-it"].handler.fire
```

However, the calculated member access operator with expressions (and not literals) breaks this chain. For example, these expressions do not turn the member access expression chain into an arrow function:

```js
operation[index + 3].handler.fire
operation["do" + "it"].handler.fire
```

### Expressions

When the event handler code is an expression, the engine transforms it into an arrow expression, like in this sample:

Original event handler:

```js
count++;
```

Transformed event handler:

```js
() => count++;
```

### Code Blocks with Single Expression

Though binding expressions are wrapped into curly braces (e.g., `{doThis()}`), event handlers are not; nonetheless, users often forget about this fact. The engine recognizes the braces as block statement delimiters and transforms code blocks into the appropriate arrow function:

Original event handler:

```js
{count++;}
```

Transformed event handler:

```js
() => count++;
```

### Code Blocks with Multiple Statement

If the block statement contains a single non-expression statement or multiple statements, the engine provides a different transformation:

Original event handler:

```js
{ if (x) counter++; }
```

Transformed event handler:

```js
() => { 
  if (x) counter++; 
}
```

Original event handler:

```js
{ doThis(); count++; }
```

Transformed event handler:

```js
() => { 
  doThis(); 
  count++;
}
```

In this situation, the engine cannot infer if you intended to return the `count++` value from the event handler. You must use the `return` statement to indicate the intention explicitly:

Original event handler:

```js
{ doThis(); return count++; }
```

Transformed event handler:

```js
() => { 
  doThis(); 
  return count++;
}
```

### Multiple Statements

The engine recognizes multiple statements and transforms them similarly to the body of block statements:

Original event handler:

```js
doThis(); count++;
```

Transformed event handler:

```js
() => { 
  doThis(); 
  count++;
}
```

<Callout type="info" emoji="ðŸ“”">
Be aware of using the `return` statement explicitly to retrieve a value from an event handler.
</Callout>