import { Callout } from 'nextra/components'
import { XMLUI_EMPTY, XMLUI_STARTER } from "../meta/downloads";
import { COMPONENT_APP, COMPONENT_FLOWLAYOUT, COMPONENT_HSTACK, COMPONENT_SPACEFILLER, COMPONENT_SPLITTER, COMPONENT_STACK, COMPONENT_VSTACK, MARKUP, THE_APP_COMPONENT, THE_APP_COMPONENT_LAYOUT_VARIANTS, WORKING_WITH_DATA, WORKING_WITH_DATA_PERSISTING_DATA, XMLUI_EXPRESSIONS_EXPRESSION_SYNTAX } from '../meta/pages';

# XMLUI Cheat Sheet

## Properties

You can influence components' visual appearance (and behavior) by setting component properties.

**Set a Simple Component Property**

Component properties are represented with attributes in the markup. Set this attribute value with a literal string.

```ueml copy /value="I'm a text!"/
<Text value="I'm a text!" />
```

**Set a component property with an expression**

You can use expressions to set up a property value. Expressions are wrapped in curly braces (between `{` and `}` characters).

```ueml copy /{6 * 7}/
<!-- Displays: "Life, universe, and everything: 42" -->
<Text value="Life, universe, and everything: {6 * 7}" />
```

**Set a component property with the `<property>` helper tag and nested value**

This construct is helpful when you want to set a property value to a component declaration (for example, you define a template with a property).

```ueml copy
<Items data="{[1, 2, 3]}">
  <property name="itemTemplate">
    <Text value="This item is: {$item}" />
  </property>
</Items>
```

**Set component presence and visibility**

By setting a component's `when` attribute to `false`, you can omit it from the markup tree (as if the definition were not there).

```ueml copy
<Text when="false" value="I'm omitted from the markup" />
```

Naturally, components omitted from the markup (`when` set to `false`) are not visible.

**Access exposed component properties**

You can assign an identifier to the component with the `id` attribute and use that to access its exposed properties.

```ueml copy /id="myTextBox"/ /{myTextBox.value}/
<App>
  <TextBox id="myTextBox" placeholder="Type something" />
  <Text variant="title">You typed: {myTextBox.value}</Text>
</App>
```

This way, you can bind components: changing a particular property of one will trigger changing the other.

**Invoke exposed component methods**

You can assign an identifier to the component with the `id` attribute and use that to invoke its exposed methods.

```ueml copy /id="myTextBox"/ /{myTextBox.value}/
<App>
  <Checkbox 
    id="myCheckbox" 
    label="Use encrypted channel"
    initialValue="false" />
  <Button label="Turn on encryption" onClick="myCheckbox.setValue(true)"/>
</App>
```

## Expressions

The expressions in XMLUI use the same syntax and semantics as JavaScript. For details on syntax, see this 
<SmartLink href={XMLUI_EXPRESSIONS_EXPRESSION_SYNTAX}>article</SmartLink>.

**Use an expression in a property value or component text**

Expressions are wrapped between curly braces; the engine evaluates them and replaces them with their actual value.

```ueml copy
<App>
  <Text value="{1 + 2 * 3}" /> <!-- Displays 7 -->
  <Text>{6 * 7}</Text>         <!-- Displays 42 -->
  <Text value="{ 3 < 4}" />    <!-- Displays true -->
</App>
```

**Use an expression for interpolation**

You can use multiple expressions combined with literal string segments in property values or component text.

```ueml copy
<App>
  <Text value="10 times 10 is {10*10} and not {9 * 10}" />
</App>
```

**Use curly braces in values**

Use `\{` as an escape for the opening curly brace. You do not need to escape the closing curly brace.

```ueml copy
<Text value="\{1 + 2 * 3}" /> <!-- Displays {1 + 2 * 3} -->
```

## Variables

Variable names start with a letter or an underscore (`_`) and continue with these characters or digits.

Variables are scoped; their name must be unique in the declaring scope. When you declare variables in markup, they are visible within the declaring component (including all direct and indirect children). When you declare them in a code-behind file, their scope is the markup within the corresponding file.

**Declare a variable with the `var.` prefix**

```ueml copy /var.myVar/ /{myVar}/
<App var.myVar="Hello, World!">
  <Text>{myVar}</Text> <!-- Displays: Hello, World! -->
</App>
```

**Declare a variable with the `<var>` helper tag and a nested value**

```ueml copy {2-4} /name="myVar"/ /{myVar}/
<App>
  <var name="myVar">
    Hello, World!
  </var>
  <Text>{myVar}</Text> <!-- Displays: Hello, World! -->
</App>
```

**Declare a variable in the code-behind file**

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
    <div style={{width: "50%", paddingRight: "0.25rem"}}>
```js copy filename="Main.xmlui.xs"
var myVar="Hello, World!";


```
    </div>
    <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```ueml copy filename="Main.xmlui" /{myVar}/
<App>
  <Text>{myVar}</Text>
</App>
```
    </div>
</div>

**Reusing a variable name in a nested scope**

The same variable name can be declared in nested scopes. The engine resolves the name to the variable in the closest (innermost) scope.

```ueml copy
<App var.myVar="Hello, from App!">
  <H1>{myVar}</H1> <!-- Displays: Hello, from App! -->
  <VStack var.myVar="Hello, from VStack!">
    <Text>{myVar}</Text> <!-- Displays: Hello, from VStack! -->
  </VStack>
</App>
```

**Leverage the reactive nature of variables**

If you initialize them with an expression, the engine detects any changes on which the variable value depends. When a change happens, the engine refreshes the UI.

```ueml copy
<App var.count="{0}" var.countTimes3="{3 * count}" >
  <Button
    label="Click to increment!"
    onClick="count++" />
  <Text>Click count = {count}</Text>
  <Text>Click count * 3 = {countTimes3}</Text>
</App>
```
Any time `count` is incremented, `count3Times` follows the change and will always have the value of three times `count.`

## Event Handlers

**Declare an event handler with the `on` attribute prefix**

You can define an event handler for a particular component event using an attribute with the `on` prefix followed by the event name:

```ueml copy /onClick="toast('Clicked!')"/
<Button label="Click me" onClick="toast('Clicked!')" />
```

**Declare an event handler with the `<event>` helper tag and nested value**

```ueml copy
<Button label="Click me">
  <event name="click">
    toast('Clicked!')
  </event>
</Button>
```

**Declare an event handler in the code-behind file**

You can assign the function's name declared in the code-behind file to the event handler in the markup.

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
    <div style={{width: "50%", paddingRight: "0.25rem"}}>
```js copy filename="Main.xmlui.xs"
function displayToast() {
  toast('Clicked!');
}
```
    </div>
    <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```ueml copy filename="Main.xmlui" /{myVar}/
<Button 
  label="Click me" 
  onClick="displayToast" />
```
    </div>
</div>

**Declare a code-behind event handler with auto markup-binding**

When your component must have an id, and the event handler function name follows the `[componentId]_on[eventName]` pattern, XMLUI automatically binds the event handler to the corresponding component.

<br/>
<div style={{display: "flex", flexDirection: "row"}}>
    <div style={{width: "50%", paddingRight: "0.25rem"}}>
```js copy filename="Main.xmlui.xs"
function myButton_onClick() {
  toast('Clicked!');
}
```
    </div>
    <div style={{width: "50%", paddingLeft: "0.25rem"}}>
```ueml copy filename="Main.xmlui" /{myVar}/
<Button
  id="myButton" 
  label="Click me" />
```
    </div>
</div>

<Callout type="info" emoji="ðŸ“”">
Use auto-binding of event handlers with care. Though your markup is shorter, you must look into the code-behind file to check if a component declares a particular event handler.
</Callout>

**Use an `APICall` component as an event handler**

The XMLUI engine supports using an `APICall` component definition as an event handler. This option is available only with the component markup (not in the code-behind file) using the `<event>` helper tag:

```ueml copy
<Button label="Delete Customer">
  <event name="click">
    <APICall 
      url="/api/customer/12345"
      method="delete"
      confirmMessage="Are you sure you want to delete the customer?"
    />
  </event>
</Button>
```

`APICall` provides valuable services (such as confirmation before the invocation and many others). Learn more in <SmartLink href={WORKING_WITH_DATA_PERSISTING_DATA}>this article</SmartLink>.

## Layout

XMLUI has a few fundamental components you can use to establish the app's layout. Their sole responsibility is to provide a viewport and organize the placement, dimensions, and other visual traits of their children.

| Component | Description |
| --------- | ----------- |
| <SmartLink href={COMPONENT_APP}>`App`</SmartLink> | ThisÂ component provides a UI frame for XMLUI apps. According to predefined (and run-time configurable) structure templates,Â `App`Â allows you to display your preferred layout. |
| <SmartLink href={COMPONENT_STACK}>`Stack`</SmartLink> | This component is a layout container displaying children in a horizontal or vertical stack. |
| <SmartLink href={COMPONENT_VSTACK}>`VStack`</SmartLink>, <SmartLink href={COMPONENT_HSTACK}>`HStack`</SmartLink> | These components are specialized versions of `Stack` that display children in a vertical or horizontal stack, respectively. |
| <SmartLink href={COMPONENT_FLOWLAYOUT}>`FlowLayout`</SmartLink> | This layout component is used to position content in rows with an auto wrapping feature: if the length of the items exceed the available space the layout will wrap into a new line. |
| <SmartLink href={COMPONENT_SPACEFILLER}>`SpaceFiler`</SmartLink> | This component works in layout containers to fill the remaining (unused) space. Its behavior depends on the layout container in which it is used. |
| <SmartLink href={COMPONENT_SPLITTER}>`Splitter`</SmartLink> | This component divides a container (such as a window, panel, pane, etc.) into two resizable sections. |


## Fetching Data

**Use a URL with the GET operation (list)**

Setting the `data` property of data-aware components (such as `List`, `Items`, `Table`, and others) to a string fetches the data from the specified URL (with the GET verb).

```ueml copy
<List data="/api/products">
  <Card title="{$item.name}" subtitle="{$item.description}"/>
</List>
```

**Use a URL with the GET operation (filtered list)**

```ueml copy
<App var.category="electronics">
  <Button label="Use books" onClick="category = 'books'" />
  <List data="/api/products/{category}" >
    <Card title="{$item.name}" subtitle="{$item.description}" />
  </List>
</App>
```

**Bind an input value with a URL**

You can combine the value of a particular input with the URL.

```ueml copy /{myTextBox.value}/ /myTextBox/ 
<App>
  <TextBox id="myTextBox" placeholder="Search value" />
  <List data="/api/products?search={myTextBox.value}" >
    <Card title="{$item.name}" subtitle="{$item.description}" />
  </List>
</App>
```

**Use a URL with another verb**

If you must use a verb other than GET, you can use a `DataSource` that provides more control over the request. The identifier of the `DataSource` is in the `data` property.

```ueml copy {2} /method="post"/ /{productSource}/ /productSource/
<App>
  <DataSource id="productSource" url="/api/products" method="post" />
  <List data="{productSource}" >
    <Card title="{$item.name}" subtitle="{$item.description}" />
  </List>
</App>
```

**Use a request header**

You can set a request header in a `DataSource` component.

```ueml copy {2-5} /headers/ /{productSource}/ /productSource/
<App>
  <DataSource 
    id="productSource" 
    url="/api/products"
    headers="{{ 'x-api-key': 'my-secret-key' }}" />
  <List data="{productSource}" >
    <Card title="{$item.name}" subtitle="{$item.description}" />
  </List>
</App>
```

**Select a part of the response as the result**

If the data you want to use is just a part of the response, you can drill down to the response segment with your data.

```ueml copy {2} /{productSource}/ /productSource/ /resultSelector="items"/
<App>
  <DataSource id="productSource" url="/api/products" resultSelector="items"/>
  <List data="{productSource}" >
    <Card title="{$item.name}" subtitle="{$item.description}" />
  </List>
</App>
```

This example assumes the response contains a `metadata` property (to ignore) and an `items` property (the actual payload for your query).

**Filter or modify the fetched result**

You can refer to the `value` property of a `DataSource` and use that to filter or modify the result.

```ueml copy {2} /{productSource}/ /productSource/ /resultSelector="items"/
<App>
  <DataSource id="productSource" url="/api/products" resultSelector="items"/>
  <List data="{productSource.value.filter(p => p.weight > 100)}" >
    <Card title="{$item.name}" subtitle="{$item.description}" />
  </List>
</App>
```

The markup in this example filters the product with a weight over 100 lbs.

## Calling an API

_TBD_ 

## Using Forms

_TBD_

## Dialogs

_TBD_

## Creating App-Specific components

_TBD_

## Using Themes

_TBD_



